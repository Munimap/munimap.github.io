<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="GMTW Trail Map">
    <meta name="theme-color" content="#0b0e14">
    <title>GMTW · Trail Map</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Barlow+Condensed:wght@400;600;700;800&family=Barlow:wght@400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha384-sHL9NAb7lN7rfvG5lfHpm643Xkcjzp4jFvuavGOndn6pjVqS6ny56CAt3nsEVT4H"
      crossorigin="anonymous"/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
      integrity="sha384-cxOPjt7s7Iz04uaHJceBmS+qpjv2JkIHNVcuOrM+YHwZOmJGBXI00mdUXEq65HTH"
      crossorigin="anonymous"></script>
    <!-- localforage 1.10.0 — IndexedDB-Wrapper (GPX-Caching, kein Quota-Limit) -->
    <script src="https://cdn.jsdelivr.net/npm/localforage@1.10.0/dist/localforage.min.js"></script>
    <!-- Turf.js 7 — Geo-Berechnungen (Distanz, Sektoren, Geofencing) -->
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@7/turf.min.js"></script>
    <!-- leaflet-gpx 1.7.0 — inline (kein CDN, kein SRI-Risiko) -->
    <script>
/**

 *GMTW MAP
 */

/*
 * Thanks to Pavel Shramov who provided the initial implementation and Leaflet
 * integration. Original code was at https://github.com/shramov/leaflet-plugins.
 *
 * It was then cleaned-up and modified to record and make available more
 * information about the GPX track while it is being parsed so that the result
 * can be used to display additional information about the track that is
 * rendered on the Leaflet map.
 */

var L = L || require('leaflet');

var _MAX_POINT_INTERVAL_MS = 15000;
var _SECOND_IN_MILLIS = 1000;
var _MINUTE_IN_MILLIS = 60 * _SECOND_IN_MILLIS;
var _HOUR_IN_MILLIS = 60 * _MINUTE_IN_MILLIS;
var _DAY_IN_MILLIS = 24 * _HOUR_IN_MILLIS;

var _GPX_STYLE_NS = 'http://www.topografix.com/GPX/gpx_style/0/2';

var _DEFAULT_MARKER_OPTS = {
  startIconUrl: 'pin-icon-start.png',
  endIconUrl: 'pin-icon-end.png',
  shadowUrl: 'pin-shadow.png',
  wptIcons: [],
  wptIconsType: [],
  wptIconUrls : {
    '': 'pin-icon-wpt.png',
  },
  wptIconTypeUrls : {
    '': 'pin-icon-wpt.png',
  },
  pointMatchers: [],
  iconSize: [33, 45],
  shadowSize: [50, 50],
  iconAnchor: [16, 45],
  shadowAnchor: [16, 47],
  clickable: false
};
var _DEFAULT_POLYLINE_OPTS = {
  color: 'blue'
};
var _DEFAULT_GPX_OPTS = {
  parseElements: ['track', 'route', 'waypoint'],
  joinTrackSegments: true
};

L.GPX = L.FeatureGroup.extend({
  initialize: function(gpx, options) {
    options.max_point_interval = options.max_point_interval || _MAX_POINT_INTERVAL_MS;
    options.marker_options = this._merge_objs(
      _DEFAULT_MARKER_OPTS,
      options.marker_options || {});
    options.polyline_options = options.polyline_options || {};
    options.gpx_options = this._merge_objs(
      _DEFAULT_GPX_OPTS,
      options.gpx_options || {});

    L.Util.setOptions(this, options);

    // Base icon class for track pins.
    L.GPXTrackIcon = L.Icon.extend({ options: options.marker_options });

    this._gpx = gpx;
    this._layers = {};
    this._init_info();

    if (gpx) {
      this._parse(gpx, options, this.options.async);
    }
  },

  get_duration_string: function(duration, hidems) {
    var s = '';

    if (duration >= _DAY_IN_MILLIS) {
      s += Math.floor(duration / _DAY_IN_MILLIS) + 'd ';
      duration = duration % _DAY_IN_MILLIS;
    }

    if (duration >= _HOUR_IN_MILLIS) {
      s += Math.floor(duration / _HOUR_IN_MILLIS) + ':';
      duration = duration % _HOUR_IN_MILLIS;
    }

    var mins = Math.floor(duration / _MINUTE_IN_MILLIS);
    duration = duration % _MINUTE_IN_MILLIS;
    if (mins < 10) s += '0';
    s += mins + '\'';

    var secs = Math.floor(duration / _SECOND_IN_MILLIS);
    duration = duration % _SECOND_IN_MILLIS;
    if (secs < 10) s += '0';
    s += secs;

    if (!hidems && duration > 0) s += '.' + Math.round(Math.floor(duration)*1000)/1000;
    else s += '"';

    return s;
  },

  get_duration_string_iso: function(duration, hidems) {
    var s = this.get_duration_string(duration, hidems);
    return s.replace("'",':').replace('"','');
  },

  // Public methods
  to_miles:            function(v) { return v / 1.60934; },
  to_ft:               function(v) { return v * 3.28084; },
  m_to_km:             function(v) { return v / 1000; },
  m_to_mi:             function(v) { return v / 1609.34; },
  ms_to_kmh:           function(v) { return v * 3.6; },
  ms_to_mih:           function(v) { return v / 1609.34 * 3600; },

  get_name:            function() { return this._info.name; },
  get_desc:            function() { return this._info.desc; },
  get_author:          function() { return this._info.author; },
  get_copyright:       function() { return this._info.copyright; },
  get_distance:        function() { return this._info.length; },
  get_distance_imp:    function() { return this.to_miles(this.m_to_km(this.get_distance())); },

  get_start_time:      function() { return this._info.duration.start; },
  get_end_time:        function() { return this._info.duration.end; },
  get_moving_time:     function() { return this._info.duration.moving; },
  get_total_time:      function() { return this._info.duration.total; },

  get_moving_pace:     function() { return this.get_moving_time() / this.m_to_km(this.get_distance()); },
  get_moving_pace_imp: function() { return this.get_moving_time() / this.get_distance_imp(); },

  get_moving_speed:    function() { return this.m_to_km(this.get_distance()) / (this.get_moving_time() / (3600 * 1000)) ; },
  get_moving_speed_imp:function() { return this.to_miles(this.m_to_km(this.get_distance())) / (this.get_moving_time() / (3600 * 1000)) ; },

  get_total_speed:     function() { return this.m_to_km(this.get_distance()) / (this.get_total_time() / (3600 * 1000)); },
  get_total_speed_imp: function() { return this.to_miles(this.m_to_km(this.get_distance())) / (this.get_total_time() / (3600 * 1000)); },

  get_elevation_gain:     function() { return this._info.elevation.gain; },
  get_elevation_loss:     function() { return this._info.elevation.loss; },
  get_elevation_gain_imp: function() { return this.to_ft(this.get_elevation_gain()); },
  get_elevation_loss_imp: function() { return this.to_ft(this.get_elevation_loss()); },
  get_elevation_data:     function() {
    var _this = this;
    return this._info.elevation._points.map(
      function(p) { return _this._prepare_data_point(p, _this.m_to_km, null,
        function(a, b) { return a.toFixed(2) + ' km, ' + b.toFixed(0) + ' m'; });
      });
  },
  get_elevation_data_imp: function() {
    var _this = this;
    return this._info.elevation._points.map(
      function(p) { return _this._prepare_data_point(p, _this.m_to_mi, _this.to_ft,
        function(a, b) { return a.toFixed(2) + ' mi, ' + b.toFixed(0) + ' ft'; });
      });
  },
  get_elevation_max:      function() { return this._info.elevation.max; },
  get_elevation_min:      function() { return this._info.elevation.min; },
  get_elevation_max_imp:  function() { return this.to_ft(this.get_elevation_max()); },
  get_elevation_min_imp:  function() { return this.to_ft(this.get_elevation_min()); },

  get_speed_data:         function() {
    var _this = this;
    return this._info.speed._points.map(
      function(p) { return _this._prepare_data_point(p, _this.m_to_km, _this.ms_to_kmh,
        function(a, b) { return a.toFixed(2) + ' km, ' + b.toFixed(2) + ' km/h'; });
      });
  },
  get_speed_data_imp: function() {
    var _this = this;
    return this._info.speed._points.map(
      function(p) { return _this._prepare_data_point(p, _this.m_to_mi, _this.ms_to_mih,
        function(a, b) { return a.toFixed(2) + ' mi, ' + b.toFixed(2) + ' mi/h'; });
      });
  },
  get_speed_max:          function() { return this.m_to_km(this._info.speed.max) * 3600; },
  get_speed_max_imp:      function() { return this.to_miles(this.get_speed_max()); },

  get_average_hr:         function() { return this._info.hr.avg; },
  get_average_temp:         function() { return this._info.atemp.avg; },
  get_average_cadence:         function() { return this._info.cad.avg; },
  get_heartrate_data:     function() {
    var _this = this;
    return this._info.hr._points.map(
      function(p) { return _this._prepare_data_point(p, _this.m_to_km, null,
        function(a, b) { return a.toFixed(2) + ' km, ' + b.toFixed(0) + ' bpm'; });
      });
  },
  get_heartrate_data_imp: function() {
    var _this = this;
    return this._info.hr._points.map(
      function(p) { return _this._prepare_data_point(p, _this.m_to_mi, null,
        function(a, b) { return a.toFixed(2) + ' mi, ' + b.toFixed(0) + ' bpm'; });
      });
  },
  get_cadence_data:     function() {
    var _this = this;
    return this._info.cad._points.map(
      function(p) { return _this._prepare_data_point(p, _this.m_to_km, null,
        function(a, b) { return a.toFixed(2) + ' km, ' + b.toFixed(0) + ' rpm'; });
      });
  },
  get_temp_data:     function() {
    var _this = this;
    return this._info.atemp._points.map(
      function(p) { return _this._prepare_data_point(p, _this.m_to_km, null,
        function(a, b) { return a.toFixed(2) + ' km, ' + b.toFixed(0) + ' degrees'; });
      });
  },
  get_cadence_data_imp:     function() {
    var _this = this;
    return this._info.cad._points.map(
      function(p) { return _this._prepare_data_point(p, _this.m_to_mi, null,
        function(a, b) { return a.toFixed(2) + ' mi, ' + b.toFixed(0) + ' rpm'; });
      });
  },
  get_temp_data_imp:     function() {
    var _this = this;
    return this._info.atemp._points.map(
      function(p) { return _this._prepare_data_point(p, _this.m_to_mi, null,
        function(a, b) { return a.toFixed(2) + ' mi, ' + b.toFixed(0) + ' degrees'; });
      });
  },

  reload: function() {
    this._init_info();
    this.clearLayers();
    this._parse(this._gpx, this.options, this.options.async);
  },

  // Private methods
  _merge_objs: function(a, b) {
    var _ = {};
    for (var attr in a) { _[attr] = a[attr]; }
    for (var attr in b) { _[attr] = b[attr]; }
    return _;
  },

  _prepare_data_point: function(p, trans1, trans2, trans_tooltip) {
    var r = [trans1 && trans1(p[0]) || p[0], trans2 && trans2(p[1]) || p[1]];
    r.push(trans_tooltip && trans_tooltip(r[0], r[1]) || (r[0] + ': ' + r[1]));
    return r;
  },

  _init_info: function() {
    this._info = {
      name: null,
      length: 0.0,
      elevation: {gain: 0.0, loss: 0.0, max: 0.0, min: Infinity, _points: []},
      speed : {max: 0.0, _points: []},
      hr: {avg: 0, _total: 0, _points: []},
      duration: {start: null, end: null, moving: 0, total: 0},
      atemp: {avg: 0, _total: 0, _points: []},
      cad: {avg: 0, _total: 0, _points: []}
    };
  },

  _load_xml: function(url, cb, options, async) {
    if (async == undefined) async = this.options.async;
    if (options == undefined) options = this.options;

    var req = new window.XMLHttpRequest();
    req.open('GET', url, async);
    try {
      req.overrideMimeType('text/xml'); // unsupported by IE
    } catch(e) {}
    req.onreadystatechange = function() {
      if (req.readyState != 4) return;
      if(req.status == 200) cb(req.responseXML, options);
    };
    req.send(null);
  },

  _parse: function(input, options, async) {
    var _this = this;
    var cb = function(gpx, options) {
      var layers = _this._parse_gpx_data(gpx, options);
      if (!layers) {
        _this.fire('error', { err: 'No parseable layers of type(s) ' + JSON.stringify(options.gpx_options.parseElements) });
        return;
      }
      _this.addLayer(layers);
      _this.fire('loaded', { layers: layers, element: gpx });
    }
    if (input.substr(0,1)==='<') { // direct XML has to start with a <
      var parser = new DOMParser();
      if (async) {
        setTimeout(function() {
          cb(parser.parseFromString(input, "text/xml"), options);
        });
      } else {
        cb(parser.parseFromString(input, "text/xml"), options);
      }
    } else {
      this._load_xml(input, cb, options, async);
    }
  },

  _parse_gpx_data: function(xml, options) {
    var i, t, l, el, layers = [];

    var name = xml.getElementsByTagName('name');
    if (name.length > 0) {
      this._info.name = name[0].textContent;
    }
    var desc = xml.getElementsByTagName('desc');
    if (desc.length > 0) {
      this._info.desc = desc[0].textContent;
    }
    var author = xml.getElementsByTagName('author');
    if (author.length > 0) {
      this._info.author = author[0].textContent;
    }
    var copyright = xml.getElementsByTagName('copyright');
    if (copyright.length > 0) {
      this._info.copyright = copyright[0].textContent;
    }

    var parseElements = options.gpx_options.parseElements;
    if (parseElements.indexOf('route') > -1) {
      // routes are <rtept> tags inside <rte> sections
      var routes = xml.getElementsByTagName('rte');
      for (i = 0; i < routes.length; i++) {
        layers = layers.concat(this._parse_segment(routes[i], options, {}, 'rtept'));
      }
    }

    if (parseElements.indexOf('track') > -1) {
      // tracks are <trkpt> tags in one or more <trkseg> sections in each <trk>
      var tracks = xml.getElementsByTagName('trk');
      for (i = 0; i < tracks.length; i++) {
        var track = tracks[i];
        var polyline_options = this._extract_styling(track);

        if (options.gpx_options.joinTrackSegments) {
          layers = layers.concat(this._parse_segment(track, options, polyline_options, 'trkpt'));
        } else {
          var segments = track.getElementsByTagName('trkseg');
          for (j = 0; j < segments.length; j++) {
            layers = layers.concat(this._parse_segment(segments[j], options, polyline_options, 'trkpt'));
          }
        }
      }
    }

    this._info.hr.avg = Math.round(this._info.hr._total / this._info.hr._points.length);
    this._info.cad.avg = Math.round(this._info.cad._total / this._info.cad._points.length);
    this._info.atemp.avg = Math.round(this._info.atemp._total / this._info.atemp._points.length);

    // parse waypoints and add markers for each of them
    if (parseElements.indexOf('waypoint') > -1) {
      el = xml.getElementsByTagName('wpt');
      for (i = 0; i < el.length; i++) {
        var ll = new L.LatLng(
            el[i].getAttribute('lat'),
            el[i].getAttribute('lon'));

        var nameEl = el[i].getElementsByTagName('name');
        var name = nameEl.length > 0 ? nameEl[0].textContent : '';

        var descEl = el[i].getElementsByTagName('desc');
        var desc = descEl.length > 0 ? descEl[0].textContent : '';

        var symEl = el[i].getElementsByTagName('sym');
        var symKey = symEl.length > 0 ? symEl[0].textContent : null;

        var typeEl = el[i].getElementsByTagName('type');
        var typeKey = typeEl.length > 0 ? typeEl[0].textContent : null;

        /*
         * Add waypoint marker based on the waypoint symbol key.
         *
         * First look for a configured icon for that symKey. If not found, look
         * for a configured icon URL for that symKey and build an icon from it.
         * If none of those match, look through the point matchers for a match
         * on the waypoint's name.
         *
         * Otherwise, fall back to the default icon if one was configured, or
         * finally to the default icon URL, if one was configured.
         */
        var wptIcons = options.marker_options.wptIcons;
        var wptIconUrls = options.marker_options.wptIconUrls;
        var wptIconsType = options.marker_options.wptIconsType;
        var wptIconTypeUrls = options.marker_options.wptIconTypeUrls;
        var ptMatchers = options.marker_options.pointMatchers || [];
        var symIcon;
        if (wptIcons && symKey && wptIcons[symKey]) {
          symIcon = wptIcons[symKey];
        } else if (wptIconsType && typeKey && wptIconsType[typeKey]) {
          symIcon = wptIconsType[typeKey];
        } else if (wptIconUrls && symKey && wptIconUrls[symKey]) {
          symIcon = new L.GPXTrackIcon({iconUrl: wptIconUrls[symKey]});
        } else if (wptIconTypeUrls && typeKey && wptIconTypeUrls[typeKey]) {
          symIcon = new L.GPXTrackIcon({iconUrl: wptIconTypeUrls[typeKey]});
        } else if (ptMatchers.length > 0) {
          for (var j = 0; j < ptMatchers.length; j++) {
            if (ptMatchers[j].regex.test(name)) {
              symIcon = ptMatchers[j].icon;
              break;
            }
          }
        } else if (wptIcons && wptIcons['']) {
          symIcon = wptIcons[''];
        } else if (wptIconUrls && wptIconUrls['']) {
          symIcon = new L.GPXTrackIcon({iconUrl: wptIconUrls['']});
        }

        if (!symIcon) {
          console.log(
            'No waypoint icon could be matched for symKey=%s,typeKey=%s,name=%s on waypoint %o',
            symKey, typeKey, name, el[i]);
          continue;
        }

        var marker = new L.Marker(ll, {
          clickable: options.marker_options.clickable,
          title: name,
          icon: symIcon,
          type: 'waypoint'
        });
        marker.bindPopup("<b>" + name + "</b>" + (desc.length > 0 ? '<br>' + desc : '')).openPopup();
        this.fire('addpoint', { point: marker, point_type: 'waypoint', element: el[i] });
        layers.push(marker);
      }
    }

    if (layers.length > 1) {
       return new L.FeatureGroup(layers);
    } else if (layers.length == 1) {
      return layers[0];
    }
  },

  _parse_segment: function(line, options, polyline_options, tag) {
    var el = line.getElementsByTagName(tag);
    if (!el.length) return [];

    var coords = [];
    var markers = [];
    var layers = [];
    var last = null;

    for (var i = 0; i < el.length; i++) {
      var _, ll = new L.LatLng(
        el[i].getAttribute('lat'),
        el[i].getAttribute('lon'));
      ll.meta = { time: null, ele: null, hr: null, cad: null, atemp: null, speed: null };

      _ = el[i].getElementsByTagName('time');
      if (_.length > 0) {
        ll.meta.time = new Date(Date.parse(_[0].textContent));
      } else {
        ll.meta.time = new Date('1970-01-01T00:00:00');
      }
      var time_diff = last != null ? Math.abs(ll.meta.time - last.meta.time) : 0;

      _ = el[i].getElementsByTagName('ele');
      if (_.length > 0) {
        ll.meta.ele = parseFloat(_[0].textContent);
      } else {
        // If the point doesn't have an <ele> tag, assume it has the same
        // elevation as the point before it (if it had one).
        ll.meta.ele = last != null ? last.meta.ele : null;
      }
      var ele_diff = last != null ? ll.meta.ele - last.meta.ele : 0;
      var dist_3d = last != null ? this._dist3d(last, ll) : 0;

      _ = el[i].getElementsByTagName('speed');
      if (_.length > 0) {
        ll.meta.speed = parseFloat(_[0].textContent);
      } else {
        // speed in meter per second
        ll.meta.speed = time_diff > 0 ? 1000.0 * dist_3d / time_diff : 0;
      }

      _ = el[i].getElementsByTagName('name');
      if (_.length > 0) {
        var name = _[0].textContent;
        var ptMatchers = options.marker_options.pointMatchers || [];

        for (var j = 0; j < ptMatchers.length; j++) {
          if (ptMatchers[j].regex.test(name)) {
            markers.push({ label: name, coords: ll, icon: ptMatchers[j].icon, element: el[i] });
            break;
          }
        }
      }

      _ = el[i].getElementsByTagNameNS('*', 'hr');
      if (_.length > 0) {
        ll.meta.hr = parseInt(_[0].textContent);
        this._info.hr._points.push([this._info.length, ll.meta.hr]);
        this._info.hr._total += ll.meta.hr;
      }

      _ = el[i].getElementsByTagNameNS('*', 'cad');
      if (_.length > 0) {
        ll.meta.cad = parseInt(_[0].textContent);
        this._info.cad._points.push([this._info.length, ll.meta.cad]);
        this._info.cad._total += ll.meta.cad;
      }

      _ = el[i].getElementsByTagNameNS('*', 'atemp');
      if (_.length > 0) {
        ll.meta.atemp = parseInt(_[0].textContent);
        this._info.atemp._points.push([this._info.length, ll.meta.atemp]);
        this._info.atemp._total += ll.meta.atemp;
      }

      if (ll.meta.ele > this._info.elevation.max) {
        this._info.elevation.max = ll.meta.ele;
      }
      if (ll.meta.ele < this._info.elevation.min) {
        this._info.elevation.min = ll.meta.ele;
      }
      this._info.elevation._points.push([this._info.length, ll.meta.ele]);

      if (ll.meta.speed > this._info.speed.max) {
        this._info.speed.max = ll.meta.speed;
      }
      this._info.speed._points.push([this._info.length, ll.meta.speed]);

      if ((last == null) && (this._info.duration.start == null)) {
        this._info.duration.start = ll.meta.time;
      }
      this._info.duration.end = ll.meta.time;
      this._info.duration.total += time_diff;
      if (time_diff < options.max_point_interval) {
        this._info.duration.moving += time_diff;
      }

      this._info.length += dist_3d;

      if (ele_diff > 0) {
        this._info.elevation.gain += ele_diff;
      } else {
        this._info.elevation.loss += Math.abs(ele_diff);
      }

      last = ll;
      coords.push(ll);
    }

    // add track
    var l = new L.Polyline(coords, this._extract_styling(line, polyline_options, options.polyline_options));
    this.fire('addline', { line: l, element: line });
    layers.push(l);

    if (options.marker_options.startIcon || options.marker_options.startIconUrl) {
      // add start pin
      var marker = new L.Marker(coords[0], {
        clickable: options.marker_options.clickable,
        icon: options.marker_options.startIcon || new L.GPXTrackIcon({iconUrl: options.marker_options.startIconUrl})
      });
      this.fire('addpoint', { point: marker, point_type: 'start', element: el[0] });
      layers.push(marker);
    }

    if (options.marker_options.endIcon || options.marker_options.endIconUrl) {
      // add end pin
      var marker = new L.Marker(coords[coords.length-1], {
        clickable: options.marker_options.clickable,
        icon: options.marker_options.endIcon || new L.GPXTrackIcon({iconUrl: options.marker_options.endIconUrl})
      });
      this.fire('addpoint', { point: marker, point_type: 'end', element: el[el.length-1] });
      layers.push(marker);
    }

    // add named markers
    for (var i = 0; i < markers.length; i++) {
      var marker = new L.Marker(markers[i].coords, {
        clickable: options.marker_options.clickable,
        title: markers[i].label,
        icon: markers[i].icon
      });
      this.fire('addpoint', { point: marker, point_type: 'label', element: markers[i].element });
      layers.push(marker);
    }

    return layers;
  },

  _extract_styling: function(el, base, overrides) {
    var style = this._merge_objs(_DEFAULT_POLYLINE_OPTS, base);
    var e = el.getElementsByTagNameNS(_GPX_STYLE_NS, 'line');
    if (e.length > 0) {
      var _ = e[0].getElementsByTagName('color');
      if (_.length > 0) style.color = '#' + _[0].textContent;
      var _ = e[0].getElementsByTagName('opacity');
      if (_.length > 0) style.opacity = _[0].textContent;
      var _ = e[0].getElementsByTagName('weight');
      if (_.length > 0) style.weight = _[0].textContent;
      var _ = e[0].getElementsByTagName('linecap');
      if (_.length > 0) style.lineCap = _[0].textContent;
      var _ = e[0].getElementsByTagName('linejoin');
      if (_.length > 0) style.lineJoin = _[0].textContent;
      var _ = e[0].getElementsByTagName('dasharray');
      if (_.length > 0) style.dashArray = _[0].textContent;
      var _ = e[0].getElementsByTagName('dashoffset');
      if (_.length > 0) style.dashOffset = _[0].textContent;
    }
    return this._merge_objs(style, overrides)
  },

  _dist2d: function(a, b) {
    var R = 6371000;
    var dLat = this._deg2rad(b.lat - a.lat);
    var dLon = this._deg2rad(b.lng - a.lng);
    var r = Math.sin(dLat/2) *
      Math.sin(dLat/2) +
      Math.cos(this._deg2rad(a.lat)) *
      Math.cos(this._deg2rad(b.lat)) *
      Math.sin(dLon/2) *
      Math.sin(dLon/2);
    var c = 2 * Math.atan2(Math.sqrt(r), Math.sqrt(1-r));
    var d = R * c;
    return d;
  },

  _dist3d: function(a, b) {
    var planar = this._dist2d(a, b);
    var height = Math.abs(b.meta.ele - a.meta.ele);
    return Math.sqrt(Math.pow(planar, 2) + Math.pow(height, 2));
  },

  _deg2rad: function(deg) {
    return deg * Math.PI / 180;
  }
});

/* inline — L.GPX already attached to window.L */

    </script>
    <!-- QR-Code Generator (qrcode-generator 1.4.4) — inline, kein CDN -->
    <script>
//---------------------------------------------------------------------
//
// QR Code Generator for JavaScript
//
// Copyright (c) 2009 Kazuhiko Arase
//
// URL: http://www.d-project.com/
//
// Licensed under the MIT license:
//  http://www.opensource.org/licenses/mit-license.php
//
// The word 'QR Code' is registered trademark of
// DENSO WAVE INCORPORATED
//  http://www.denso-wave.com/qrcode/faqpatent-e.html
//
//---------------------------------------------------------------------

var qrcode = function() {

  //---------------------------------------------------------------------
  // qrcode
  //---------------------------------------------------------------------

  /**
   * qrcode
   * @param typeNumber 1 to 40
   * @param errorCorrectionLevel 'L','M','Q','H'
   */
  var qrcode = function(typeNumber, errorCorrectionLevel) {

    var PAD0 = 0xEC;
    var PAD1 = 0x11;

    var _typeNumber = typeNumber;
    var _errorCorrectionLevel = QRErrorCorrectionLevel[errorCorrectionLevel];
    var _modules = null;
    var _moduleCount = 0;
    var _dataCache = null;
    var _dataList = [];

    var _this = {};

    var makeImpl = function(test, maskPattern) {

      _moduleCount = _typeNumber * 4 + 17;
      _modules = function(moduleCount) {
        var modules = new Array(moduleCount);
        for (var row = 0; row < moduleCount; row += 1) {
          modules[row] = new Array(moduleCount);
          for (var col = 0; col < moduleCount; col += 1) {
            modules[row][col] = null;
          }
        }
        return modules;
      }(_moduleCount);

      setupPositionProbePattern(0, 0);
      setupPositionProbePattern(_moduleCount - 7, 0);
      setupPositionProbePattern(0, _moduleCount - 7);
      setupPositionAdjustPattern();
      setupTimingPattern();
      setupTypeInfo(test, maskPattern);

      if (_typeNumber >= 7) {
        setupTypeNumber(test);
      }

      if (_dataCache == null) {
        _dataCache = createData(_typeNumber, _errorCorrectionLevel, _dataList);
      }

      mapData(_dataCache, maskPattern);
    };

    var setupPositionProbePattern = function(row, col) {

      for (var r = -1; r <= 7; r += 1) {

        if (row + r <= -1 || _moduleCount <= row + r) continue;

        for (var c = -1; c <= 7; c += 1) {

          if (col + c <= -1 || _moduleCount <= col + c) continue;

          if ( (0 <= r && r <= 6 && (c == 0 || c == 6) )
              || (0 <= c && c <= 6 && (r == 0 || r == 6) )
              || (2 <= r && r <= 4 && 2 <= c && c <= 4) ) {
            _modules[row + r][col + c] = true;
          } else {
            _modules[row + r][col + c] = false;
          }
        }
      }
    };

    var getBestMaskPattern = function() {

      var minLostPoint = 0;
      var pattern = 0;

      for (var i = 0; i < 8; i += 1) {

        makeImpl(true, i);

        var lostPoint = QRUtil.getLostPoint(_this);

        if (i == 0 || minLostPoint > lostPoint) {
          minLostPoint = lostPoint;
          pattern = i;
        }
      }

      return pattern;
    };

    var setupTimingPattern = function() {

      for (var r = 8; r < _moduleCount - 8; r += 1) {
        if (_modules[r][6] != null) {
          continue;
        }
        _modules[r][6] = (r % 2 == 0);
      }

      for (var c = 8; c < _moduleCount - 8; c += 1) {
        if (_modules[6][c] != null) {
          continue;
        }
        _modules[6][c] = (c % 2 == 0);
      }
    };

    var setupPositionAdjustPattern = function() {

      var pos = QRUtil.getPatternPosition(_typeNumber);

      for (var i = 0; i < pos.length; i += 1) {

        for (var j = 0; j < pos.length; j += 1) {

          var row = pos[i];
          var col = pos[j];

          if (_modules[row][col] != null) {
            continue;
          }

          for (var r = -2; r <= 2; r += 1) {

            for (var c = -2; c <= 2; c += 1) {

              if (r == -2 || r == 2 || c == -2 || c == 2
                  || (r == 0 && c == 0) ) {
                _modules[row + r][col + c] = true;
              } else {
                _modules[row + r][col + c] = false;
              }
            }
          }
        }
      }
    };

    var setupTypeNumber = function(test) {

      var bits = QRUtil.getBCHTypeNumber(_typeNumber);

      for (var i = 0; i < 18; i += 1) {
        var mod = (!test && ( (bits >> i) & 1) == 1);
        _modules[Math.floor(i / 3)][i % 3 + _moduleCount - 8 - 3] = mod;
      }

      for (var i = 0; i < 18; i += 1) {
        var mod = (!test && ( (bits >> i) & 1) == 1);
        _modules[i % 3 + _moduleCount - 8 - 3][Math.floor(i / 3)] = mod;
      }
    };

    var setupTypeInfo = function(test, maskPattern) {

      var data = (_errorCorrectionLevel << 3) | maskPattern;
      var bits = QRUtil.getBCHTypeInfo(data);

      // vertical
      for (var i = 0; i < 15; i += 1) {

        var mod = (!test && ( (bits >> i) & 1) == 1);

        if (i < 6) {
          _modules[i][8] = mod;
        } else if (i < 8) {
          _modules[i + 1][8] = mod;
        } else {
          _modules[_moduleCount - 15 + i][8] = mod;
        }
      }

      // horizontal
      for (var i = 0; i < 15; i += 1) {

        var mod = (!test && ( (bits >> i) & 1) == 1);

        if (i < 8) {
          _modules[8][_moduleCount - i - 1] = mod;
        } else if (i < 9) {
          _modules[8][15 - i - 1 + 1] = mod;
        } else {
          _modules[8][15 - i - 1] = mod;
        }
      }

      // fixed module
      _modules[_moduleCount - 8][8] = (!test);
    };

    var mapData = function(data, maskPattern) {

      var inc = -1;
      var row = _moduleCount - 1;
      var bitIndex = 7;
      var byteIndex = 0;
      var maskFunc = QRUtil.getMaskFunction(maskPattern);

      for (var col = _moduleCount - 1; col > 0; col -= 2) {

        if (col == 6) col -= 1;

        while (true) {

          for (var c = 0; c < 2; c += 1) {

            if (_modules[row][col - c] == null) {

              var dark = false;

              if (byteIndex < data.length) {
                dark = ( ( (data[byteIndex] >>> bitIndex) & 1) == 1);
              }

              var mask = maskFunc(row, col - c);

              if (mask) {
                dark = !dark;
              }

              _modules[row][col - c] = dark;
              bitIndex -= 1;

              if (bitIndex == -1) {
                byteIndex += 1;
                bitIndex = 7;
              }
            }
          }

          row += inc;

          if (row < 0 || _moduleCount <= row) {
            row -= inc;
            inc = -inc;
            break;
          }
        }
      }
    };

    var createBytes = function(buffer, rsBlocks) {

      var offset = 0;

      var maxDcCount = 0;
      var maxEcCount = 0;

      var dcdata = new Array(rsBlocks.length);
      var ecdata = new Array(rsBlocks.length);

      for (var r = 0; r < rsBlocks.length; r += 1) {

        var dcCount = rsBlocks[r].dataCount;
        var ecCount = rsBlocks[r].totalCount - dcCount;

        maxDcCount = Math.max(maxDcCount, dcCount);
        maxEcCount = Math.max(maxEcCount, ecCount);

        dcdata[r] = new Array(dcCount);

        for (var i = 0; i < dcdata[r].length; i += 1) {
          dcdata[r][i] = 0xff & buffer.getBuffer()[i + offset];
        }
        offset += dcCount;

        var rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);
        var rawPoly = qrPolynomial(dcdata[r], rsPoly.getLength() - 1);

        var modPoly = rawPoly.mod(rsPoly);
        ecdata[r] = new Array(rsPoly.getLength() - 1);
        for (var i = 0; i < ecdata[r].length; i += 1) {
          var modIndex = i + modPoly.getLength() - ecdata[r].length;
          ecdata[r][i] = (modIndex >= 0)? modPoly.getAt(modIndex) : 0;
        }
      }

      var totalCodeCount = 0;
      for (var i = 0; i < rsBlocks.length; i += 1) {
        totalCodeCount += rsBlocks[i].totalCount;
      }

      var data = new Array(totalCodeCount);
      var index = 0;

      for (var i = 0; i < maxDcCount; i += 1) {
        for (var r = 0; r < rsBlocks.length; r += 1) {
          if (i < dcdata[r].length) {
            data[index] = dcdata[r][i];
            index += 1;
          }
        }
      }

      for (var i = 0; i < maxEcCount; i += 1) {
        for (var r = 0; r < rsBlocks.length; r += 1) {
          if (i < ecdata[r].length) {
            data[index] = ecdata[r][i];
            index += 1;
          }
        }
      }

      return data;
    };

    var createData = function(typeNumber, errorCorrectionLevel, dataList) {

      var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectionLevel);

      var buffer = qrBitBuffer();

      for (var i = 0; i < dataList.length; i += 1) {
        var data = dataList[i];
        buffer.put(data.getMode(), 4);
        buffer.put(data.getLength(), QRUtil.getLengthInBits(data.getMode(), typeNumber) );
        data.write(buffer);
      }

      // calc num max data.
      var totalDataCount = 0;
      for (var i = 0; i < rsBlocks.length; i += 1) {
        totalDataCount += rsBlocks[i].dataCount;
      }

      if (buffer.getLengthInBits() > totalDataCount * 8) {
        throw 'code length overflow. ('
          + buffer.getLengthInBits()
          + '>'
          + totalDataCount * 8
          + ')';
      }

      // end code
      if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {
        buffer.put(0, 4);
      }

      // padding
      while (buffer.getLengthInBits() % 8 != 0) {
        buffer.putBit(false);
      }

      // padding
      while (true) {

        if (buffer.getLengthInBits() >= totalDataCount * 8) {
          break;
        }
        buffer.put(PAD0, 8);

        if (buffer.getLengthInBits() >= totalDataCount * 8) {
          break;
        }
        buffer.put(PAD1, 8);
      }

      return createBytes(buffer, rsBlocks);
    };

    _this.addData = function(data, mode) {

      mode = mode || 'Byte';

      var newData = null;

      switch(mode) {
      case 'Numeric' :
        newData = qrNumber(data);
        break;
      case 'Alphanumeric' :
        newData = qrAlphaNum(data);
        break;
      case 'Byte' :
        newData = qr8BitByte(data);
        break;
      case 'Kanji' :
        newData = qrKanji(data);
        break;
      default :
        throw 'mode:' + mode;
      }

      _dataList.push(newData);
      _dataCache = null;
    };

    _this.isDark = function(row, col) {
      if (row < 0 || _moduleCount <= row || col < 0 || _moduleCount <= col) {
        throw row + ',' + col;
      }
      return _modules[row][col];
    };

    _this.getModuleCount = function() {
      return _moduleCount;
    };

    _this.make = function() {
      if (_typeNumber < 1) {
        var typeNumber = 1;

        for (; typeNumber < 40; typeNumber++) {
          var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, _errorCorrectionLevel);
          var buffer = qrBitBuffer();

          for (var i = 0; i < _dataList.length; i++) {
            var data = _dataList[i];
            buffer.put(data.getMode(), 4);
            buffer.put(data.getLength(), QRUtil.getLengthInBits(data.getMode(), typeNumber) );
            data.write(buffer);
          }

          var totalDataCount = 0;
          for (var i = 0; i < rsBlocks.length; i++) {
            totalDataCount += rsBlocks[i].dataCount;
          }

          if (buffer.getLengthInBits() <= totalDataCount * 8) {
            break;
          }
        }

        _typeNumber = typeNumber;
      }

      makeImpl(false, getBestMaskPattern() );
    };

    _this.createTableTag = function(cellSize, margin) {

      cellSize = cellSize || 2;
      margin = (typeof margin == 'undefined')? cellSize * 4 : margin;

      var qrHtml = '';

      qrHtml += '<table style="';
      qrHtml += ' border-width: 0px; border-style: none;';
      qrHtml += ' border-collapse: collapse;';
      qrHtml += ' padding: 0px; margin: ' + margin + 'px;';
      qrHtml += '">';
      qrHtml += '<tbody>';

      for (var r = 0; r < _this.getModuleCount(); r += 1) {

        qrHtml += '<tr>';

        for (var c = 0; c < _this.getModuleCount(); c += 1) {
          qrHtml += '<td style="';
          qrHtml += ' border-width: 0px; border-style: none;';
          qrHtml += ' border-collapse: collapse;';
          qrHtml += ' padding: 0px; margin: 0px;';
          qrHtml += ' width: ' + cellSize + 'px;';
          qrHtml += ' height: ' + cellSize + 'px;';
          qrHtml += ' background-color: ';
          qrHtml += _this.isDark(r, c)? '#000000' : '#ffffff';
          qrHtml += ';';
          qrHtml += '"/>';
        }

        qrHtml += '</tr>';
      }

      qrHtml += '</tbody>';
      qrHtml += '</table>';

      return qrHtml;
    };

    _this.createSvgTag = function(cellSize, margin, alt, title) {

      var opts = {};
      if (typeof arguments[0] == 'object') {
        // Called by options.
        opts = arguments[0];
        // overwrite cellSize and margin.
        cellSize = opts.cellSize;
        margin = opts.margin;
        alt = opts.alt;
        title = opts.title;
      }

      cellSize = cellSize || 2;
      margin = (typeof margin == 'undefined')? cellSize * 4 : margin;

      // Compose alt property surrogate
      alt = (typeof alt === 'string') ? {text: alt} : alt || {};
      alt.text = alt.text || null;
      alt.id = (alt.text) ? alt.id || 'qrcode-description' : null;

      // Compose title property surrogate
      title = (typeof title === 'string') ? {text: title} : title || {};
      title.text = title.text || null;
      title.id = (title.text) ? title.id || 'qrcode-title' : null;

      var size = _this.getModuleCount() * cellSize + margin * 2;
      var c, mc, r, mr, qrSvg='', rect;

      rect = 'l' + cellSize + ',0 0,' + cellSize +
        ' -' + cellSize + ',0 0,-' + cellSize + 'z ';

      qrSvg += '<svg version="1.1" xmlns="http://www.w3.org/2000/svg"';
      qrSvg += !opts.scalable ? ' width="' + size + 'px" height="' + size + 'px"' : '';
      qrSvg += ' viewBox="0 0 ' + size + ' ' + size + '" ';
      qrSvg += ' preserveAspectRatio="xMinYMin meet"';
      qrSvg += (title.text || alt.text) ? ' role="img" aria-labelledby="' +
          escapeXml([title.id, alt.id].join(' ').trim() ) + '"' : '';
      qrSvg += '>';
      qrSvg += (title.text) ? '<title id="' + escapeXml(title.id) + '">' +
          escapeXml(title.text) + '</title>' : '';
      qrSvg += (alt.text) ? '<description id="' + escapeXml(alt.id) + '">' +
          escapeXml(alt.text) + '</description>' : '';
      qrSvg += '<rect width="100%" height="100%" fill="white" cx="0" cy="0"/>';
      qrSvg += '<path d="';

      for (r = 0; r < _this.getModuleCount(); r += 1) {
        mr = r * cellSize + margin;
        for (c = 0; c < _this.getModuleCount(); c += 1) {
          if (_this.isDark(r, c) ) {
            mc = c*cellSize+margin;
            qrSvg += 'M' + mc + ',' + mr + rect;
          }
        }
      }

      qrSvg += '" stroke="transparent" fill="black"/>';
      qrSvg += '</svg>';

      return qrSvg;
    };

    _this.createDataURL = function(cellSize, margin) {

      cellSize = cellSize || 2;
      margin = (typeof margin == 'undefined')? cellSize * 4 : margin;

      var size = _this.getModuleCount() * cellSize + margin * 2;
      var min = margin;
      var max = size - margin;

      return createDataURL(size, size, function(x, y) {
        if (min <= x && x < max && min <= y && y < max) {
          var c = Math.floor( (x - min) / cellSize);
          var r = Math.floor( (y - min) / cellSize);
          return _this.isDark(r, c)? 0 : 1;
        } else {
          return 1;
        }
      } );
    };

    _this.createImgTag = function(cellSize, margin, alt) {

      cellSize = cellSize || 2;
      margin = (typeof margin == 'undefined')? cellSize * 4 : margin;

      var size = _this.getModuleCount() * cellSize + margin * 2;

      var img = '';
      img += '<img';
      img += '\u0020src="';
      img += _this.createDataURL(cellSize, margin);
      img += '"';
      img += '\u0020width="';
      img += size;
      img += '"';
      img += '\u0020height="';
      img += size;
      img += '"';
      if (alt) {
        img += '\u0020alt="';
        img += escapeXml(alt);
        img += '"';
      }
      img += '/>';

      return img;
    };

    var escapeXml = function(s) {
      var escaped = '';
      for (var i = 0; i < s.length; i += 1) {
        var c = s.charAt(i);
        switch(c) {
        case '<': escaped += '&lt;'; break;
        case '>': escaped += '&gt;'; break;
        case '&': escaped += '&amp;'; break;
        case '"': escaped += '&quot;'; break;
        default : escaped += c; break;
        }
      }
      return escaped;
    };

    var _createHalfASCII = function(margin) {
      var cellSize = 1;
      margin = (typeof margin == 'undefined')? cellSize * 2 : margin;

      var size = _this.getModuleCount() * cellSize + margin * 2;
      var min = margin;
      var max = size - margin;

      var y, x, r1, r2, p;

      var blocks = {
        '██': '█',
        '█ ': '▀',
        ' █': '▄',
        '  ': ' '
      };

      var blocksLastLineNoMargin = {
        '██': '▀',
        '█ ': '▀',
        ' █': ' ',
        '  ': ' '
      };

      var ascii = '';
      for (y = 0; y < size; y += 2) {
        r1 = Math.floor((y - min) / cellSize);
        r2 = Math.floor((y + 1 - min) / cellSize);
        for (x = 0; x < size; x += 1) {
          p = '█';

          if (min <= x && x < max && min <= y && y < max && _this.isDark(r1, Math.floor((x - min) / cellSize))) {
            p = ' ';
          }

          if (min <= x && x < max && min <= y+1 && y+1 < max && _this.isDark(r2, Math.floor((x - min) / cellSize))) {
            p += ' ';
          }
          else {
            p += '█';
          }

          // Output 2 characters per pixel, to create full square. 1 character per pixels gives only half width of square.
          ascii += (margin < 1 && y+1 >= max) ? blocksLastLineNoMargin[p] : blocks[p];
        }

        ascii += '\n';
      }

      if (size % 2 && margin > 0) {
        return ascii.substring(0, ascii.length - size - 1) + Array(size+1).join('▀');
      }

      return ascii.substring(0, ascii.length-1);
    };

    _this.createASCII = function(cellSize, margin) {
      cellSize = cellSize || 1;

      if (cellSize < 2) {
        return _createHalfASCII(margin);
      }

      cellSize -= 1;
      margin = (typeof margin == 'undefined')? cellSize * 2 : margin;

      var size = _this.getModuleCount() * cellSize + margin * 2;
      var min = margin;
      var max = size - margin;

      var y, x, r, p;

      var white = Array(cellSize+1).join('██');
      var black = Array(cellSize+1).join('  ');

      var ascii = '';
      var line = '';
      for (y = 0; y < size; y += 1) {
        r = Math.floor( (y - min) / cellSize);
        line = '';
        for (x = 0; x < size; x += 1) {
          p = 1;

          if (min <= x && x < max && min <= y && y < max && _this.isDark(r, Math.floor((x - min) / cellSize))) {
            p = 0;
          }

          // Output 2 characters per pixel, to create full square. 1 character per pixels gives only half width of square.
          line += p ? white : black;
        }

        for (r = 0; r < cellSize; r += 1) {
          ascii += line + '\n';
        }
      }

      return ascii.substring(0, ascii.length-1);
    };

    _this.renderTo2dContext = function(context, cellSize) {
      cellSize = cellSize || 2;
      var length = _this.getModuleCount();
      for (var row = 0; row < length; row++) {
        for (var col = 0; col < length; col++) {
          context.fillStyle = _this.isDark(row, col) ? 'black' : 'white';
          context.fillRect(row * cellSize, col * cellSize, cellSize, cellSize);
        }
      }
    }

    return _this;
  };

  //---------------------------------------------------------------------
  // qrcode.stringToBytes
  //---------------------------------------------------------------------

  qrcode.stringToBytesFuncs = {
    'default' : function(s) {
      var bytes = [];
      for (var i = 0; i < s.length; i += 1) {
        var c = s.charCodeAt(i);
        bytes.push(c & 0xff);
      }
      return bytes;
    }
  };

  qrcode.stringToBytes = qrcode.stringToBytesFuncs['default'];

  //---------------------------------------------------------------------
  // qrcode.createStringToBytes
  //---------------------------------------------------------------------

  /**
   * @param unicodeData base64 string of byte array.
   * [16bit Unicode],[16bit Bytes], ...
   * @param numChars
   */
  qrcode.createStringToBytes = function(unicodeData, numChars) {

    // create conversion map.

    var unicodeMap = function() {

      var bin = base64DecodeInputStream(unicodeData);
      var read = function() {
        var b = bin.read();
        if (b == -1) throw 'eof';
        return b;
      };

      var count = 0;
      var unicodeMap = {};
      while (true) {
        var b0 = bin.read();
        if (b0 == -1) break;
        var b1 = read();
        var b2 = read();
        var b3 = read();
        var k = String.fromCharCode( (b0 << 8) | b1);
        var v = (b2 << 8) | b3;
        unicodeMap[k] = v;
        count += 1;
      }
      if (count != numChars) {
        throw count + ' != ' + numChars;
      }

      return unicodeMap;
    }();

    var unknownChar = '?'.charCodeAt(0);

    return function(s) {
      var bytes = [];
      for (var i = 0; i < s.length; i += 1) {
        var c = s.charCodeAt(i);
        if (c < 128) {
          bytes.push(c);
        } else {
          var b = unicodeMap[s.charAt(i)];
          if (typeof b == 'number') {
            if ( (b & 0xff) == b) {
              // 1byte
              bytes.push(b);
            } else {
              // 2bytes
              bytes.push(b >>> 8);
              bytes.push(b & 0xff);
            }
          } else {
            bytes.push(unknownChar);
          }
        }
      }
      return bytes;
    };
  };

  //---------------------------------------------------------------------
  // QRMode
  //---------------------------------------------------------------------

  var QRMode = {
    MODE_NUMBER :    1 << 0,
    MODE_ALPHA_NUM : 1 << 1,
    MODE_8BIT_BYTE : 1 << 2,
    MODE_KANJI :     1 << 3
  };

  //---------------------------------------------------------------------
  // QRErrorCorrectionLevel
  //---------------------------------------------------------------------

  var QRErrorCorrectionLevel = {
    L : 1,
    M : 0,
    Q : 3,
    H : 2
  };

  //---------------------------------------------------------------------
  // QRMaskPattern
  //---------------------------------------------------------------------

  var QRMaskPattern = {
    PATTERN000 : 0,
    PATTERN001 : 1,
    PATTERN010 : 2,
    PATTERN011 : 3,
    PATTERN100 : 4,
    PATTERN101 : 5,
    PATTERN110 : 6,
    PATTERN111 : 7
  };

  //---------------------------------------------------------------------
  // QRUtil
  //---------------------------------------------------------------------

  var QRUtil = function() {

    var PATTERN_POSITION_TABLE = [
      [],
      [6, 18],
      [6, 22],
      [6, 26],
      [6, 30],
      [6, 34],
      [6, 22, 38],
      [6, 24, 42],
      [6, 26, 46],
      [6, 28, 50],
      [6, 30, 54],
      [6, 32, 58],
      [6, 34, 62],
      [6, 26, 46, 66],
      [6, 26, 48, 70],
      [6, 26, 50, 74],
      [6, 30, 54, 78],
      [6, 30, 56, 82],
      [6, 30, 58, 86],
      [6, 34, 62, 90],
      [6, 28, 50, 72, 94],
      [6, 26, 50, 74, 98],
      [6, 30, 54, 78, 102],
      [6, 28, 54, 80, 106],
      [6, 32, 58, 84, 110],
      [6, 30, 58, 86, 114],
      [6, 34, 62, 90, 118],
      [6, 26, 50, 74, 98, 122],
      [6, 30, 54, 78, 102, 126],
      [6, 26, 52, 78, 104, 130],
      [6, 30, 56, 82, 108, 134],
      [6, 34, 60, 86, 112, 138],
      [6, 30, 58, 86, 114, 142],
      [6, 34, 62, 90, 118, 146],
      [6, 30, 54, 78, 102, 126, 150],
      [6, 24, 50, 76, 102, 128, 154],
      [6, 28, 54, 80, 106, 132, 158],
      [6, 32, 58, 84, 110, 136, 162],
      [6, 26, 54, 82, 110, 138, 166],
      [6, 30, 58, 86, 114, 142, 170]
    ];
    var G15 = (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0);
    var G18 = (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0);
    var G15_MASK = (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1);

    var _this = {};

    var getBCHDigit = function(data) {
      var digit = 0;
      while (data != 0) {
        digit += 1;
        data >>>= 1;
      }
      return digit;
    };

    _this.getBCHTypeInfo = function(data) {
      var d = data << 10;
      while (getBCHDigit(d) - getBCHDigit(G15) >= 0) {
        d ^= (G15 << (getBCHDigit(d) - getBCHDigit(G15) ) );
      }
      return ( (data << 10) | d) ^ G15_MASK;
    };

    _this.getBCHTypeNumber = function(data) {
      var d = data << 12;
      while (getBCHDigit(d) - getBCHDigit(G18) >= 0) {
        d ^= (G18 << (getBCHDigit(d) - getBCHDigit(G18) ) );
      }
      return (data << 12) | d;
    };

    _this.getPatternPosition = function(typeNumber) {
      return PATTERN_POSITION_TABLE[typeNumber - 1];
    };

    _this.getMaskFunction = function(maskPattern) {

      switch (maskPattern) {

      case QRMaskPattern.PATTERN000 :
        return function(i, j) { return (i + j) % 2 == 0; };
      case QRMaskPattern.PATTERN001 :
        return function(i, j) { return i % 2 == 0; };
      case QRMaskPattern.PATTERN010 :
        return function(i, j) { return j % 3 == 0; };
      case QRMaskPattern.PATTERN011 :
        return function(i, j) { return (i + j) % 3 == 0; };
      case QRMaskPattern.PATTERN100 :
        return function(i, j) { return (Math.floor(i / 2) + Math.floor(j / 3) ) % 2 == 0; };
      case QRMaskPattern.PATTERN101 :
        return function(i, j) { return (i * j) % 2 + (i * j) % 3 == 0; };
      case QRMaskPattern.PATTERN110 :
        return function(i, j) { return ( (i * j) % 2 + (i * j) % 3) % 2 == 0; };
      case QRMaskPattern.PATTERN111 :
        return function(i, j) { return ( (i * j) % 3 + (i + j) % 2) % 2 == 0; };

      default :
        throw 'bad maskPattern:' + maskPattern;
      }
    };

    _this.getErrorCorrectPolynomial = function(errorCorrectLength) {
      var a = qrPolynomial([1], 0);
      for (var i = 0; i < errorCorrectLength; i += 1) {
        a = a.multiply(qrPolynomial([1, QRMath.gexp(i)], 0) );
      }
      return a;
    };

    _this.getLengthInBits = function(mode, type) {

      if (1 <= type && type < 10) {

        // 1 - 9

        switch(mode) {
        case QRMode.MODE_NUMBER    : return 10;
        case QRMode.MODE_ALPHA_NUM : return 9;
        case QRMode.MODE_8BIT_BYTE : return 8;
        case QRMode.MODE_KANJI     : return 8;
        default :
          throw 'mode:' + mode;
        }

      } else if (type < 27) {

        // 10 - 26

        switch(mode) {
        case QRMode.MODE_NUMBER    : return 12;
        case QRMode.MODE_ALPHA_NUM : return 11;
        case QRMode.MODE_8BIT_BYTE : return 16;
        case QRMode.MODE_KANJI     : return 10;
        default :
          throw 'mode:' + mode;
        }

      } else if (type < 41) {

        // 27 - 40

        switch(mode) {
        case QRMode.MODE_NUMBER    : return 14;
        case QRMode.MODE_ALPHA_NUM : return 13;
        case QRMode.MODE_8BIT_BYTE : return 16;
        case QRMode.MODE_KANJI     : return 12;
        default :
          throw 'mode:' + mode;
        }

      } else {
        throw 'type:' + type;
      }
    };

    _this.getLostPoint = function(qrcode) {

      var moduleCount = qrcode.getModuleCount();

      var lostPoint = 0;

      // LEVEL1

      for (var row = 0; row < moduleCount; row += 1) {
        for (var col = 0; col < moduleCount; col += 1) {

          var sameCount = 0;
          var dark = qrcode.isDark(row, col);

          for (var r = -1; r <= 1; r += 1) {

            if (row + r < 0 || moduleCount <= row + r) {
              continue;
            }

            for (var c = -1; c <= 1; c += 1) {

              if (col + c < 0 || moduleCount <= col + c) {
                continue;
              }

              if (r == 0 && c == 0) {
                continue;
              }

              if (dark == qrcode.isDark(row + r, col + c) ) {
                sameCount += 1;
              }
            }
          }

          if (sameCount > 5) {
            lostPoint += (3 + sameCount - 5);
          }
        }
      };

      // LEVEL2

      for (var row = 0; row < moduleCount - 1; row += 1) {
        for (var col = 0; col < moduleCount - 1; col += 1) {
          var count = 0;
          if (qrcode.isDark(row, col) ) count += 1;
          if (qrcode.isDark(row + 1, col) ) count += 1;
          if (qrcode.isDark(row, col + 1) ) count += 1;
          if (qrcode.isDark(row + 1, col + 1) ) count += 1;
          if (count == 0 || count == 4) {
            lostPoint += 3;
          }
        }
      }

      // LEVEL3

      for (var row = 0; row < moduleCount; row += 1) {
        for (var col = 0; col < moduleCount - 6; col += 1) {
          if (qrcode.isDark(row, col)
              && !qrcode.isDark(row, col + 1)
              &&  qrcode.isDark(row, col + 2)
              &&  qrcode.isDark(row, col + 3)
              &&  qrcode.isDark(row, col + 4)
              && !qrcode.isDark(row, col + 5)
              &&  qrcode.isDark(row, col + 6) ) {
            lostPoint += 40;
          }
        }
      }

      for (var col = 0; col < moduleCount; col += 1) {
        for (var row = 0; row < moduleCount - 6; row += 1) {
          if (qrcode.isDark(row, col)
              && !qrcode.isDark(row + 1, col)
              &&  qrcode.isDark(row + 2, col)
              &&  qrcode.isDark(row + 3, col)
              &&  qrcode.isDark(row + 4, col)
              && !qrcode.isDark(row + 5, col)
              &&  qrcode.isDark(row + 6, col) ) {
            lostPoint += 40;
          }
        }
      }

      // LEVEL4

      var darkCount = 0;

      for (var col = 0; col < moduleCount; col += 1) {
        for (var row = 0; row < moduleCount; row += 1) {
          if (qrcode.isDark(row, col) ) {
            darkCount += 1;
          }
        }
      }

      var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
      lostPoint += ratio * 10;

      return lostPoint;
    };

    return _this;
  }();

  //---------------------------------------------------------------------
  // QRMath
  //---------------------------------------------------------------------

  var QRMath = function() {

    var EXP_TABLE = new Array(256);
    var LOG_TABLE = new Array(256);

    // initialize tables
    for (var i = 0; i < 8; i += 1) {
      EXP_TABLE[i] = 1 << i;
    }
    for (var i = 8; i < 256; i += 1) {
      EXP_TABLE[i] = EXP_TABLE[i - 4]
        ^ EXP_TABLE[i - 5]
        ^ EXP_TABLE[i - 6]
        ^ EXP_TABLE[i - 8];
    }
    for (var i = 0; i < 255; i += 1) {
      LOG_TABLE[EXP_TABLE[i] ] = i;
    }

    var _this = {};

    _this.glog = function(n) {

      if (n < 1) {
        throw 'glog(' + n + ')';
      }

      return LOG_TABLE[n];
    };

    _this.gexp = function(n) {

      while (n < 0) {
        n += 255;
      }

      while (n >= 256) {
        n -= 255;
      }

      return EXP_TABLE[n];
    };

    return _this;
  }();

  //---------------------------------------------------------------------
  // qrPolynomial
  //---------------------------------------------------------------------

  function qrPolynomial(num, shift) {

    if (typeof num.length == 'undefined') {
      throw num.length + '/' + shift;
    }

    var _num = function() {
      var offset = 0;
      while (offset < num.length && num[offset] == 0) {
        offset += 1;
      }
      var _num = new Array(num.length - offset + shift);
      for (var i = 0; i < num.length - offset; i += 1) {
        _num[i] = num[i + offset];
      }
      return _num;
    }();

    var _this = {};

    _this.getAt = function(index) {
      return _num[index];
    };

    _this.getLength = function() {
      return _num.length;
    };

    _this.multiply = function(e) {

      var num = new Array(_this.getLength() + e.getLength() - 1);

      for (var i = 0; i < _this.getLength(); i += 1) {
        for (var j = 0; j < e.getLength(); j += 1) {
          num[i + j] ^= QRMath.gexp(QRMath.glog(_this.getAt(i) ) + QRMath.glog(e.getAt(j) ) );
        }
      }

      return qrPolynomial(num, 0);
    };

    _this.mod = function(e) {

      if (_this.getLength() - e.getLength() < 0) {
        return _this;
      }

      var ratio = QRMath.glog(_this.getAt(0) ) - QRMath.glog(e.getAt(0) );

      var num = new Array(_this.getLength() );
      for (var i = 0; i < _this.getLength(); i += 1) {
        num[i] = _this.getAt(i);
      }

      for (var i = 0; i < e.getLength(); i += 1) {
        num[i] ^= QRMath.gexp(QRMath.glog(e.getAt(i) ) + ratio);
      }

      // recursive call
      return qrPolynomial(num, 0).mod(e);
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // QRRSBlock
  //---------------------------------------------------------------------

  var QRRSBlock = function() {

    var RS_BLOCK_TABLE = [

      // L
      // M
      // Q
      // H

      // 1
      [1, 26, 19],
      [1, 26, 16],
      [1, 26, 13],
      [1, 26, 9],

      // 2
      [1, 44, 34],
      [1, 44, 28],
      [1, 44, 22],
      [1, 44, 16],

      // 3
      [1, 70, 55],
      [1, 70, 44],
      [2, 35, 17],
      [2, 35, 13],

      // 4
      [1, 100, 80],
      [2, 50, 32],
      [2, 50, 24],
      [4, 25, 9],

      // 5
      [1, 134, 108],
      [2, 67, 43],
      [2, 33, 15, 2, 34, 16],
      [2, 33, 11, 2, 34, 12],

      // 6
      [2, 86, 68],
      [4, 43, 27],
      [4, 43, 19],
      [4, 43, 15],

      // 7
      [2, 98, 78],
      [4, 49, 31],
      [2, 32, 14, 4, 33, 15],
      [4, 39, 13, 1, 40, 14],

      // 8
      [2, 121, 97],
      [2, 60, 38, 2, 61, 39],
      [4, 40, 18, 2, 41, 19],
      [4, 40, 14, 2, 41, 15],

      // 9
      [2, 146, 116],
      [3, 58, 36, 2, 59, 37],
      [4, 36, 16, 4, 37, 17],
      [4, 36, 12, 4, 37, 13],

      // 10
      [2, 86, 68, 2, 87, 69],
      [4, 69, 43, 1, 70, 44],
      [6, 43, 19, 2, 44, 20],
      [6, 43, 15, 2, 44, 16],

      // 11
      [4, 101, 81],
      [1, 80, 50, 4, 81, 51],
      [4, 50, 22, 4, 51, 23],
      [3, 36, 12, 8, 37, 13],

      // 12
      [2, 116, 92, 2, 117, 93],
      [6, 58, 36, 2, 59, 37],
      [4, 46, 20, 6, 47, 21],
      [7, 42, 14, 4, 43, 15],

      // 13
      [4, 133, 107],
      [8, 59, 37, 1, 60, 38],
      [8, 44, 20, 4, 45, 21],
      [12, 33, 11, 4, 34, 12],

      // 14
      [3, 145, 115, 1, 146, 116],
      [4, 64, 40, 5, 65, 41],
      [11, 36, 16, 5, 37, 17],
      [11, 36, 12, 5, 37, 13],

      // 15
      [5, 109, 87, 1, 110, 88],
      [5, 65, 41, 5, 66, 42],
      [5, 54, 24, 7, 55, 25],
      [11, 36, 12, 7, 37, 13],

      // 16
      [5, 122, 98, 1, 123, 99],
      [7, 73, 45, 3, 74, 46],
      [15, 43, 19, 2, 44, 20],
      [3, 45, 15, 13, 46, 16],

      // 17
      [1, 135, 107, 5, 136, 108],
      [10, 74, 46, 1, 75, 47],
      [1, 50, 22, 15, 51, 23],
      [2, 42, 14, 17, 43, 15],

      // 18
      [5, 150, 120, 1, 151, 121],
      [9, 69, 43, 4, 70, 44],
      [17, 50, 22, 1, 51, 23],
      [2, 42, 14, 19, 43, 15],

      // 19
      [3, 141, 113, 4, 142, 114],
      [3, 70, 44, 11, 71, 45],
      [17, 47, 21, 4, 48, 22],
      [9, 39, 13, 16, 40, 14],

      // 20
      [3, 135, 107, 5, 136, 108],
      [3, 67, 41, 13, 68, 42],
      [15, 54, 24, 5, 55, 25],
      [15, 43, 15, 10, 44, 16],

      // 21
      [4, 144, 116, 4, 145, 117],
      [17, 68, 42],
      [17, 50, 22, 6, 51, 23],
      [19, 46, 16, 6, 47, 17],

      // 22
      [2, 139, 111, 7, 140, 112],
      [17, 74, 46],
      [7, 54, 24, 16, 55, 25],
      [34, 37, 13],

      // 23
      [4, 151, 121, 5, 152, 122],
      [4, 75, 47, 14, 76, 48],
      [11, 54, 24, 14, 55, 25],
      [16, 45, 15, 14, 46, 16],

      // 24
      [6, 147, 117, 4, 148, 118],
      [6, 73, 45, 14, 74, 46],
      [11, 54, 24, 16, 55, 25],
      [30, 46, 16, 2, 47, 17],

      // 25
      [8, 132, 106, 4, 133, 107],
      [8, 75, 47, 13, 76, 48],
      [7, 54, 24, 22, 55, 25],
      [22, 45, 15, 13, 46, 16],

      // 26
      [10, 142, 114, 2, 143, 115],
      [19, 74, 46, 4, 75, 47],
      [28, 50, 22, 6, 51, 23],
      [33, 46, 16, 4, 47, 17],

      // 27
      [8, 152, 122, 4, 153, 123],
      [22, 73, 45, 3, 74, 46],
      [8, 53, 23, 26, 54, 24],
      [12, 45, 15, 28, 46, 16],

      // 28
      [3, 147, 117, 10, 148, 118],
      [3, 73, 45, 23, 74, 46],
      [4, 54, 24, 31, 55, 25],
      [11, 45, 15, 31, 46, 16],

      // 29
      [7, 146, 116, 7, 147, 117],
      [21, 73, 45, 7, 74, 46],
      [1, 53, 23, 37, 54, 24],
      [19, 45, 15, 26, 46, 16],

      // 30
      [5, 145, 115, 10, 146, 116],
      [19, 75, 47, 10, 76, 48],
      [15, 54, 24, 25, 55, 25],
      [23, 45, 15, 25, 46, 16],

      // 31
      [13, 145, 115, 3, 146, 116],
      [2, 74, 46, 29, 75, 47],
      [42, 54, 24, 1, 55, 25],
      [23, 45, 15, 28, 46, 16],

      // 32
      [17, 145, 115],
      [10, 74, 46, 23, 75, 47],
      [10, 54, 24, 35, 55, 25],
      [19, 45, 15, 35, 46, 16],

      // 33
      [17, 145, 115, 1, 146, 116],
      [14, 74, 46, 21, 75, 47],
      [29, 54, 24, 19, 55, 25],
      [11, 45, 15, 46, 46, 16],

      // 34
      [13, 145, 115, 6, 146, 116],
      [14, 74, 46, 23, 75, 47],
      [44, 54, 24, 7, 55, 25],
      [59, 46, 16, 1, 47, 17],

      // 35
      [12, 151, 121, 7, 152, 122],
      [12, 75, 47, 26, 76, 48],
      [39, 54, 24, 14, 55, 25],
      [22, 45, 15, 41, 46, 16],

      // 36
      [6, 151, 121, 14, 152, 122],
      [6, 75, 47, 34, 76, 48],
      [46, 54, 24, 10, 55, 25],
      [2, 45, 15, 64, 46, 16],

      // 37
      [17, 152, 122, 4, 153, 123],
      [29, 74, 46, 14, 75, 47],
      [49, 54, 24, 10, 55, 25],
      [24, 45, 15, 46, 46, 16],

      // 38
      [4, 152, 122, 18, 153, 123],
      [13, 74, 46, 32, 75, 47],
      [48, 54, 24, 14, 55, 25],
      [42, 45, 15, 32, 46, 16],

      // 39
      [20, 147, 117, 4, 148, 118],
      [40, 75, 47, 7, 76, 48],
      [43, 54, 24, 22, 55, 25],
      [10, 45, 15, 67, 46, 16],

      // 40
      [19, 148, 118, 6, 149, 119],
      [18, 75, 47, 31, 76, 48],
      [34, 54, 24, 34, 55, 25],
      [20, 45, 15, 61, 46, 16]
    ];

    var qrRSBlock = function(totalCount, dataCount) {
      var _this = {};
      _this.totalCount = totalCount;
      _this.dataCount = dataCount;
      return _this;
    };

    var _this = {};

    var getRsBlockTable = function(typeNumber, errorCorrectionLevel) {

      switch(errorCorrectionLevel) {
      case QRErrorCorrectionLevel.L :
        return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
      case QRErrorCorrectionLevel.M :
        return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
      case QRErrorCorrectionLevel.Q :
        return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
      case QRErrorCorrectionLevel.H :
        return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
      default :
        return undefined;
      }
    };

    _this.getRSBlocks = function(typeNumber, errorCorrectionLevel) {

      var rsBlock = getRsBlockTable(typeNumber, errorCorrectionLevel);

      if (typeof rsBlock == 'undefined') {
        throw 'bad rs block @ typeNumber:' + typeNumber +
            '/errorCorrectionLevel:' + errorCorrectionLevel;
      }

      var length = rsBlock.length / 3;

      var list = [];

      for (var i = 0; i < length; i += 1) {

        var count = rsBlock[i * 3 + 0];
        var totalCount = rsBlock[i * 3 + 1];
        var dataCount = rsBlock[i * 3 + 2];

        for (var j = 0; j < count; j += 1) {
          list.push(qrRSBlock(totalCount, dataCount) );
        }
      }

      return list;
    };

    return _this;
  }();

  //---------------------------------------------------------------------
  // qrBitBuffer
  //---------------------------------------------------------------------

  var qrBitBuffer = function() {

    var _buffer = [];
    var _length = 0;

    var _this = {};

    _this.getBuffer = function() {
      return _buffer;
    };

    _this.getAt = function(index) {
      var bufIndex = Math.floor(index / 8);
      return ( (_buffer[bufIndex] >>> (7 - index % 8) ) & 1) == 1;
    };

    _this.put = function(num, length) {
      for (var i = 0; i < length; i += 1) {
        _this.putBit( ( (num >>> (length - i - 1) ) & 1) == 1);
      }
    };

    _this.getLengthInBits = function() {
      return _length;
    };

    _this.putBit = function(bit) {

      var bufIndex = Math.floor(_length / 8);
      if (_buffer.length <= bufIndex) {
        _buffer.push(0);
      }

      if (bit) {
        _buffer[bufIndex] |= (0x80 >>> (_length % 8) );
      }

      _length += 1;
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // qrNumber
  //---------------------------------------------------------------------

  var qrNumber = function(data) {

    var _mode = QRMode.MODE_NUMBER;
    var _data = data;

    var _this = {};

    _this.getMode = function() {
      return _mode;
    };

    _this.getLength = function(buffer) {
      return _data.length;
    };

    _this.write = function(buffer) {

      var data = _data;

      var i = 0;

      while (i + 2 < data.length) {
        buffer.put(strToNum(data.substring(i, i + 3) ), 10);
        i += 3;
      }

      if (i < data.length) {
        if (data.length - i == 1) {
          buffer.put(strToNum(data.substring(i, i + 1) ), 4);
        } else if (data.length - i == 2) {
          buffer.put(strToNum(data.substring(i, i + 2) ), 7);
        }
      }
    };

    var strToNum = function(s) {
      var num = 0;
      for (var i = 0; i < s.length; i += 1) {
        num = num * 10 + chatToNum(s.charAt(i) );
      }
      return num;
    };

    var chatToNum = function(c) {
      if ('0' <= c && c <= '9') {
        return c.charCodeAt(0) - '0'.charCodeAt(0);
      }
      throw 'illegal char :' + c;
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // qrAlphaNum
  //---------------------------------------------------------------------

  var qrAlphaNum = function(data) {

    var _mode = QRMode.MODE_ALPHA_NUM;
    var _data = data;

    var _this = {};

    _this.getMode = function() {
      return _mode;
    };

    _this.getLength = function(buffer) {
      return _data.length;
    };

    _this.write = function(buffer) {

      var s = _data;

      var i = 0;

      while (i + 1 < s.length) {
        buffer.put(
          getCode(s.charAt(i) ) * 45 +
          getCode(s.charAt(i + 1) ), 11);
        i += 2;
      }

      if (i < s.length) {
        buffer.put(getCode(s.charAt(i) ), 6);
      }
    };

    var getCode = function(c) {

      if ('0' <= c && c <= '9') {
        return c.charCodeAt(0) - '0'.charCodeAt(0);
      } else if ('A' <= c && c <= 'Z') {
        return c.charCodeAt(0) - 'A'.charCodeAt(0) + 10;
      } else {
        switch (c) {
        case ' ' : return 36;
        case '$' : return 37;
        case '%' : return 38;
        case '*' : return 39;
        case '+' : return 40;
        case '-' : return 41;
        case '.' : return 42;
        case '/' : return 43;
        case ':' : return 44;
        default :
          throw 'illegal char :' + c;
        }
      }
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // qr8BitByte
  //---------------------------------------------------------------------

  var qr8BitByte = function(data) {

    var _mode = QRMode.MODE_8BIT_BYTE;
    var _data = data;
    var _bytes = qrcode.stringToBytes(data);

    var _this = {};

    _this.getMode = function() {
      return _mode;
    };

    _this.getLength = function(buffer) {
      return _bytes.length;
    };

    _this.write = function(buffer) {
      for (var i = 0; i < _bytes.length; i += 1) {
        buffer.put(_bytes[i], 8);
      }
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // qrKanji
  //---------------------------------------------------------------------

  var qrKanji = function(data) {

    var _mode = QRMode.MODE_KANJI;
    var _data = data;

    var stringToBytes = qrcode.stringToBytesFuncs['SJIS'];
    if (!stringToBytes) {
      throw 'sjis not supported.';
    }
    !function(c, code) {
      // self test for sjis support.
      var test = stringToBytes(c);
      if (test.length != 2 || ( (test[0] << 8) | test[1]) != code) {
        throw 'sjis not supported.';
      }
    }('\u53cb', 0x9746);

    var _bytes = stringToBytes(data);

    var _this = {};

    _this.getMode = function() {
      return _mode;
    };

    _this.getLength = function(buffer) {
      return ~~(_bytes.length / 2);
    };

    _this.write = function(buffer) {

      var data = _bytes;

      var i = 0;

      while (i + 1 < data.length) {

        var c = ( (0xff & data[i]) << 8) | (0xff & data[i + 1]);

        if (0x8140 <= c && c <= 0x9FFC) {
          c -= 0x8140;
        } else if (0xE040 <= c && c <= 0xEBBF) {
          c -= 0xC140;
        } else {
          throw 'illegal char at ' + (i + 1) + '/' + c;
        }

        c = ( (c >>> 8) & 0xff) * 0xC0 + (c & 0xff);

        buffer.put(c, 13);

        i += 2;
      }

      if (i < data.length) {
        throw 'illegal char at ' + (i + 1);
      }
    };

    return _this;
  };

  //=====================================================================
  // GIF Support etc.
  //

  //---------------------------------------------------------------------
  // byteArrayOutputStream
  //---------------------------------------------------------------------

  var byteArrayOutputStream = function() {

    var _bytes = [];

    var _this = {};

    _this.writeByte = function(b) {
      _bytes.push(b & 0xff);
    };

    _this.writeShort = function(i) {
      _this.writeByte(i);
      _this.writeByte(i >>> 8);
    };

    _this.writeBytes = function(b, off, len) {
      off = off || 0;
      len = len || b.length;
      for (var i = 0; i < len; i += 1) {
        _this.writeByte(b[i + off]);
      }
    };

    _this.writeString = function(s) {
      for (var i = 0; i < s.length; i += 1) {
        _this.writeByte(s.charCodeAt(i) );
      }
    };

    _this.toByteArray = function() {
      return _bytes;
    };

    _this.toString = function() {
      var s = '';
      s += '[';
      for (var i = 0; i < _bytes.length; i += 1) {
        if (i > 0) {
          s += ',';
        }
        s += _bytes[i];
      }
      s += ']';
      return s;
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // base64EncodeOutputStream
  //---------------------------------------------------------------------

  var base64EncodeOutputStream = function() {

    var _buffer = 0;
    var _buflen = 0;
    var _length = 0;
    var _base64 = '';

    var _this = {};

    var writeEncoded = function(b) {
      _base64 += String.fromCharCode(encode(b & 0x3f) );
    };

    var encode = function(n) {
      if (n < 0) {
        // error.
      } else if (n < 26) {
        return 0x41 + n;
      } else if (n < 52) {
        return 0x61 + (n - 26);
      } else if (n < 62) {
        return 0x30 + (n - 52);
      } else if (n == 62) {
        return 0x2b;
      } else if (n == 63) {
        return 0x2f;
      }
      throw 'n:' + n;
    };

    _this.writeByte = function(n) {

      _buffer = (_buffer << 8) | (n & 0xff);
      _buflen += 8;
      _length += 1;

      while (_buflen >= 6) {
        writeEncoded(_buffer >>> (_buflen - 6) );
        _buflen -= 6;
      }
    };

    _this.flush = function() {

      if (_buflen > 0) {
        writeEncoded(_buffer << (6 - _buflen) );
        _buffer = 0;
        _buflen = 0;
      }

      if (_length % 3 != 0) {
        // padding
        var padlen = 3 - _length % 3;
        for (var i = 0; i < padlen; i += 1) {
          _base64 += '=';
        }
      }
    };

    _this.toString = function() {
      return _base64;
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // base64DecodeInputStream
  //---------------------------------------------------------------------

  var base64DecodeInputStream = function(str) {

    var _str = str;
    var _pos = 0;
    var _buffer = 0;
    var _buflen = 0;

    var _this = {};

    _this.read = function() {

      while (_buflen < 8) {

        if (_pos >= _str.length) {
          if (_buflen == 0) {
            return -1;
          }
          throw 'unexpected end of file./' + _buflen;
        }

        var c = _str.charAt(_pos);
        _pos += 1;

        if (c == '=') {
          _buflen = 0;
          return -1;
        } else if (c.match(/^\s$/) ) {
          // ignore if whitespace.
          continue;
        }

        _buffer = (_buffer << 6) | decode(c.charCodeAt(0) );
        _buflen += 6;
      }

      var n = (_buffer >>> (_buflen - 8) ) & 0xff;
      _buflen -= 8;
      return n;
    };

    var decode = function(c) {
      if (0x41 <= c && c <= 0x5a) {
        return c - 0x41;
      } else if (0x61 <= c && c <= 0x7a) {
        return c - 0x61 + 26;
      } else if (0x30 <= c && c <= 0x39) {
        return c - 0x30 + 52;
      } else if (c == 0x2b) {
        return 62;
      } else if (c == 0x2f) {
        return 63;
      } else {
        throw 'c:' + c;
      }
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // gifImage (B/W)
  //---------------------------------------------------------------------

  var gifImage = function(width, height) {

    var _width = width;
    var _height = height;
    var _data = new Array(width * height);

    var _this = {};

    _this.setPixel = function(x, y, pixel) {
      _data[y * _width + x] = pixel;
    };

    _this.write = function(out) {

      //---------------------------------
      // GIF Signature

      out.writeString('GIF87a');

      //---------------------------------
      // Screen Descriptor

      out.writeShort(_width);
      out.writeShort(_height);

      out.writeByte(0x80); // 2bit
      out.writeByte(0);
      out.writeByte(0);

      //---------------------------------
      // Global Color Map

      // black
      out.writeByte(0x00);
      out.writeByte(0x00);
      out.writeByte(0x00);

      // white
      out.writeByte(0xff);
      out.writeByte(0xff);
      out.writeByte(0xff);

      //---------------------------------
      // Image Descriptor

      out.writeString(',');
      out.writeShort(0);
      out.writeShort(0);
      out.writeShort(_width);
      out.writeShort(_height);
      out.writeByte(0);

      //---------------------------------
      // Local Color Map

      //---------------------------------
      // Raster Data

      var lzwMinCodeSize = 2;
      var raster = getLZWRaster(lzwMinCodeSize);

      out.writeByte(lzwMinCodeSize);

      var offset = 0;

      while (raster.length - offset > 255) {
        out.writeByte(255);
        out.writeBytes(raster, offset, 255);
        offset += 255;
      }

      out.writeByte(raster.length - offset);
      out.writeBytes(raster, offset, raster.length - offset);
      out.writeByte(0x00);

      //---------------------------------
      // GIF Terminator
      out.writeString(';');
    };

    var bitOutputStream = function(out) {

      var _out = out;
      var _bitLength = 0;
      var _bitBuffer = 0;

      var _this = {};

      _this.write = function(data, length) {

        if ( (data >>> length) != 0) {
          throw 'length over';
        }

        while (_bitLength + length >= 8) {
          _out.writeByte(0xff & ( (data << _bitLength) | _bitBuffer) );
          length -= (8 - _bitLength);
          data >>>= (8 - _bitLength);
          _bitBuffer = 0;
          _bitLength = 0;
        }

        _bitBuffer = (data << _bitLength) | _bitBuffer;
        _bitLength = _bitLength + length;
      };

      _this.flush = function() {
        if (_bitLength > 0) {
          _out.writeByte(_bitBuffer);
        }
      };

      return _this;
    };

    var getLZWRaster = function(lzwMinCodeSize) {

      var clearCode = 1 << lzwMinCodeSize;
      var endCode = (1 << lzwMinCodeSize) + 1;
      var bitLength = lzwMinCodeSize + 1;

      // Setup LZWTable
      var table = lzwTable();

      for (var i = 0; i < clearCode; i += 1) {
        table.add(String.fromCharCode(i) );
      }
      table.add(String.fromCharCode(clearCode) );
      table.add(String.fromCharCode(endCode) );

      var byteOut = byteArrayOutputStream();
      var bitOut = bitOutputStream(byteOut);

      // clear code
      bitOut.write(clearCode, bitLength);

      var dataIndex = 0;

      var s = String.fromCharCode(_data[dataIndex]);
      dataIndex += 1;

      while (dataIndex < _data.length) {

        var c = String.fromCharCode(_data[dataIndex]);
        dataIndex += 1;

        if (table.contains(s + c) ) {

          s = s + c;

        } else {

          bitOut.write(table.indexOf(s), bitLength);

          if (table.size() < 0xfff) {

            if (table.size() == (1 << bitLength) ) {
              bitLength += 1;
            }

            table.add(s + c);
          }

          s = c;
        }
      }

      bitOut.write(table.indexOf(s), bitLength);

      // end code
      bitOut.write(endCode, bitLength);

      bitOut.flush();

      return byteOut.toByteArray();
    };

    var lzwTable = function() {

      var _map = {};
      var _size = 0;

      var _this = {};

      _this.add = function(key) {
        if (_this.contains(key) ) {
          throw 'dup key:' + key;
        }
        _map[key] = _size;
        _size += 1;
      };

      _this.size = function() {
        return _size;
      };

      _this.indexOf = function(key) {
        return _map[key];
      };

      _this.contains = function(key) {
        return typeof _map[key] != 'undefined';
      };

      return _this;
    };

    return _this;
  };

  var createDataURL = function(width, height, getPixel) {
    var gif = gifImage(width, height);
    for (var y = 0; y < height; y += 1) {
      for (var x = 0; x < width; x += 1) {
        gif.setPixel(x, y, getPixel(x, y) );
      }
    }

    var b = byteArrayOutputStream();
    gif.write(b);

    var base64 = base64EncodeOutputStream();
    var bytes = b.toByteArray();
    for (var i = 0; i < bytes.length; i += 1) {
      base64.writeByte(bytes[i]);
    }
    base64.flush();

    return 'data:image/gif;base64,' + base64;
  };

  //---------------------------------------------------------------------
  // returns qrcode function.

  return qrcode;
}();

// multibyte support
!function() {

  qrcode.stringToBytesFuncs['UTF-8'] = function(s) {
    // http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array
    function toUTF8Array(str) {
      var utf8 = [];
      for (var i=0; i < str.length; i++) {
        var charcode = str.charCodeAt(i);
        if (charcode < 0x80) utf8.push(charcode);
        else if (charcode < 0x800) {
          utf8.push(0xc0 | (charcode >> 6),
              0x80 | (charcode & 0x3f));
        }
        else if (charcode < 0xd800 || charcode >= 0xe000) {
          utf8.push(0xe0 | (charcode >> 12),
              0x80 | ((charcode>>6) & 0x3f),
              0x80 | (charcode & 0x3f));
        }
        // surrogate pair
        else {
          i++;
          // UTF-16 encodes 0x10000-0x10FFFF by
          // subtracting 0x10000 and splitting the
          // 20 bits of 0x0-0xFFFFF into two halves
          charcode = 0x10000 + (((charcode & 0x3ff)<<10)
            | (str.charCodeAt(i) & 0x3ff));
          utf8.push(0xf0 | (charcode >>18),
              0x80 | ((charcode>>12) & 0x3f),
              0x80 | ((charcode>>6) & 0x3f),
              0x80 | (charcode & 0x3f));
        }
      }
      return utf8;
    }
    return toUTF8Array(s);
  };

}();

if(typeof window!=='undefined'){window.qrcode=qrcode;}
    </script>
    <style>
        :root {
            --bg:#0b0e14; --s1:#161b26; --s2:#1e2535; --s3:#252e42;
            --bd:rgba(255,255,255,0.07); --bd2:rgba(255,255,255,0.12);
            --tx:#e4e9f0; --td:#7a8499; --tm:#3a4358;
            --ac:#c8ff00; --acd:#8fb800;
            --beg:#22c55e; --mit:#f59e0b; --exp:#ef4444; --log:#38bdf8; --fac:#a78bfa;
            --fh:'Barlow Condensed',sans-serif; --fb:'Barlow',sans-serif;
            --r:12px;
            --shadow:0 8px 24px rgba(0,0,0,.55);
            color-scheme: dark;
        }
        /* ═══ LIGHT MODE ═══ */
        [data-theme=light]{
            --bg:#f0f4f8; --s1:#ffffff; --s2:#e8ecf2; --s3:#dde2eb;
            --bd:rgba(0,0,0,0.06); --bd2:rgba(0,0,0,0.13);
            --tx:#1a2030; --td:#5a6478; --tm:#8a95a8;
            --ac:#4a8500; --acd:#3a6800;
            --shadow:0 4px 16px rgba(0,0,0,.14);
            color-scheme: light;
        }
        [data-theme=light] .leaflet-popup-content-wrapper,
        [data-theme=light] .leaflet-popup-content-wrapper *{
            background:var(--s1)!important;
        }
        [data-theme=light] .leaflet-control-zoom a{background:var(--s1)!important;color:var(--tx)!important;}
        [data-theme=light] .leaflet-control-attribution{background:rgba(240,244,248,.85)!important;color:var(--td)!important;}
        [data-theme=light] .path-lbl{background:rgba(240,244,248,.92)!important;border-color:rgba(245,158,11,.5)!important;}
        [data-theme=light] #legend{background:rgba(255,255,255,.92)!important;}
        [data-theme=light] .ibtn,[data-theme=light] #titlepill,[data-theme=light] .fab{
            box-shadow:0 2px 8px rgba(0,0,0,.15)!important;
        }
        *,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
        body,html{width:100%;height:100%;overflow:hidden;font-family:var(--fb);background:var(--bg);color:var(--tx);-webkit-tap-highlight-color:transparent;-webkit-text-size-adjust:100%}
        button{font-family:inherit}
        #map{position:fixed;inset:0;z-index:1}

        /* LEAFLET */
        .leaflet-control-zoom{border:none!important;box-shadow:0 8px 24px rgba(0,0,0,.6)!important}
        .leaflet-control-zoom a{background:var(--s1)!important;color:var(--tx)!important;border:1px solid var(--bd2)!important;font-size:16px!important;width:34px!important;height:34px!important;line-height:34px!important}
        .leaflet-control-zoom a:hover{background:var(--s2)!important}
        .leaflet-control-zoom-in{border-radius:var(--r) var(--r) 0 0!important}
        .leaflet-control-zoom-out{border-radius:0 0 var(--r) var(--r)!important}
        .leaflet-popup-content-wrapper{background:var(--s1)!important;border:1px solid var(--bd2)!important;border-radius:16px!important;box-shadow:0 20px 60px rgba(0,0,0,.8)!important;padding:0!important;overflow:hidden}
        .leaflet-popup-content{margin:0!important;min-width:250px;max-width:290px}
        .leaflet-popup-tip-container{display:none}
        .leaflet-popup-close-button{color:var(--td)!important;font-size:20px!important;top:10px!important;right:10px!important;z-index:10;width:28px!important;height:28px!important;display:flex!important;align-items:center!important;justify-content:center!important;background:var(--s2)!important;border-radius:50%!important;line-height:1!important}
        .map-label{background:transparent!important;border:none!important;box-shadow:none!important;font-family:var(--fh)!important;font-size:11px!important;font-weight:700!important;letter-spacing:.6px!important;color:#fff!important;text-shadow:0 0 4px #000,0 0 10px rgba(0,0,0,.9),0 1px 3px #000!important;pointer-events:none!important;white-space:nowrap!important;text-transform:uppercase!important}
        .leaflet-tooltip{opacity:1!important}
        .path-lbl{background:rgba(11,14,20,.85)!important;border:1px solid rgba(245,158,11,.4)!important;color:#f59e0b!important;font-family:var(--fh)!important;font-size:11px!important;font-weight:700!important;letter-spacing:1px!important;border-radius:4px!important;padding:2px 7px!important;pointer-events:none!important}
        .leaflet-control-attribution{background:rgba(11,14,20,.7)!important;color:var(--td)!important;font-size:9px!important}

        /* TOP BAR */
        #topbar{position:fixed;top:0;left:0;right:0;z-index:500;padding:max(12px,env(safe-area-inset-top,12px)) 12px 0;pointer-events:none}
        #tbrow{display:flex;align-items:center;gap:8px;padding-bottom:10px}
        #tbrow>*{pointer-events:all}
        .ibtn{width:42px;height:42px;flex-shrink:0;background:var(--s1);border:1px solid var(--bd2);border-radius:var(--r);color:var(--tx);display:flex;align-items:center;justify-content:center;cursor:pointer;box-shadow:0 2px 8px rgba(0,0,0,.4);transition:background .15s,transform .1s}
        .ibtn:active{background:var(--s2);transform:scale(.9)}
        #titlepill{flex:1;min-width:0;background:var(--s1);border:1px solid var(--bd2);border-radius:var(--r);padding:7px 12px;box-shadow:0 2px 8px rgba(0,0,0,.4);display:flex;align-items:center;gap:10px}
        .logobadge{width:28px;height:28px;flex-shrink:0;background:var(--ac);border-radius:7px;display:flex;align-items:center;justify-content:center;font-family:var(--fh);font-size:11px;font-weight:800;color:var(--bg);letter-spacing:-.5px}
        .ttl{font-family:var(--fh);font-size:15px;font-weight:800;letter-spacing:1.5px;text-transform:uppercase;color:var(--tx);line-height:1.1}
        .tsub{font-size:10px;color:var(--td)}

        /* FILTER BAR */
        #fbar{position:fixed;top:max(66px,calc(env(safe-area-inset-top,0px) + 66px));left:0;right:0;z-index:499;display:flex;gap:6px;padding:4px 12px 8px;overflow-x:auto;scrollbar-width:none;pointer-events:none}
        #fbar::-webkit-scrollbar{display:none}
        #fbar>*{pointer-events:all}
        .chip{flex-shrink:0;height:32px;padding:0 13px;border-radius:20px;border:1px solid var(--bd2);font-family:var(--fh);font-size:12px;font-weight:700;letter-spacing:.8px;text-transform:uppercase;background:rgba(11,14,20,.88);color:var(--td);cursor:pointer;white-space:nowrap;transition:all .2s;display:flex;align-items:center;gap:5px}
        .chip:active{transform:scale(.94)}
        .chip.on{border-color:transparent;color:#000}
        .chip[data-f=all].on{background:var(--tx)}
        .chip[data-f=beginner].on{background:var(--beg)}
        .chip[data-f=mittel].on{background:var(--mit)}
        .chip[data-f=expert].on{background:var(--exp)}
        .chip[data-f=logistik].on{background:var(--log)}

        /* FABS */
        .fabs{position:fixed;right:12px;bottom:calc(env(safe-area-inset-bottom,0px) + 110px);z-index:490;display:flex;flex-direction:column;gap:8px}
        .fab{width:46px;height:46px;background:var(--s1);border:1px solid var(--bd2);border-radius:13px;color:var(--tx);display:flex;align-items:center;justify-content:center;cursor:pointer;box-shadow:0 8px 24px rgba(0,0,0,.55);transition:all .15s}
        .fab:active{transform:scale(.88)}
        .fab.spin svg{animation:spin 1s linear infinite}
        @keyframes spin{to{transform:rotate(360deg)}}

        /* LEGEND */
        #legend{position:fixed;left:12px;bottom:calc(env(safe-area-inset-bottom,0px) + 110px);z-index:490;background:rgba(11,14,20,.88);border:1px solid var(--bd2);border-radius:var(--r);padding:9px 12px;backdrop-filter:blur(10px)}
        .lgnd-t{font-family:var(--fh);font-size:9px;font-weight:700;letter-spacing:2px;text-transform:uppercase;color:var(--tm);margin-bottom:7px}
        .lgnd-r{display:flex;align-items:center;gap:7px;margin-bottom:4px}
        .lgnd-r:last-child{margin-bottom:0}
        .lgnd-d{width:9px;height:9px;border-radius:2px;flex-shrink:0}
        .lgnd-l{font-family:var(--fh);font-size:11px;font-weight:700;text-transform:uppercase;color:var(--tx)}

        /* BACKDROP */
        #backdrop{position:fixed;inset:0;z-index:800;background:rgba(0,0,0,.65);opacity:0;visibility:hidden;transition:opacity .3s;backdrop-filter:blur(3px)}
        #backdrop.show{opacity:1;visibility:visible}

        /* SHEET */
        #sheet{position:fixed;bottom:0;left:0;right:0;z-index:900;background:var(--s1);border-top:1px solid var(--bd2);border-radius:20px 20px 0 0;max-height:82vh;transform:translateY(100%);transition:transform .4s cubic-bezier(.32,.72,0,1);display:flex;flex-direction:column;padding-bottom:env(safe-area-inset-bottom,0px)}
        #sheet.open{transform:translateY(0)}
        .s-handle{width:36px;height:4px;border-radius:2px;background:var(--bd2);margin:12px auto 0;flex-shrink:0}
        .s-head{padding:10px 16px 12px;flex-shrink:0;border-bottom:1px solid var(--bd);display:flex;align-items:center;justify-content:space-between;gap:10px}
        .s-title{font-family:var(--fh);font-size:19px;font-weight:800;letter-spacing:1px;text-transform:uppercase}
        .s-cnt{font-family:var(--fh);font-size:12px;font-weight:700;color:var(--td);background:var(--s2);padding:3px 9px;border-radius:20px;border:1px solid var(--bd)}
        .s-close{width:30px;height:30px;background:var(--s2);border:1px solid var(--bd);border-radius:50%;color:var(--td);cursor:pointer;display:flex;align-items:center;justify-content:center;flex-shrink:0;font-size:18px;line-height:1;transition:all .15s}
        .s-close:active{background:var(--s3)}
        .s-scroll{overflow-y:auto;flex:1;-webkit-overflow-scrolling:touch}
        .s-scroll::-webkit-scrollbar{width:3px}
        .s-scroll::-webkit-scrollbar-thumb{background:var(--bd2);border-radius:2px}
        .cat-head{padding:14px 16px 6px;font-family:var(--fh);font-size:10px;font-weight:700;letter-spacing:2.5px;text-transform:uppercase;color:var(--tm);display:flex;align-items:center;gap:8px}
        .cat-head::after{content:'';flex:1;height:1px;background:var(--bd)}
        .lrow{display:flex;align-items:center;gap:12px;padding:10px 16px;border-bottom:1px solid var(--bd);transition:background .12s;cursor:pointer}
        .lrow:active{background:var(--s2)}
        .lrow:last-child{border-bottom:none}
        .l-ico{width:38px;height:38px;border-radius:9px;flex-shrink:0;display:flex;align-items:center;justify-content:center;font-size:18px}
        .l-inf{flex:1;min-width:0}
        .l-nm{font-family:var(--fh);font-size:15px;font-weight:700;color:var(--tx);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;line-height:1.2}
        .l-co{font-size:10px;color:var(--td);font-family:monospace;margin-top:2px}
        .l-btns{display:flex;gap:6px;flex-shrink:0}
        .lbtn{width:34px;height:34px;border-radius:9px;background:var(--s2);border:1px solid var(--bd);color:var(--td);cursor:pointer;display:flex;align-items:center;justify-content:center;transition:all .15s}
        .lbtn:active{transform:scale(.86);background:var(--s3)}
        .lbtn.nav{background:var(--ac);border-color:var(--ac);color:var(--bg)}
        .lbtn.nav:active{background:var(--acd)}

        /* POPUP */
        .p-top{padding:14px 14px 10px;border-bottom:1px solid var(--bd)}
        .p-badge{display:inline-flex;align-items:center;gap:5px;padding:3px 9px;border-radius:20px;font-family:var(--fh);font-size:10px;font-weight:800;letter-spacing:1px;text-transform:uppercase;color:var(--bg);margin-bottom:8px}
        .p-name{font-family:var(--fh);font-size:18px;font-weight:800;color:var(--tx);line-height:1.2;margin-bottom:2px;padding-right:28px}
        .p-crds{font-size:10px;color:var(--tm);font-family:monospace}
        .p-desc{font-size:12px;color:var(--td);margin-top:6px;line-height:1.4}
        .p-acts{padding:10px 14px;display:flex;gap:8px}
        .pbtn{flex:1;padding:9px 8px;border-radius:10px;border:1px solid var(--bd2);font-family:var(--fh);font-size:12px;font-weight:800;letter-spacing:.8px;text-transform:uppercase;cursor:pointer;display:flex;align-items:center;justify-content:center;gap:6px;transition:all .15s}
        .pbtn:active{transform:scale(.94)}
        .pbtn.nav{background:var(--ac);border-color:var(--ac);color:var(--bg);flex:2}
        .pbtn.nav:active{background:var(--acd)}
        .pbtn.shr{background:var(--s2);color:var(--td)}

        /* QR MODAL */
        #qrm{position:fixed;top:50%;left:50%;z-index:1100;transform:translate(-50%,-50%) scale(.88);background:var(--s1);border:1px solid var(--bd2);border-radius:20px;box-shadow:0 20px 60px rgba(0,0,0,.8);width:90%;max-width:310px;padding:20px;text-align:center;opacity:0;visibility:hidden;transition:all .25s cubic-bezier(.32,.72,0,1)}
        #qrm.show{opacity:1;visibility:visible;transform:translate(-50%,-50%) scale(1)}
        .qr-nm{font-family:var(--fh);font-size:17px;font-weight:800;letter-spacing:.5px;text-transform:uppercase;color:var(--tx);margin-bottom:4px}
        .qr-hint{font-size:11px;color:var(--td);margin-bottom:14px}
        #qr-wrap{width:176px;height:176px;margin:0 auto 14px;background:#fff;border-radius:14px;padding:8px;display:flex;align-items:center;justify-content:center;box-shadow:0 4px 20px rgba(0,0,0,.25)}
        #qr-canvas{width:160px;height:160px;display:block;border-radius:6px;image-rendering:pixelated;image-rendering:-moz-crisp-edges;image-rendering:crisp-edges}
        #qr-inp{width:100%;padding:9px 12px;background:var(--bg);border:1px solid var(--bd2);border-radius:9px;color:var(--td);font-size:12px;font-family:monospace;margin-bottom:12px;outline:none}
        .qr-acts{display:flex;gap:8px}
        .qbtn{flex:1;padding:10px 8px;border-radius:10px;border:none;font-family:var(--fh);font-size:13px;font-weight:800;letter-spacing:.5px;text-transform:uppercase;cursor:pointer;transition:all .15s;display:flex;align-items:center;justify-content:center;gap:5px}
        .qbtn:active{transform:scale(.94)}
        .qbtn.cl{background:var(--s2);color:var(--td)}
        .qbtn.cp{background:var(--s3);color:var(--tx)}
        .qbtn.dl{background:var(--ac);color:var(--bg)}

        /* GPS HINT */
        #gpshint{position:fixed;right:12px;bottom:calc(env(safe-area-inset-bottom,0px) + 160px);z-index:491;background:var(--s1);border:1px solid var(--bd2);border-radius:var(--r);padding:12px 14px 10px;max-width:220px;box-shadow:0 8px 24px rgba(0,0,0,.55);font-size:12px;color:var(--td);line-height:1.4;opacity:0;visibility:hidden;transition:all .3s;transform:translateX(10px)}
        #gpshint.show{opacity:1;visibility:visible;transform:translateX(0)}
        #gpshint strong{color:var(--tx);display:block;margin-bottom:4px;font-family:var(--fh);font-size:13px;font-weight:700}
        #gpshint-x{position:absolute;top:8px;right:10px;cursor:pointer;color:var(--tm);font-size:16px;line-height:1;background:none;border:none}

        /* TOAST */
        #toast{position:fixed;bottom:calc(env(safe-area-inset-bottom,0px) + 110px);left:50%;transform:translateX(-50%) translateY(16px);background:var(--s2);border:1px solid var(--bd2);border-radius:30px;padding:9px 18px;font-family:var(--fh);font-size:13px;font-weight:700;letter-spacing:.5px;color:var(--tx);z-index:2000;opacity:0;pointer-events:none;transition:all .28s;white-space:nowrap;box-shadow:0 8px 24px rgba(0,0,0,.55)}
        #toast.show{opacity:1;transform:translateX(-50%) translateY(0)}

        /* PIN */
        .pm{display:flex;flex-direction:column;align-items:center}
        .pm-h{width:30px;height:30px;border-radius:50% 50% 50% 4px;transform:rotate(-45deg);display:flex;align-items:center;justify-content:center;border:1.5px solid rgba(255,255,255,.25);box-shadow:0 3px 10px rgba(0,0,0,.55)}
        .pm-i{transform:rotate(45deg);font-size:13px;line-height:1}
        .pm-d{width:4px;height:4px;border-radius:50%;margin-top:2px;opacity:.6}
        .pm.lg .pm-h{width:36px;height:36px}
        .pm.lg .pm-i{font-size:16px}


        /* ═══ ELEVATION PROFILE ═══ */
        #elev-panel{margin:0 16px 14px;background:var(--s2);border:1px solid var(--bd2);border-radius:var(--r);padding:10px 12px;display:none}
        #elev-title{font-family:var(--fh);font-size:10px;font-weight:700;letter-spacing:2px;text-transform:uppercase;color:var(--tm);margin-bottom:6px}
        #elev-canvas{width:100%;height:80px;border-radius:6px;display:block;image-rendering:auto}
        #elev-stats{display:flex;gap:8px;margin-top:6px}
        .elev-stat{flex:1;text-align:center;background:var(--s1);border-radius:7px;padding:5px 3px}
        .elev-stat-v{font-family:var(--fh);font-size:16px;font-weight:800;color:var(--tx);line-height:1.1}
        .elev-stat-l{font-family:var(--fh);font-size:9px;font-weight:700;letter-spacing:1px;text-transform:uppercase;color:var(--tm)}
        /* ═══ THEME FAB ═══ */
        #theme-fab svg{transition:opacity .2s}
        /* ═══ PERSIST BADGE ═══ */
        .persist-badge{display:inline-flex;align-items:center;gap:4px;font-size:10px;color:var(--ac);font-family:var(--fh);font-weight:700;letter-spacing:.5px;margin-left:6px;opacity:.7}
        /* ═══════════════════════════════════════════════════
           GPX PANEL
        ═══════════════════════════════════════════════════ */
        #gpx-panel{position:fixed;bottom:0;left:0;right:0;z-index:901;background:var(--s1);border-top:1px solid var(--bd2);border-radius:20px 20px 0 0;max-height:85vh;transform:translateY(100%);transition:transform .4s cubic-bezier(.32,.72,0,1);display:flex;flex-direction:column;padding-bottom:env(safe-area-inset-bottom,0px)}
        #gpx-panel.open{transform:translateY(0)}
        .gpx-tabs{display:flex;gap:0;flex-shrink:0;border-bottom:1px solid var(--bd);margin:0 16px}
        .gpx-tab{flex:1;padding:10px 8px;background:none;border:none;border-bottom:2px solid transparent;font-family:var(--fh);font-size:13px;font-weight:700;letter-spacing:.8px;text-transform:uppercase;color:var(--td);cursor:pointer;transition:all .2s;margin-bottom:-1px}
        .gpx-tab.on{color:var(--ac);border-bottom-color:var(--ac)}
        .gpx-content{display:none;flex:1;overflow-y:auto;-webkit-overflow-scrolling:touch}
        .gpx-content.on{display:flex;flex-direction:column}
        .gpx-section{padding:14px 16px;border-bottom:1px solid var(--bd)}
        .gpx-section:last-child{border-bottom:none}
        .gpx-label{font-family:var(--fh);font-size:10px;font-weight:700;letter-spacing:2px;text-transform:uppercase;color:var(--tm);margin-bottom:8px;display:block}
        .gpx-row{display:flex;gap:8px;align-items:stretch}
        .gpx-select{flex:1;background:var(--s2);border:1px solid var(--bd2);border-radius:9px;color:var(--tx);font-family:var(--fh);font-size:13px;font-weight:700;padding:8px 12px;cursor:pointer;outline:none;-webkit-appearance:none;appearance:none}
        .gpx-select:focus{border-color:var(--ac)}
        .gpx-input{flex:1;background:var(--s2);border:1px solid var(--bd2);border-radius:9px;color:var(--tx);font-family:var(--fb);font-size:13px;padding:9px 12px;outline:none}
        .gpx-input::placeholder{color:var(--tm)}
        .gpx-input:focus{border-color:var(--ac)}
        .gpx-btn{padding:9px 14px;border-radius:9px;border:1px solid var(--bd2);font-family:var(--fh);font-size:12px;font-weight:800;letter-spacing:.8px;text-transform:uppercase;cursor:pointer;display:flex;align-items:center;justify-content:center;gap:6px;transition:all .15s;white-space:nowrap}
        .gpx-btn:active{transform:scale(.93)}
        .gpx-btn.prim{background:var(--ac);border-color:var(--ac);color:var(--bg)}
        .gpx-btn.prim:active{background:var(--acd)}
        .gpx-btn.sec{background:var(--s2);color:var(--tx)}
        .gpx-btn.danger{background:rgba(239,68,68,.15);border-color:rgba(239,68,68,.4);color:#ef4444}
        /* File-Input versteckt, styled Button darüber */
        #gpx-file-input{display:none}
        .gpx-file-label{display:flex;align-items:center;justify-content:center;gap:8px;padding:14px;border:1.5px dashed var(--bd2);border-radius:12px;color:var(--td);font-family:var(--fh);font-size:13px;font-weight:700;letter-spacing:.5px;text-transform:uppercase;cursor:pointer;transition:all .2s;text-align:center}
        .gpx-file-label:hover,.gpx-file-label:active{border-color:var(--ac);color:var(--ac);background:rgba(200,255,0,.05)}
        /* Track Liste */
        .trk-row{display:flex;align-items:center;gap:10px;padding:10px 16px;border-bottom:1px solid var(--bd);transition:background .12s}
        .trk-row:last-child{border-bottom:none}
        .trk-dot{width:12px;height:12px;border-radius:3px;flex-shrink:0}
        .trk-inf{flex:1;min-width:0}
        .trk-nm{font-family:var(--fh);font-size:14px;font-weight:700;color:var(--tx);white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
        .trk-meta{font-size:10px;color:var(--td);margin-top:1px}
        .trk-btns{display:flex;gap:5px;flex-shrink:0}
        .trk-btn{width:32px;height:32px;border-radius:8px;background:var(--s2);border:1px solid var(--bd);color:var(--td);cursor:pointer;display:flex;align-items:center;justify-content:center;transition:all .15s}
        .trk-btn:active{transform:scale(.86)}
        .trk-btn.on{background:var(--ac);border-color:var(--ac);color:var(--bg)}
        /* Aufnahme / Recording */
        .rec-timer{font-family:var(--fh);font-size:42px;font-weight:800;letter-spacing:2px;color:var(--tx);text-align:center;padding:16px 0 8px;line-height:1}
        .rec-status{font-family:var(--fh);font-size:11px;font-weight:700;letter-spacing:2px;text-transform:uppercase;text-align:center;margin-bottom:14px}
        .rec-stats{display:flex;gap:12px;padding:0 16px 14px}
        .rec-stat{flex:1;background:var(--s2);border-radius:10px;padding:10px;text-align:center}
        .rec-stat-val{font-family:var(--fh);font-size:20px;font-weight:800;color:var(--tx);line-height:1.1}
        .rec-stat-lbl{font-family:var(--fh);font-size:9px;font-weight:700;letter-spacing:1.5px;text-transform:uppercase;color:var(--tm);margin-top:2px}
        .rec-controls{display:flex;gap:8px;padding:0 16px 14px}
        #rec-bar{position:fixed;top:max(66px,calc(env(safe-area-inset-top,0px)+66px));left:50%;transform:translateX(-50%) translateY(-6px);z-index:498;display:flex;align-items:center;gap:8px;background:rgba(239,68,68,.9);border-radius:20px;padding:5px 14px 5px 10px;opacity:0;visibility:hidden;transition:all .3s;backdrop-filter:blur(8px)}
        #rec-bar.show{opacity:1;visibility:visible;transform:translateX(-50%) translateY(0)}
        .rec-dot{width:8px;height:8px;border-radius:50%;background:#fff;animation:pulse-rec 1.4s ease-in-out infinite}
        @keyframes pulse-rec{0%,100%{opacity:1;transform:scale(1)}50%{opacity:.5;transform:scale(.75)}}
        .rec-bar-txt{font-family:var(--fh);font-size:12px;font-weight:700;letter-spacing:.5px;color:#fff}
        /* Kategorie-Filter im GPX-Panel */
        .cat-filter-row{display:flex;gap:6px;flex-wrap:wrap;padding:10px 16px 14px}
        .cat-fbtn{padding:6px 12px;border-radius:20px;border:1px solid var(--bd2);font-family:var(--fh);font-size:11px;font-weight:700;letter-spacing:.8px;text-transform:uppercase;background:var(--s2);color:var(--td);cursor:pointer;transition:all .2s}
        .cat-fbtn:active{transform:scale(.93)}
        .cat-fbtn.on{border-color:transparent;color:#000}
        .cat-fbtn[data-c=beginner].on{background:#27AE60}
        .cat-fbtn[data-c=mittel].on{background:#D4A017}
        .cat-fbtn[data-c=expert].on{background:#8E44AD}
        .cat-fbtn[data-c=all].on{background:var(--tx)}
        /* Fab Nummer-Badge */
        .fab-badge{position:absolute;top:-4px;right:-4px;background:var(--ac);color:var(--bg);border-radius:8px;font-family:var(--fh);font-size:10px;font-weight:800;padding:1px 5px;line-height:1.4;pointer-events:none}
        #gpx-fab{position:relative}
        /* CORS Hint */
        .cors-hint{font-size:11px;color:var(--td);margin-top:6px;line-height:1.5}
        .cors-hint a{color:var(--ac)}

        /* ── NAVIGATION HUD ─────────────────────────────────── */
        #nav-hud{position:fixed;top:max(118px,calc(env(safe-area-inset-top,0px)+118px));left:50%;transform:translateX(-50%);z-index:600;background:var(--s1);border:1px solid var(--bd2);border-radius:var(--r);padding:10px 14px;display:flex;align-items:flex-start;gap:10px;box-shadow:var(--shadow);min-width:260px;max-width:320px;transition:opacity .3s,visibility .3s,transform .3s;opacity:0;visibility:hidden;pointer-events:none;will-change:transform}
        #nav-hud.show{opacity:1;visibility:visible;pointer-events:all;transform:translateX(-50%) translateY(0)}
        #nav-hud .nh-arrow{font-size:30px;line-height:1;flex-shrink:0;transition:transform .4s}
        #nav-hud .nh-txt{flex:1;min-width:0}
        #nav-hud .nh-title{font-family:var(--fh);font-size:10px;font-weight:700;letter-spacing:.8px;text-transform:uppercase;color:var(--td);margin-bottom:2px}
        #nav-hud .nh-dist{font-family:var(--fh);font-size:24px;font-weight:800;color:var(--ac);line-height:1;font-variant-numeric:tabular-nums}
        #nav-hud .nh-sub{font-size:11px;color:var(--td);margin-top:2px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
        #nav-hud .nh-gmaps{display:inline-flex;align-items:center;gap:4px;font-size:10px;color:var(--log);text-decoration:none;margin-top:4px}
        #nav-hud .nh-close{background:none;border:none;color:var(--td);font-size:20px;cursor:pointer;padding:0;line-height:1;flex-shrink:0;margin-top:-2px}

        /* ── RACE OVERLAY ────────────────────────────────────── */
        #race-overlay{position:fixed;inset:0;z-index:2000;display:flex;flex-direction:column;align-items:center;justify-content:center;background:var(--bg);transition:background .3s;opacity:0;visibility:hidden;pointer-events:none}
        #race-overlay.show{opacity:1;visibility:visible;pointer-events:all}
        #race-overlay.flash-red{background:#c0392b !important}
        @keyframes race-flash{0%,100%{background:#c0392b}50%{background:#e74c3c}}
        #race-overlay.flash-anim{animation:race-flash .3s ease-in-out 3}
        .race-overlay-x{position:absolute;top:max(14px,env(safe-area-inset-top,14px));right:14px;background:rgba(255,255,255,.1);border:1px solid rgba(255,255,255,.15);color:rgba(255,255,255,.7);font-size:18px;width:34px;height:34px;border-radius:50%;cursor:pointer;display:none;align-items:center;justify-content:center;z-index:1;line-height:1;padding:0}
        #race-overlay.show .race-overlay-x{display:flex}

        /* Approaching page */
        .race-approaching{text-align:center;padding:24px 20px;width:100%;max-width:360px}
        .race-approaching .ra-icon{font-size:44px;margin-bottom:10px}
        .race-approaching .ra-title{font-family:var(--fh);font-size:16px;font-weight:800;letter-spacing:1px;text-transform:uppercase;color:var(--tx);margin-bottom:4px}
        .race-approaching .ra-track{font-size:12px;color:var(--td);margin-bottom:18px;max-width:260px;margin-inline:auto}
        .race-approaching .ra-num{font-family:var(--fh);font-size:80px;font-weight:800;line-height:1;color:var(--ac);margin-bottom:2px;font-variant-numeric:tabular-nums}
        .race-approaching .ra-unit{font-family:var(--fh);font-size:14px;color:var(--td);text-transform:uppercase;letter-spacing:.8px;margin-bottom:16px}
        .race-approaching .ra-acc{font-size:11px;color:var(--tm)}
        .race-approaching .ra-hint{font-size:12px;color:var(--td);margin-top:8px;padding:8px 12px;background:var(--s2);border-radius:8px}

        /* Start line page (<= 5m) */
        .race-startline{text-align:center;padding:20px;width:100%;max-width:360px}
        .race-startline .rsl-label{font-family:var(--fh);font-size:11px;font-weight:700;letter-spacing:1px;text-transform:uppercase;color:var(--td);margin-bottom:10px}
        .rsl-vis{display:flex;align-items:center;justify-content:center;width:min(300px,88vw);height:56px;margin:0 auto 16px;background:repeating-linear-gradient(90deg,rgba(196,255,0,.05),rgba(196,255,0,.05) 16px,transparent 16px,transparent 17px);border-top:3px solid var(--ac);border-bottom:3px solid var(--ac);position:relative;box-shadow:0 0 20px rgba(196,255,0,.2)}
        .rsl-vis-text{font-family:var(--fh);font-size:18px;font-weight:900;letter-spacing:4px;color:var(--ac);text-shadow:0 0 12px rgba(196,255,0,.6)}
        .race-startline .rsl-dist{font-family:var(--fh);font-size:68px;font-weight:800;line-height:1;color:#fff;margin-bottom:4px;transition:color .2s;font-variant-numeric:tabular-nums}
        .race-startline .rsl-dist.green{color:#4ade80}
        .race-startline .rsl-unit{font-family:var(--fh);font-size:13px;color:var(--td);text-transform:uppercase;letter-spacing:.8px;margin-bottom:12px}
        .race-startline .rsl-hint{font-family:var(--fh);font-size:13px;font-weight:700;letter-spacing:.8px;text-transform:uppercase;color:var(--td);margin-bottom:6px}
        .race-startline .rsl-acc{font-size:10px;color:var(--tm)}
        @keyframes pulse-green{0%,100%{box-shadow:0 0 0 rgba(74,222,128,.4)}50%{box-shadow:0 0 24px rgba(74,222,128,.5)}}
        .rsl-vis.ready{border-color:#4ade80;animation:pulse-green 1s ease-in-out infinite}
        .rsl-vis.ready .rsl-vis-text{color:#4ade80;text-shadow:0 0 12px rgba(74,222,128,.7)}

        /* GO! page */
        .race-go-page{text-align:center;padding:20px;width:100%}
        .race-go-page .rg-go{font-family:var(--fh);font-size:100px;font-weight:900;letter-spacing:6px;color:var(--beg);line-height:1;animation:go-pop .45s cubic-bezier(.36,.07,.19,.97)}
        @keyframes go-pop{0%{transform:scale(.3);opacity:0}80%{transform:scale(1.15)}100%{transform:scale(1);opacity:1}}
        .race-go-page .rg-sub{font-family:var(--fh);font-size:14px;font-weight:700;letter-spacing:1px;text-transform:uppercase;color:var(--td);margin-top:12px}

        /* Running page */
        .race-running{text-align:center;padding:16px;width:100%;max-width:420px}
        .race-running .rr-name{font-family:var(--fh);font-size:11px;font-weight:700;letter-spacing:1px;text-transform:uppercase;color:var(--td);margin-bottom:8px}
        .race-running .rr-timer{font-family:var(--fh);font-size:58px;font-weight:800;letter-spacing:2px;color:var(--ac);line-height:1;margin-bottom:4px;font-variant-numeric:tabular-nums}
        .race-running .rr-timer.paused{color:var(--td)}
        @keyframes blink-td{50%{opacity:.25}}
        .race-running .rr-timer.paused{animation:blink-td 1s step-start infinite}
        .race-running .rr-pause-lbl{font-family:var(--fh);font-size:10px;font-weight:700;letter-spacing:.8px;text-transform:uppercase;color:var(--exp);min-height:14px;margin-bottom:8px}
        .rr-splits-grid{display:grid;grid-template-columns:repeat(4,1fr);gap:5px;margin:8px 0 12px}
        .rr-split-box{background:var(--s2);border-radius:8px;padding:7px 3px;text-align:center;border:1px solid transparent}
        .rr-split-box.active{background:rgba(56,189,248,.1);border-color:rgba(56,189,248,.3);animation:pulse-blue .9s ease-in-out infinite alternate}
        @keyframes pulse-blue{from{box-shadow:0 0 2px rgba(56,189,248,.1)}to{box-shadow:0 0 10px rgba(56,189,248,.4)}}
        .rr-split-box.done{background:rgba(196,255,0,.07);border-color:rgba(196,255,0,.18)}
        .rr-split-lbl{font-family:var(--fh);font-size:9px;font-weight:700;letter-spacing:.5px;text-transform:uppercase;color:var(--td)}
        .rr-split-val{font-family:var(--fh);font-size:15px;font-weight:800;color:var(--ac);margin-top:2px;font-variant-numeric:tabular-nums}
        .rr-split-val.empty{color:var(--tm);font-size:12px}
        .rr-speed-lbl{font-size:11px;color:var(--td);margin-bottom:12px}
        .rr-abort-btn{background:var(--s2);border:1px solid var(--bd2);color:var(--td);font-family:var(--fh);font-size:11px;font-weight:700;letter-spacing:.8px;text-transform:uppercase;padding:8px 18px;border-radius:8px;cursor:pointer;margin-top:4px}
        .rr-confirm-box{display:none;background:var(--s2);border-radius:10px;padding:12px;margin-top:8px;border:1px solid var(--bd2)}
        .rr-confirm-box.show{display:block}
        .rr-confirm-q{font-size:13px;color:var(--tx);text-align:center;margin-bottom:10px}
        .rr-confirm-btns{display:flex;gap:8px}
        .rr-confirm-btns button{flex:1;padding:8px;border-radius:8px;border:none;font-family:var(--fh);font-size:12px;font-weight:700;letter-spacing:.6px;cursor:pointer}

        /* Results page */
        .race-results{text-align:center;padding:16px;width:100%;max-width:400px;overflow-y:auto;max-height:90svh}
        .race-results .rres-crown{font-size:36px;margin-bottom:6px}
        .race-results .rres-title{font-family:var(--fh);font-size:20px;font-weight:800;letter-spacing:1px;text-transform:uppercase;color:var(--ac);margin-bottom:2px}
        .race-results .rres-track{font-size:12px;color:var(--td);margin-bottom:14px}
        .race-results .rres-total-time{font-family:var(--fh);font-size:52px;font-weight:800;color:var(--ac);line-height:1;font-variant-numeric:tabular-nums}
        .race-results .rres-total-lbl{font-size:11px;color:var(--td);text-transform:uppercase;letter-spacing:.6px;margin-bottom:16px}
        .rres-splits-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin-bottom:16px}
        .rres-split-card{background:var(--s2);border-radius:8px;padding:9px 8px;text-align:center}
        .rres-split-lbl{font-family:var(--fh);font-size:9px;font-weight:700;letter-spacing:.6px;text-transform:uppercase;color:var(--td);margin-bottom:3px}
        .rres-split-val{font-family:var(--fh);font-size:20px;font-weight:800;color:var(--tx);font-variant-numeric:tabular-nums}
        .rres-lb-head{font-family:var(--fh);font-size:11px;font-weight:700;letter-spacing:.8px;text-transform:uppercase;color:var(--td);margin:14px 0 8px;text-align:left}
        .rres-lb-row{display:flex;align-items:center;gap:8px;padding:7px 9px;border-radius:8px;background:var(--s2);margin-bottom:5px}
        .rres-lb-row.gold-row{background:rgba(245,158,11,.08);border:1px solid rgba(245,158,11,.2)}
        .rres-lb-row.cur-row{border:1px solid var(--log)}
        .rres-lb-rank{font-family:var(--fh);font-size:14px;font-weight:800;color:var(--td);width:22px;text-align:center;flex-shrink:0}
        .rres-lb-rank.gold{color:#f59e0b}
        .rres-lb-date{font-size:10px;color:var(--tm);flex:1;text-align:left}
        .rres-lb-time{font-family:var(--fh);font-size:18px;font-weight:800;color:var(--ac);font-variant-numeric:tabular-nums}
        .rres-actions{display:flex;gap:8px;margin-top:14px}
        .rres-btn{flex:1;padding:11px;border-radius:10px;border:none;font-family:var(--fh);font-size:12px;font-weight:700;letter-spacing:.7px;text-transform:uppercase;cursor:pointer}
        .rres-btn.prim{background:var(--ac);color:#0b0e14}
        .rres-btn.sec{background:var(--s2);color:var(--td)}

        /* ── TRACK DETAIL PANEL ─────────────────────────────── */
        .trk-detail{background:var(--s2);border-radius:10px;padding:12px 14px;margin:0 12px 8px;border:1px solid var(--bd2)}
        .trk-detail .tdd-head{display:flex;align-items:center;gap:8px;margin-bottom:10px}
        .trk-detail .tdd-dot{width:9px;height:9px;border-radius:50%;flex-shrink:0}
        .trk-detail .tdd-name{font-family:var(--fh);font-size:14px;font-weight:800;letter-spacing:.4px;color:var(--tx);flex:1;min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
        .trk-detail .tdd-close{background:none;border:none;color:var(--td);font-size:18px;cursor:pointer;padding:0;line-height:1}
        .tdd-stats{display:flex;gap:5px;margin-bottom:10px}
        .tdd-stat{flex:1;background:var(--s3);border-radius:6px;padding:6px 4px;text-align:center}
        .tdd-stat-val{font-family:var(--fh);font-size:15px;font-weight:800;color:var(--tx)}
        .tdd-stat-lbl{font-size:9px;text-transform:uppercase;letter-spacing:.5px;color:var(--td);margin-top:1px}
        .tdd-btns{display:flex;flex-direction:column;gap:6px}
        .tdd-btn{width:100%;padding:10px;border-radius:8px;border:none;font-family:var(--fh);font-size:12px;font-weight:700;letter-spacing:.8px;text-transform:uppercase;cursor:pointer;display:flex;align-items:center;justify-content:center;gap:7px;text-decoration:none}
        .tdd-btn.race{background:var(--ac);color:#0b0e14}
        .tdd-btn.navi{background:transparent;color:var(--log);border:1px solid rgba(56,189,248,.4)}
        .tdd-btn.gmaps{background:transparent;color:var(--td);border:1px solid var(--bd2)}
        .tdd-lb{margin-top:10px}
        .tdd-lb-head{font-family:var(--fh);font-size:10px;font-weight:700;letter-spacing:.8px;text-transform:uppercase;color:var(--td);margin-bottom:7px}
        .tdd-lb-empty{font-size:11px;color:var(--tm);text-align:center;padding:6px}
        .tdd-lb-row{display:flex;align-items:center;gap:7px;padding:5px 8px;border-radius:6px;background:var(--s3);margin-bottom:3px}
        .tdd-lb-row.gold-lb{background:rgba(245,158,11,.07)}
        .tdd-lb-rank{font-family:var(--fh);font-size:12px;font-weight:800;color:var(--td);width:18px;text-align:center;flex-shrink:0}
        .tdd-lb-rank.gold{color:#f59e0b}
        .tdd-lb-time{font-family:var(--fh);font-size:17px;font-weight:800;color:var(--ac);margin-left:auto;font-variant-numeric:tabular-nums}
        .tdd-lb-date{font-size:10px;color:var(--tm);flex:1}
        .tdd-lb-export{margin-top:7px;width:100%;padding:7px;border-radius:6px;background:var(--s3);border:1px solid var(--bd);color:var(--td);font-family:var(--fh);font-size:10px;font-weight:700;letter-spacing:.6px;text-transform:uppercase;cursor:pointer}

        /* Checkpoint markers on map */
        .chk-div{width:16px;height:16px;border-radius:50%;background:rgba(196,255,0,.3);border:2.5px solid var(--ac);box-shadow:0 0 6px rgba(196,255,0,.4)}
        .chk-div.finish{background:rgba(239,68,68,.3);border-color:var(--exp);box-shadow:0 0 6px rgba(239,68,68,.4)}

        /* ── START MARKER ────────────────────────────────────────── */
        .start-pin{width:26px;height:32px;display:flex;align-items:center;justify-content:center;border-radius:50% 50% 50% 0;transform:rotate(-45deg);border:2.5px solid rgba(255,255,255,.9);box-shadow:0 2px 12px rgba(0,0,0,.65);cursor:pointer;transition:transform .15s,box-shadow .15s}
        .start-pin:hover,.start-pin:active{transform:rotate(-45deg) scale(1.15);box-shadow:0 4px 18px rgba(0,0,0,.8)}
        .start-pin-flag{transform:rotate(45deg);font-size:13px;line-height:1;user-select:none;pointer-events:none}

        /* ── CANVAS APPROACH PAGE ─────────────────────────────────── */
        #rp-approach{position:absolute;inset:0;overflow:hidden;background:#0b0e14;display:none}
        #approach-canvas{display:block;position:absolute;inset:0;width:100%;height:100%}
        #approach-confirm{position:absolute;bottom:0;left:0;right:0;display:none;flex-direction:column;align-items:center;gap:14px;padding:24px 24px 48px;background:linear-gradient(transparent,rgba(11,14,20,.95) 35%);z-index:3}
        #approach-confirm.show{display:flex}
        .approach-confirm-q{font-family:var(--fh);font-size:16px;font-weight:800;color:#fff;letter-spacing:.8px;text-transform:uppercase;text-align:center;line-height:1.4}
        .approach-confirm-btns{display:flex;gap:12px;width:100%;max-width:300px}
        .approach-confirm-btns button{flex:1;font-family:var(--fh);font-size:14px;font-weight:800;letter-spacing:1px;text-transform:uppercase;border:none;border-radius:12px;padding:16px 14px;cursor:pointer;transition:transform .12s}
        .approach-confirm-btns button:active{transform:scale(.95)}
        .approach-btn-yes{background:#c8ff00;color:#0b0e14}
        .approach-btn-no{background:rgba(255,255,255,.1);color:rgba(255,255,255,.8);border:1px solid rgba(255,255,255,.2)!important}

        /* ── TRACK DETAIL SLOT ───────────────────────────────────── */
        .trk-detail-loading{background:var(--s2);border-radius:10px;padding:14px;margin:0 12px 8px;border:1px solid var(--bd2);text-align:center;color:var(--td);font-size:11px;font-style:italic}

        /* ── RACE RESULTS QR ─────────────────────────────────────── */
        .rres-qr-wrap{background:#fff;border-radius:10px;padding:8px;width:136px;height:136px;margin:12px auto;display:flex;align-items:center;justify-content:center}
        .rres-qr-wrap canvas{border-radius:4px;image-rendering:pixelated;image-rendering:crisp-edges}

    </style>
</head>
<body>
<div id="map"></div>

<!-- TOP BAR -->
<div id="topbar">
  <div id="tbrow">
    <button class="ibtn" onclick="toggleSheet()" aria-label="Menü">
      <svg width="18" height="14" viewBox="0 0 18 14" fill="none"><path d="M0 1H18M0 7H12M0 13H18" stroke="currentColor" stroke-width="1.8" stroke-linecap="round"/></svg>
    </button>
    <div id="titlepill">
      <div class="logobadge">MUNI</div>
      <div><div class="ttl">GMTW Trail Map</div><div class="tsub">Hohensyburg · Herdecke</div></div>
    </div>
    <button class="ibtn" id="layer-btn" onclick="toggleLayer()" aria-label="Karte wechseln">
      <svg width="18" height="18" viewBox="0 0 18 18" fill="none"><path d="M9 1L17 5.5L9 10L1 5.5L9 1Z" stroke="currentColor" stroke-width="1.5" stroke-linejoin="round"/><path d="M1 9.5L9 14L17 9.5" stroke="currentColor" stroke-width="1.5" stroke-linejoin="round"/></svg>
    </button>
  </div>
</div>

<!-- FILTER -->
<div id="fbar">
  <button class="chip on" data-f="all"      onclick="setFilter('all',this)">Alle</button>
  <button class="chip"    data-f="beginner" aria-label="Beginner Filter" onclick="setFilter('beginner',this)">🟢 Beginner</button>
  <button class="chip"    data-f="mittel"   onclick="setFilter('mittel',this)">🟡 Mittel</button>
  <button class="chip"    data-f="expert"   onclick="setFilter('expert',this)">🔴 Expert</button>
  <button class="chip"    data-f="logistik" aria-label="Logistik Filter" onclick="setFilter('logistik',this)">🔵 Logistik</button>
</div>

<!-- FABS -->
<div class="fabs">
  <button class="fab" id="gps-fab" onclick="locateUser()" aria-label="GPS">
    <svg id="gps-icon" width="20" height="20" viewBox="0 0 20 20" fill="none"><circle cx="10" cy="10" r="3" fill="currentColor"/><path d="M10 2V5M10 15V18M18 10H15M5 10H2" stroke="currentColor" stroke-width="1.8" stroke-linecap="round"/><circle cx="10" cy="10" r="7" stroke="currentColor" stroke-width="1.2" opacity=".35"/></svg>
  </button>
  <button class="fab" id="gpx-fab" onclick="openGpxPanel('load')" aria-label="GPX Tracks" style="position:relative">
    <svg width="20" height="20" viewBox="0 0 20 20" fill="none"><path d="M3 15L7 9L11 12L15 6L18 9" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/><circle cx="3" cy="15" r="1.8" fill="currentColor"/><circle cx="18" cy="9" r="1.8" fill="currentColor"/></svg>
    <span class="fab-badge" id="gpx-cnt" style="display:none">0</span>
  </button>
  <button class="fab" id="rec-fab" onclick="openGpxPanel('rec')" aria-label="Aufnahme starten">
    <svg width="18" height="18" viewBox="0 0 18 18" fill="none"><circle cx="9" cy="9" r="6" stroke="currentColor" stroke-width="1.6"/><circle cx="9" cy="9" r="3" fill="currentColor"/></svg>
  </button>
  <button class="fab" id="theme-fab" onclick="toggleTheme()" aria-label="Hell/Dunkel Modus" title="Hell/Dunkel wechseln">
    <svg id="ti-moon" width="18" height="18" viewBox="0 0 18 18" fill="none"><path d="M15.5 11A6.5 6.5 0 017 3.5a.5.5 0 00-.6-.57A7 7 0 1015.07 12a.5.5 0 00-.57-.6 6.5 6.5 0 01-.98.07L15.5 11z" fill="currentColor" opacity=".9"/></svg>
    <svg id="ti-sun" width="18" height="18" viewBox="0 0 18 18" fill="none" style="display:none"><circle cx="9" cy="9" r="3.5" stroke="currentColor" stroke-width="1.7"/><path d="M9 1.5v2M9 14.5v2M1.5 9h2M14.5 9h2M3.6 3.6l1.4 1.4M13 13l1.4 1.4M3.6 14.4l1.4-1.4M13 5l1.4-1.4" stroke="currentColor" stroke-width="1.7" stroke-linecap="round"/></svg>
  </button>
  <button class="fab" onclick="fitAll()" aria-label="Übersicht">
    <svg width="18" height="18" viewBox="0 0 18 18" fill="none"><rect x="1" y="1" width="5" height="5" rx="1.5" stroke="currentColor" stroke-width="1.6"/><rect x="12" y="1" width="5" height="5" rx="1.5" stroke="currentColor" stroke-width="1.6"/><rect x="1" y="12" width="5" height="5" rx="1.5" stroke="currentColor" stroke-width="1.6"/><rect x="12" y="12" width="5" height="5" rx="1.5" stroke="currentColor" stroke-width="1.6"/></svg>
  </button>
</div>

<!-- LEGEND -->
<div id="legend">
  <div class="lgnd-t">Legende</div>
  <div class="lgnd-r"><div class="lgnd-d" style="background:var(--beg)"></div><span class="lgnd-l">Beginner</span></div>
  <div class="lgnd-r"><div class="lgnd-d" style="background:var(--mit)"></div><span class="lgnd-l">Mittel</span></div>
  <div class="lgnd-r"><div class="lgnd-d" style="background:var(--exp)"></div><span class="lgnd-l">Expert</span></div>
  <div class="lgnd-r"><div class="lgnd-d" style="background:var(--log)"></div><span class="lgnd-l">Logistik</span></div>
</div>

<div id="backdrop" onclick="closeAll()"></div>

<!-- SHEET -->
<div id="sheet" role="dialog" aria-modal="true" aria-labelledby="sheet-title">
  <div class="s-handle"></div>
  <div class="s-head">
    <div style="display:flex;align-items:center;gap:10px">
      <span class="s-title" id="sheet-title">Trail Punkte</span>
      <span class="s-cnt" id="s-cnt">0</span>
    </div>
    <button class="s-close" onclick="closeAll()">×</button>
  </div>
  <div class="s-scroll" id="s-list"></div>
</div>

<!-- QR MODAL -->
<div id="qrm" role="dialog" aria-modal="true" aria-labelledby="qr-nm">
  <div class="qr-nm" id="qr-nm">Standort</div>
  <div class="qr-hint" id="qr-hint">QR scannen → startet Navigation in Google Maps</div>
  <div id="qr-wrap"><canvas id="qr-canvas" width="160" height="160" aria-label="QR Code"></canvas></div>
  <input id="qr-inp" type="text" readonly onclick="this.select()">
  <div class="qr-acts">
    <button class="qbtn cl" onclick="closeAll()">← Zurück</button>
    <button class="qbtn cp" onclick="copyQR()">📋 Kopieren</button>
    <button class="qbtn dl" onclick="downloadQR()">⬇ QR</button>
  </div>
</div>

<!-- GPS HINT -->
<div id="gpshint">
  <button id="gpshint-x" onclick="hideGpsHint()">×</button>
  <strong id="gpshint-t">GPS Problem</strong>
  <span id="gpshint-m">Standortzugriff verweigert.</span>
</div>

<!-- AUFNAHME STATUS BAR -->
<div id="rec-bar">
  <div class="rec-dot"></div>
  <span class="rec-bar-txt" id="rec-bar-txt">00:00:00</span>
</div>

<!-- GPX PANEL -->
<div id="gpx-panel" role="dialog" aria-modal="true" aria-labelledby="gpx-panel-title">
  <div class="s-handle"></div>
  <div class="s-head">
    <div style="display:flex;align-items:center;gap:10px">
      <span class="s-title" id="gpx-panel-title">GPX & Tracks</span>
      <span class="s-cnt" id="gpx-track-cnt">0 Tracks</span>
    </div>
    <button class="s-close" onclick="closeGpxPanel()">×</button>
  </div>
  <!-- TABS -->
  <div class="gpx-tabs">
    <button class="gpx-tab on" data-tab="load" onclick="switchGpxTab('load',this)">Laden</button>
    <button class="gpx-tab" data-tab="tracks" onclick="switchGpxTab('tracks',this)">Tracks</button>
    <button class="gpx-tab" data-tab="rec" onclick="switchGpxTab('rec',this)">Aufnahme</button>
  </div>

  <!-- TAB: LADEN -->
  <div class="gpx-content on" id="gpx-tab-load">
    <!-- Kategorie Auswahl -->
    <div class="gpx-section">
      <span class="gpx-label">Kategorie für neuen Track</span>
      <select class="gpx-select" id="gpx-cat">
        <option value="beginner">🟢 Beginner</option>
        <option value="mittel" selected>🟡 Mittel</option>
        <option value="expert">🔴 Expert</option>
      </select>
    </div>
    <!-- Datei Upload -->
    <div class="gpx-section">
      <span class="gpx-label">GPX vom Gerät laden</span>
      <label class="gpx-file-label" for="gpx-file-input">
        <svg width="20" height="20" viewBox="0 0 20 20" fill="none"><path d="M10 13V4M6 8L10 4L14 8" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/><path d="M3 16H17" stroke="currentColor" stroke-width="1.8" stroke-linecap="round"/></svg>
        .gpx Datei(en) auswählen oder hierher ziehen
      </label>
      <input type="file" id="gpx-file-input" accept=".gpx,application/gpx+xml,application/xml,text/xml" multiple onchange="handleGpxFiles(this)">
    </div>
    <!-- URL laden -->
    <div class="gpx-section">
      <span class="gpx-label">GPX per URL laden</span>
      <div class="gpx-row" style="margin-bottom:6px">
        <input class="gpx-input" id="gpx-url-inp" type="url" placeholder="https://raw.githubusercontent.com/…/track.gpx">
        <button class="gpx-btn prim" onclick="loadGpxFromUrl()">
          <svg width="14" height="14" viewBox="0 0 14 14" fill="none"><path d="M2 7H12M8 3L12 7L8 11" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/></svg>
          Laden
        </button>
      </div>
      <div class="cors-hint">
        <b style="color:var(--ac)">GitHub:</b> <code style="font-size:10px;background:var(--s3);padding:1px 4px;border-radius:3px;font-family:monospace">/blob/</code> → <code style="font-size:10px;background:var(--s3);padding:1px 4px;border-radius:3px;font-family:monospace">raw.githubusercontent.com</code> (wird automatisch umgewandelt) &nbsp;·&nbsp;
        CORS-Fehler: <a href="#" onclick="useCorsProxy();return false">Proxy aktivieren</a> <span style="color:var(--tm)">(Datenschutz beachten)</span>
      </div>
    </div>
  </div>

  <!-- TAB: TRACKS -->
  <div class="gpx-content" id="gpx-tab-tracks">
    <!-- Kategorie-Filter -->
    <div class="cat-filter-row">
      <button class="cat-fbtn on" data-c="all" onclick="filterTracks('all',this)">Alle</button>
      <button class="cat-fbtn" data-c="beginner" onclick="filterTracks('beginner',this)">🟢 Beginner</button>
      <button class="cat-fbtn" data-c="mittel" onclick="filterTracks('mittel',this)">🟡 Mittel</button>
      <button class="cat-fbtn" data-c="expert" onclick="filterTracks('expert',this)">🔴 Expert</button>
    </div>
    <div id="trk-list"><div style="padding:20px 16px;text-align:center;color:var(--td);font-family:var(--fh);font-size:13px;font-weight:700;text-transform:uppercase;letter-spacing:1px">Noch keine Tracks geladen</div></div>
    <!-- Elevation Profile -->
    <div id="elev-panel" aria-label="Höhenprofil">
      <div id="elev-title">Höhenprofil</div>
      <canvas id="elev-canvas"></canvas>
      <div id="elev-stats">
        <div class="elev-stat"><div class="elev-stat-v" id="elev-min">–</div><div class="elev-stat-l">Min m</div></div>
        <div class="elev-stat"><div class="elev-stat-v" id="elev-max">–</div><div class="elev-stat-l">Max m</div></div>
        <div class="elev-stat"><div class="elev-stat-v" id="elev-gain">–</div><div class="elev-stat-l">↑ Aufst.</div></div>
        <div class="elev-stat"><div class="elev-stat-v" id="elev-dist">–</div><div class="elev-stat-l">km</div></div>
      </div>
    </div>
  </div>

  <!-- TAB: AUFNAHME -->
  <div class="gpx-content" id="gpx-tab-rec">
    <div class="gpx-section" style="text-align:center;padding-bottom:0;border-bottom:none">
      <div class="rec-timer" id="rec-timer">00:00:00</div>
      <div class="rec-status" id="rec-status-txt" style="color:var(--tm)">Bereit</div>
    </div>
    <div class="rec-stats">
      <div class="rec-stat"><div class="rec-stat-val" id="rec-dist">0.0</div><div class="rec-stat-lbl">km</div></div>
      <div class="rec-stat"><div class="rec-stat-val" id="rec-pts">0</div><div class="rec-stat-lbl">Punkte</div></div>
      <div class="rec-stat"><div class="rec-stat-val" id="rec-speed">0.0</div><div class="rec-stat-lbl">km/h</div></div>
    </div>
    <div class="rec-controls">
      <button class="gpx-btn prim" id="rec-start-btn" onclick="recStart()" style="flex:2">
        <svg width="14" height="14" viewBox="0 0 14 14" fill="none"><circle cx="7" cy="7" r="5.5" stroke="currentColor" stroke-width="1.5"/><circle cx="7" cy="7" r="3" fill="currentColor"/></svg>
        Aufnahme starten
      </button>
      <button class="gpx-btn sec" id="rec-pause-btn" onclick="recPause()" style="display:none;flex:1">Pause</button>
      <button class="gpx-btn danger" id="rec-stop-btn" onclick="recStop()" style="display:none">Stop</button>
    </div>
    <div class="gpx-section" id="rec-save-section" style="display:none">
      <span class="gpx-label">Strecke speichern &amp; laden</span>
      <div style="display:flex;flex-direction:column;gap:8px">
        <div class="gpx-row">
          <input class="gpx-input" id="rec-name-inp" type="text" placeholder="Streckenname…">
        </div>
        <select class="gpx-select" id="rec-save-cat">
          <option value="beginner">🟢 Beginner</option>
          <option value="mittel" selected>🟡 Mittel</option>
          <option value="expert">🔴 Expert</option>
        </select>
        <button class="gpx-btn prim" onclick="recAddToMap()" style="width:100%;justify-content:center">
          ＋ In Karte laden &amp; anzeigen
        </button>
        <div class="gpx-row">
          <button class="gpx-btn sec" onclick="recExportGpx()" style="flex:1">⬇ GPX</button>
          <button class="gpx-btn sec" onclick="recExportJson()" style="flex:1">⬇ JSON</button>
        </div>
        <button class="gpx-btn danger" onclick="recReset()" style="width:100%">🗑 Aufnahme verwerfen</button>
      </div>
    </div>
  </div>
</div>


<!-- DRAG & DROP Overlay für GPX -->
<div id="gpx-drop-overlay" style="display:none;position:fixed;inset:0;z-index:1500;background:rgba(200,255,0,.12);border:3px dashed var(--ac);pointer-events:none;align-items:center;justify-content:center;font-family:var(--fh);font-size:18px;font-weight:800;letter-spacing:1px;color:var(--ac);text-transform:uppercase">
  GPX Datei hier ablegen
</div>
<!-- TRACK QR MODAL -->
<div id="trk-qrm" style="position:fixed;top:50%;left:50%;z-index:1100;transform:translate(-50%,-50%) scale(.88);background:var(--s1);border:1px solid var(--bd2);border-radius:20px;box-shadow:0 20px 60px rgba(0,0,0,.8);width:92%;max-width:340px;padding:20px;text-align:center;opacity:0;visibility:hidden;transition:all .25s cubic-bezier(.32,.72,0,1)">
  <div style="font-family:var(--fh);font-size:17px;font-weight:800;letter-spacing:.5px;text-transform:uppercase;color:var(--tx);margin-bottom:2px" id="trk-qr-nm">Track</div>
  <div style="font-size:11px;color:var(--td);margin-bottom:12px" id="trk-qr-hint">GPX laden oder QR scannen</div>
  <div style="width:180px;height:180px;margin:0 auto 12px;background:#fff;border-radius:12px;padding:8px;display:flex;align-items:center;justify-content:center">
    <canvas id="trk-qr-canvas" width="164" height="164" style="display:block;border-radius:6px;image-rendering:pixelated;image-rendering:crisp-edges" aria-label="Track QR Code"></canvas>
  </div>
  <div style="font-size:10px;color:var(--td);margin-bottom:12px;padding:8px;background:var(--s2);border-radius:8px;text-align:left;line-height:1.5" id="trk-qr-info"></div>
  <div style="display:flex;gap:8px;margin-bottom:8px">
    <button class="qbtn sec" onclick="closeAll()" style="flex:1;background:var(--s2);color:var(--td)">← Zurück</button>
    <button class="qbtn dl" onclick="trkQrDownloadGpx()" style="flex:2" id="trk-qr-dl-btn">⬇ GPX laden</button>
  </div>
  <div style="display:flex;gap:8px">
    <button class="qbtn cp" onclick="trkQrDownloadImg()" style="flex:1;background:var(--s3);color:var(--tx)">⬇ QR Bild</button>
    <button class="qbtn cp" onclick="trkQrCopyUrl()" style="flex:1;background:var(--s3);color:var(--tx)">📋 Link</button>
  </div>
</div>
<div id="toast"></div>

<script>
// ═══════════════════════════════════════════════════════════════
// GMTW TRAIL MAP — vollständiges JS
// Fixes: XSS, QR lokal, localStorage, Theme, Elevation, Deep Link
// ═══════════════════════════════════════════════════════════════

// ── SICHERHEIT: Universelle HTML-Escape-Funktion ──────────────
function escHtml(s){
  if(s==null)return '';
  return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;');
}
// Alias für Legacy-Code & onclick-Strings
function esc(s){ return String(s||'').replace(/'/g,"\\'"); }
function escXml(s){ return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

// ── LOKALSTORAGE: sicheres Lesen/Schreiben ─────────────────────
const LS = {
  K: { TRACKS:'gmtw_tracks_v2', RUNS:'gmtw_runs_v1', REC:'gmtw_rec_v2', VIEW:'gmtw_view_v1', THEME:'gmtw_theme' },
  _ok: null,

  // Prüft ob localStorage verfügbar ist (Private Mode, iOS-Restrictions etc.)
  ok() {
    if (this._ok !== null) return this._ok;
    try {
      localStorage.setItem('__gmtw_probe__','1');
      localStorage.removeItem('__gmtw_probe__');
      this._ok = true;
    } catch(e) { this._ok = false; }
    return this._ok;
  },

  set(key, val) {
    if (!this.ok()) return false;
    try {
      localStorage.setItem(key, JSON.stringify(val));
      return true;
    } catch(e) {
      const isQuota = e.name==='QuotaExceededError'
        || e.name==='NS_ERROR_DOM_QUOTA_REACHED'
        || e.code===22;
      if (isQuota) {
        // Key löschen, nochmal versuchen
        try {
          localStorage.removeItem(key);
          localStorage.setItem(key, JSON.stringify(val));
          return true;
        } catch(e2) {
          console.warn('localStorage quota exceeded:', key);
          return false;
        }
      }
      console.warn('localStorage.set error:', key, e);
      return false;
    }
  },

  get(key, fb=null) {
    if (!this.ok()) return fb;
    try {
      const raw = localStorage.getItem(key);
      return raw !== null ? JSON.parse(raw) : fb;
    } catch(e) { return fb; }
  },

  del(key) {
    if (!this.ok()) return;
    try { localStorage.removeItem(key); } catch(e) {}
  },

  // Belegten Speicher (nur gmtw_* Keys) in Bytes schätzen
  usedBytes() {
    if (!this.ok()) return 0;
    try {
      let n = 0;
      for (let i = 0; i < localStorage.length; i++) {
        const k = localStorage.key(i);
        if (k && k.startsWith('gmtw_')) {
          const v = localStorage.getItem(k) || '';
          n += (k.length + v.length) * 2;
        }
      }
      return n;
    } catch(e) { return 0; }
  }
};

// ── DATEN ──────────────────────────────────────────────────────
const LOCS = [
  // BEGINNER
  { id:"muni",     name:"Muni Start Beginner/Mittel", lat:51.421812, lng:7.492612, color:"#22c55e", emoji:"🚩", cat:"beginner", desc:"Startpunkt für Muni-Fahrer aller Levels" },
  { id:"ein-beg",  name:"Einstieg Beginner",          lat:51.419668, lng:7.484089, color:"#22c55e", emoji:"🟢", cat:"beginner", desc:"Haupteinstieg für Anfänger" },
  { id:"ein-bm",   name:"Einstieg Beginner/Mittel",   lat:51.420365, lng:7.483406, color:"#22c55e", emoji:"🟡", cat:"beginner", desc:"Gemischter Einstieg — Beginner & Mittel" },
  { id:"end-ein",  name:"Ende Beginner",               lat:51.418374, lng:7.478817, color:"#22c55e", emoji:"🏁", cat:"beginner", desc:"Ziel der einfachen Strecke" },
  // MITTEL — Koordinaten korrekt: sam-mit=Sammelpunkt(51.423371), ziel-mit=Ziel(51.419329)
  { id:"ein-mit",  name:"Einstieg Mittel",            lat:51.423421, lng:7.480829, color:"#f59e0b", emoji:"🟡", cat:"mittel",   desc:"Einstieg in die mittlere Strecke" },
  { id:"end-mit",  name:"Ende Mittel",                lat:51.418704, lng:7.477420, color:"#f59e0b", emoji:"🏁", cat:"mittel",   desc:"Ziel der mittleren Strecke" },
  { id:"sam-mit",  name:"Sammelpunkt Mittel",         lat:51.423371, lng:7.513606, color:"#f59e0b", emoji:"👥", cat:"mittel",   desc:"Sammelpunkt — Auf dem Spielplatz" },
  { id:"ziel-mit", name:"Ziel Mittel",                lat:51.419329, lng:7.511120, color:"#f59e0b", emoji:"🏆", cat:"mittel",   desc:"Ziel der mittleren Strecke — an der Ruhr" },
  // EXPERT
  { id:"st-exp",   name:"Start Expert",               lat:51.418657, lng:7.477602, color:"#ef4444", emoji:"💀", cat:"expert",   desc:"Nur für erfahrene Fahrer!" },
  { id:"exp-zone", name:"Expert Zone",                lat:51.418692, lng:7.475410, color:"#ef4444", emoji:"⚠️", cat:"expert",   desc:"Hochanspruchsvolles Gelände" },
  { id:"exp-kurs", name:"Zerstörer",                  lat:51.416403, lng:7.453939, color:"#ef4444", emoji:"🎇", cat:"expert",   desc:"Links sehr schwer, rechts schwer" },
  // LOGISTIK
  { id:"camp",      name:"GMTW Camp",            lat:51.417704, lng:7.494867, color:"#38bdf8", emoji:"⛺", cat:"logistik", desc:"Hauptcamp des Events — Basisstation", large:true },
  { id:"camp-tor",  name:"Camp Tor",             lat:51.417482, lng:7.490904, color:"#38bdf8", emoji:"🚧", cat:"logistik", desc:"Haupteingang zum GMTW Camp" },
  { id:"zeltplatz", name:"Zeltplatz Eingang",    lat:51.420130, lng:7.495086, color:"#38bdf8", emoji:"🏕️",cat:"logistik", desc:"Eingang Campingplatz Hohensyburg · Syburger Dorfstr. 69" },
  { id:"sam-beg",   name:"Sammelpunkt Beginner", lat:51.419799, lng:7.484685, color:"#38bdf8", emoji:"👥", cat:"logistik", desc:"Treffpunkt nach dem Aufstieg vom Camp" },
  { id:"sam-mit",  name:"Sammelpunkt Mittel",         lat:51.423371, lng:7.513606, color:"#f59e0b", emoji:"👥", cat:"logistik", desc:"Sammelpunkt — Auf dem Spielplatz" },
  { id:"sam-camp",  name:"Sammelpunkt → Camp",   lat:51.418164, lng:7.478552, color:"#38bdf8", emoji:"🔁", cat:"logistik", desc:"Treffpunkt für den Rückweg ins Camp" },
  { id:"wc",        name:"Dusche / WC",          lat:51.418808, lng:7.493754, color:"#a78bfa", emoji:"🚿", cat:"logistik", desc:"Sanitäreinrichtungen am Camp" },
];

const CATS = {
  beginner: { label:"Beginner",                color:"var(--beg)" },
  mittel:   { label:"Mittel",                  color:"var(--mit)" },
  expert:   { label:"Expert",                  color:"var(--exp)" },
  logistik: { label:"Logistik & Einrichtungen",color:"var(--log)" },
};
const WEG = [[51.418146,7.478490],[51.417422,7.490686]];

// GPX Farben (spec-konform)
const GPX_COLORS = { beginner:'#27AE60', mittel:'#D4A017', expert:'#8E44AD' };

// ── KARTE ──────────────────────────────────────────────────────
const map = L.map('map',{zoomControl:false,tap:false,zoomSnap:0.1,zoomDelta:0.5,wheelPxPerZoomLevel:120}).setView([51.4192,7.4855],16);
L.control.zoom({position:'bottomright'}).addTo(map);

// Gespeicherte Kartenposition laden
(function(){
  const v=LS.get(LS.K.VIEW);
  if(v&&v.lat&&v.lng&&v.zoom) map.setView([v.lat,v.lng],v.zoom);
})();

const TOPO = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',{
  maxNativeZoom:17,maxZoom:26,
  attribution:'<a href="https://opentopomap.org">© OpenTopoMap</a> (CC-BY-SA) · <a href="https://www.openstreetmap.org/copyright">© OSM</a>'
}).addTo(map);
const SAT = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',{
  maxNativeZoom:19,maxZoom:26,attribution:'© Esri'
});
let isSat=false;
function toggleLayer(){
  if(isSat){map.removeLayer(SAT);map.addLayer(TOPO);isSat=false;toast('🌲 Topo Ansicht')}
  else{map.removeLayer(TOPO);map.addLayer(SAT);isSat=true;toast('🛰 Satellit Ansicht')}
}

// Kartenposition speichern bei Bewegung
map.on('moveend zoomend',()=>{
  const c=map.getCenter();
  LS.set(LS.K.VIEW,{lat:c.lat,lng:c.lng,zoom:map.getZoom()});
});

// Weg zurück
L.polyline(WEG,{color:'#f59e0b',weight:3.5,dashArray:'8 10',lineCap:'round',opacity:.85})
  .addTo(map).bindTooltip('Weg zurück ins Camp',{permanent:true,direction:'center',className:'path-lbl'});

// ── MARKER ─────────────────────────────────────────────────────
const MKR={};
let curFilter='all';

function mkIcon(loc){
  const s=loc.large?36:30, is=loc.large?16:13;
  return L.divIcon({
    className:'',
    html:`<div class="pm${loc.large?' lg':''}"><div class="pm-h" style="background:${loc.color}"><span class="pm-i" style="font-size:${is}px">${loc.emoji}</span></div><div class="pm-d" style="background:${loc.color}"></div></div>`,
    iconSize:[s,s+8],iconAnchor:[s/2,s+8],popupAnchor:[0,-(s+12)]
  });
}

function mkPopup(loc){
  const c=CATS[loc.cat];
  // escHtml für alle user-sichtbaren Strings
  const nm=escHtml(loc.name), ds=escHtml(loc.desc||''), badge=escHtml(c.label);
  return `<div style="background:var(--s1)">
    <div class="p-top">
      <div class="p-badge" style="background:${loc.color}">${badge}</div>
      <div class="p-name">${nm}</div>
      <div class="p-crds">${loc.lat.toFixed(5)}, ${loc.lng.toFixed(5)}</div>
      ${ds?`<div class="p-desc">${ds}`:''}
    </div>
    <div class="p-acts">
      <button class="pbtn nav" onclick="navTo(${loc.lat},${loc.lng},'${esc(loc.name)}')" aria-label="Navigation starten">
        <svg width="13" height="13" viewBox="0 0 13 13" fill="none"><path d="M6.5 1L12 6.5L6.5 12M1 6.5H11.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
        Navigation
      </button>
      <button class="pbtn shr" onclick="openQR('${esc(loc.id)}')" aria-label="QR-Code anzeigen">
        <svg width="15" height="15" viewBox="0 0 14 14" fill="none"><rect x="1" y="1" width="4" height="4" rx=".5" stroke="currentColor" stroke-width="1.3"/><rect x="9" y="1" width="4" height="4" rx=".5" stroke="currentColor" stroke-width="1.3"/><rect x="1" y="9" width="4" height="4" rx=".5" stroke="currentColor" stroke-width="1.3"/><path d="M9 9h1v1M11 9h1M9 11v1M11 12h1M12 11v-1" stroke="currentColor" stroke-width="1.3" stroke-linecap="round"/></svg>
        Nav-QR
      </button>
    </div>
  </div>`;
}

LOCS.forEach(loc=>{
  const m=L.marker([loc.lat,loc.lng],{icon:mkIcon(loc)}).addTo(map);
  m.bindTooltip(loc.name,{permanent:true,direction:'bottom',offset:[0,4],className:'map-label'});
  m.bindPopup(mkPopup(loc),{maxWidth:292,minWidth:250});
  MKR[loc.id]={m,loc};
});

// ── SHEET / POI-LISTE ──────────────────────────────────────────
function buildList(){
  const c=document.getElementById('s-list'); c.innerHTML='';
  let n=0;
  ['beginner','mittel','expert','logistik'].forEach(cat=>{
    const items=LOCS.filter(l=>l.cat===cat&&(curFilter==='all'||curFilter===cat));
    if(!items.length)return;
    const hd=document.createElement('div'); hd.className='cat-head'; hd.textContent=CATS[cat].label; c.appendChild(hd);
    items.forEach(loc=>{
      n++;
      const r=document.createElement('div'); r.className='lrow';
      r.setAttribute('role','listitem');
      r.innerHTML=`<div class="l-ico" style="background:${loc.color}22"><span role="img" aria-label="${escHtml(CATS[loc.cat].label)}">${loc.emoji}</span></div>
        <div class="l-inf"><div class="l-nm">${escHtml(loc.name)}</div><div class="l-co">${loc.lat.toFixed(5)}, ${loc.lng.toFixed(5)}</div></div>
        <div class="l-btns">
          <button class="lbtn nav" aria-label="Navigation zu ${escHtml(loc.name)}" onclick="event.stopPropagation();navTo(${loc.lat},${loc.lng},'${esc(loc.name)}')"><svg width="13" height="13" viewBox="0 0 13 13" fill="none"><path d="M6.5 1L12 6.5L6.5 12M1 6.5H11" stroke="currentColor" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"/></svg></button>
          <button class="lbtn" aria-label="QR-Code für ${escHtml(loc.name)}" onclick="event.stopPropagation();openQR('${esc(loc.id)}')"><svg width="13" height="13" viewBox="0 0 14 14" fill="none"><rect x="1" y="1" width="4" height="4" rx=".5" stroke="currentColor" stroke-width="1.3"/><rect x="9" y="1" width="4" height="4" rx=".5" stroke="currentColor" stroke-width="1.3"/><rect x="1" y="9" width="4" height="4" rx=".5" stroke="currentColor" stroke-width="1.3"/><path d="M9 9h1v1M11 9h1M9 11v1" stroke="currentColor" stroke-width="1.3" stroke-linecap="round"/></svg></button>
        </div>`;
      r.addEventListener('click',()=>focusMarker(loc.id));
      c.appendChild(r);
    });
  });
  document.getElementById('s-cnt').textContent=n;
}

function toggleSheet(){
  const s=document.getElementById('sheet'),b=document.getElementById('backdrop');
  if(s.classList.contains('open')){s.classList.remove('open');b.classList.remove('show')}
  else{buildList();s.classList.add('open');b.classList.add('show');s.focus();}
}

function closeAll(){
  document.getElementById('sheet').classList.remove('open');
  document.getElementById('qrm').classList.remove('show');
  document.getElementById('backdrop').classList.remove('show');
  const gp=document.getElementById('gpx-panel'); if(gp) gp.classList.remove('open');
  const tq=document.getElementById('trk-qrm');
  if(tq){ tq.style.opacity='0'; tq.style.visibility='hidden'; tq.style.transform='translate(-50%,-50%) scale(.88)'; }
}

// ── FILTER ─────────────────────────────────────────────────────
function setFilter(f,el){
  curFilter=f;
  document.querySelectorAll('.chip').forEach(c=>c.classList.remove('on'));
  el.classList.add('on');
  LOCS.forEach(loc=>{
    const lm=MKR[loc.id].m;
    (f==='all'||loc.cat===f)?map.addLayer(lm):map.removeLayer(lm);
  });
  buildList();
}

function focusMarker(id){
  closeAll();
  const{m,loc}=MKR[id];
  map.flyTo([loc.lat,loc.lng],18,{animate:true,duration:1.2});
  setTimeout(()=>m.openPopup(),1250);
}
function fitAll(){
  const vis=LOCS.filter(l=>curFilter==='all'||l.cat===curFilter);
  if(!vis.length)return;
  map.flyToBounds(L.latLngBounds(vis.map(l=>[l.lat,l.lng])),{padding:[55,55],maxZoom:17,animate:true,duration:1.3});
}

// ── NAVIGATION ─────────────────────────────────────────────────
function navTo(lat,lng,name){
  const ua=navigator.userAgent||'';
  const isIOS=/iPad|iPhone|iPod/.test(ua)&&!window.MSStream;
  const isAndroid=/Android/i.test(ua);
  const gmapsUrl=`https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}&travelmode=bicycling`;
  if(isIOS){
    let opened=false;
    window.addEventListener('blur',()=>{opened=true},{once:true});
    window.location.href=`maps://maps.apple.com/?daddr=${lat},${lng}&dirflg=d`;
    setTimeout(()=>{ if(!opened) window.open(`https://maps.apple.com/?daddr=${lat},${lng}&dirflg=d`,'_blank'); },700);
  } else if(isAndroid){
    let opened=false;
    window.addEventListener('blur',()=>{opened=true},{once:true});
    window.location.href=`geo:${lat},${lng}?q=${lat},${lng}`;
    setTimeout(()=>{ if(!opened) window.open(gmapsUrl,'_blank'); },1000);
  } else {
    window.open(gmapsUrl,'_blank');
  }
}

// ── LOKALE QR-CODE GENERIERUNG ──────────────────────────────────
/**
 * Zeichnet QR-Code lokal auf Canvas (qrcode-generator, kein CDN nötig)
 * @param {HTMLCanvasElement} canvas
 * @param {string} data - zu kodierender Inhalt
 * @param {number} size - Canvas-Größe px
 * @param {string} fgColor - Vordergrundfarbe
 * @param {string} bgColor - Hintergrundfarbe
 */
function drawQR(canvas, data, size=160, fgColor='#0b0e14', bgColor='#ffffff'){
  if(!window.qrcode){ toast('❌ QR-Lib nicht geladen'); return false; }
  try{
    const qr=window.qrcode(0,'M');
    qr.addData(data);
    qr.make();
    const n=qr.getModuleCount();
    const cell=size/n;
    canvas.width=size; canvas.height=size;
    const ctx=canvas.getContext('2d');
    ctx.fillStyle=bgColor; ctx.fillRect(0,0,size,size);
    ctx.fillStyle=fgColor;
    for(let r=0;r<n;r++) for(let c=0;c<n;c++){
      if(qr.isDark(r,c)){
        const x=Math.floor(c*cell), y=Math.floor(r*cell);
        ctx.fillRect(x,y,Math.ceil((c+1)*cell)-x,Math.ceil((r+1)*cell)-y);
      }
    }
    return true;
  }catch(e){
    console.warn('QR error:',e);
    const ctx=canvas.getContext('2d');
    ctx.fillStyle='#fff'; ctx.fillRect(0,0,size,size);
    ctx.fillStyle='#ef4444'; ctx.font=`bold 11px sans-serif`;
    ctx.textAlign='center'; ctx.fillText('QR Fehler',size/2,size/2);
    return false;
  }
}

function downloadCanvas(canvas, filename){
  try{
    canvas.toBlob(blob=>{
      const u=URL.createObjectURL(blob);
      const a=document.createElement('a'); a.href=u; a.download=filename;
      document.body.appendChild(a); a.click(); document.body.removeChild(a);
      URL.revokeObjectURL(u); toast('⬇ QR-Bild gespeichert!');
    },'image/png');
  }catch(e){
    const a=document.createElement('a'); a.href=canvas.toDataURL('image/png'); a.download=filename; a.click();
    toast('⬇ QR-Bild gespeichert!');
  }
}

// ── QR FÜR MARKER/POIs ─────────────────────────────────────────
let curQrUrl='', curQrLocId='';

function openQR(id){
  const loc=LOCS.find(l=>l.id===id); if(!loc)return;
  curQrUrl=`https://www.google.com/maps/dir/?api=1&destination=${loc.lat},${loc.lng}&travelmode=bicycling`;
  curQrLocId=id;
  document.getElementById('qr-nm').textContent=loc.name;
  document.getElementById('qr-hint').textContent='QR scannen → startet Navigation in Google Maps';
  document.getElementById('qr-inp').value=curQrUrl;
  const canvas=document.getElementById('qr-canvas');
  drawQR(canvas, curQrUrl, 160, '#0b0e14', '#ffffff');
  closeAll();
  document.getElementById('qrm').classList.add('show');
  document.getElementById('backdrop').classList.add('show');
}

function copyQR(){
  if(!curQrUrl)return;
  if(navigator.clipboard){
    navigator.clipboard.writeText(curQrUrl).then(()=>toast('✅ Link kopiert!')).catch(()=>{legacyCopy(curQrUrl);toast('✅ Link kopiert!');});
  } else { legacyCopy(curQrUrl); toast('✅ Link kopiert!'); }
}

function downloadQR(){
  const canvas=document.getElementById('qr-canvas');
  if(!canvas)return;
  downloadCanvas(canvas, `GMTW_${curQrLocId||'punkt'}_Navigation_QR.png`);
}

function legacyCopy(t){
  const el=document.createElement('textarea');
  el.value=t; el.style.cssText='position:fixed;top:-9999px;left:-9999px;opacity:0';
  document.body.appendChild(el); el.focus(); el.select();
  try{document.execCommand('copy')}catch(e){}
  document.body.removeChild(el);
}

// ── LIGHT/DARK MODE ────────────────────────────────────────────
let isDark=true;
function toggleTheme(){
  isDark=!isDark;
  document.documentElement.setAttribute('data-theme', isDark?'dark':'light');
  document.getElementById('ti-moon').style.display=isDark?'':'none';
  document.getElementById('ti-sun').style.display=isDark?'none':'';
  document.querySelector('meta[name=theme-color]').content=isDark?'#0b0e14':'#f0f4f8';
  LS.set(LS.K.THEME, isDark?'dark':'light');
  toast(isDark?'🌙 Dunkel Modus':'☀️ Hell Modus');
}
function initTheme(){
  const saved=LS.get(LS.K.THEME,'dark');
  if(saved==='light'){
    isDark=false;
    document.documentElement.setAttribute('data-theme','light');
    document.querySelector('meta[name=theme-color]').content='#f0f4f8';
    document.getElementById('ti-moon').style.display='none';
    document.getElementById('ti-sun').style.display='';
  } else {
    document.documentElement.setAttribute('data-theme','dark');
  }
}

// ── GPS ────────────────────────────────────────────────────────
let userMkr=null, userAccCircle=null, gpsWatcher=null, gpsOn=false;
let _gpsAutoFollow = false; // Auto-follow mode (map centers on position)

// Central GPS position handler — called for every GPS update
function _onGpsPos(pos) {
  const {latitude:lat, longitude:lng, accuracy:acc, speed} = pos.coords;
  const fab = document.getElementById('gps-fab');

  // First fix
  if (!gpsOn) {
    gpsOn = true;
    fab.classList.remove('spin');
    fab.style.borderColor = 'var(--log)';
    fab.style.borderWidth = '2px';
    if (_gpsAutoFollow) map.flyTo([lat,lng],17,{animate:true,duration:1});
    toast(`✅ Standort (±${Math.round(acc)}m)`);
  }

  // Update user dot + accuracy circle
  const dotHtml = `<div style="position:relative;width:22px;height:22px;display:flex;align-items:center;justify-content:center">
    <div style="position:absolute;width:36px;height:36px;border-radius:50%;background:rgba(56,189,248,.15);border:1px solid rgba(56,189,248,.35);top:50%;left:50%;transform:translate(-50%,-50%)"></div>
    <div style="width:16px;height:16px;border-radius:50%;background:#38bdf8;border:3px solid #fff;box-shadow:0 2px 8px rgba(0,0,0,.5)"></div>
  </div>`;
  const dotIcon = L.divIcon({className:'',html:dotHtml,iconSize:[22,22],iconAnchor:[11,11]});
  if (userMkr) map.removeLayer(userMkr);
  userMkr = L.marker([lat,lng],{icon:dotIcon,zIndexOffset:1000})
    .addTo(map)
    .bindPopup(`<div class="p-top"><div class="p-name">Dein Standort</div><div class="p-crds">${lat.toFixed(5)}, ${lng.toFixed(5)}</div><div class="p-desc">Genauigkeit: ±${Math.round(acc)} m</div></div>`);

  // Accuracy circle (update or create)
  if (userAccCircle) userAccCircle.setLatLng([lat,lng]).setRadius(acc);
  else userAccCircle = L.circle([lat,lng],{radius:acc,color:'#38bdf8',fillColor:'#38bdf8',fillOpacity:.06,weight:1,opacity:.4}).addTo(map);

  // Auto-follow when navigation is active
  if (_gpsAutoFollow) map.setView([lat,lng], map.getZoom(), {animate:true, duration:.5});

  // Hook: Navigation & Race engines
  if (typeof _onNavGpsUpdate === 'function') _onNavGpsUpdate(lat, lng, acc);
  if (typeof _onRaceGpsUpdate === 'function') _onRaceGpsUpdate(lat, lng, acc, speed);
}

function _onGpsErr(err) {
  const fab = document.getElementById('gps-fab');
  fab.classList.remove('spin'); fab.style.borderColor=''; gpsOn=false;
  const msgs = {1:['Zugriff verweigert','Standortzugriff in Einstellungen erlauben.'],2:['Kein Signal','Ins Freie gehen oder WLAN aktivieren.'],3:['Zeitüberschreitung','GPS erneut versuchen.']};
  const [t,m] = msgs[err.code] || ['GPS Fehler',err.message];
  showGpsHint(t, m);
}

async function locateUser(){
  const fab=document.getElementById('gps-fab');
  if(!('geolocation'in navigator)){showGpsHint('GPS nicht verfügbar','Dein Browser unterstützt keine Geolocation-API.');return}
  if(navigator.permissions){
    try{const p=await navigator.permissions.query({name:'geolocation'});if(p.state==='denied'){showGpsHint('Zugriff verweigert','Erlaube den Standort in den Browser-/App-Einstellungen.');return}}catch(e){}
  }
  if(gpsOn){
    if(gpsWatcher!==null){navigator.geolocation.clearWatch(gpsWatcher);gpsWatcher=null}
    if(userMkr){map.removeLayer(userMkr);userMkr=null}
    if(userAccCircle){map.removeLayer(userAccCircle);userAccCircle=null}
    gpsOn=false; _gpsAutoFollow=false; fab.classList.remove('spin'); fab.style.borderColor='';
    toast('📍 GPS deaktiviert'); return;
  }
  _gpsAutoFollow = true;
  fab.classList.add('spin'); toast('📡 GPS wird aktiviert…');
  gpsWatcher = navigator.geolocation.watchPosition(_onGpsPos, _onGpsErr,
    {enableHighAccuracy:true, timeout:20000, maximumAge:3000});
}

// Ensure GPS is running (called by nav/race engine without user tap)
function ensureGpsActive() {
  return new Promise((resolve, reject) => {
    if (!('geolocation' in navigator)) { reject(new Error('Kein GPS')); return; }
    if (gpsOn) { resolve(); return; }
    const fab = document.getElementById('gps-fab');
    fab.classList.add('spin');
    gpsWatcher = navigator.geolocation.watchPosition(
      pos => { _onGpsPos(pos); resolve(); },
      err  => { _onGpsErr(err); reject(err); },
      {enableHighAccuracy:true, timeout:20000, maximumAge:3000}
    );
  });
}
function showGpsHint(t,m){document.getElementById('gpshint-t').textContent=t;document.getElementById('gpshint-m').textContent=m;document.getElementById('gpshint').classList.add('show');setTimeout(hideGpsHint,8000);}
function hideGpsHint(){document.getElementById('gpshint').classList.remove('show')}

// ── TOAST ──────────────────────────────────────────────────────
let toastT;
function toast(msg){const t=document.getElementById('toast');t.textContent=msg;t.classList.add('show');clearTimeout(toastT);toastT=setTimeout(()=>t.classList.remove('show'),2700);}

// ── AUTO-DOWNLOAD: GMTW 2026 TRACKS ───────────────────────────
// RAW-Links (kein /blob/, sonst liefert GitHub HTML statt GPX)
const AUTO_TRACKS = [
  { name:'GMTW 2026 Beginner',        cat:'beginner',
    url:'https://raw.githubusercontent.com/GMTW42/GMTW42.github.io/main/GMTW2026_Beginner.gpx' },
  { name:'GMTW 2026 Beginner/Mittel', cat:'mittel',
    url:'https://raw.githubusercontent.com/GMTW42/GMTW42.github.io/main/GMTW2026_Beginner_Intermediate.gpx' },
  { name:'GMTW 2026 Expert 1',        cat:'expert',
    url:'https://raw.githubusercontent.com/GMTW42/GMTW42.github.io/main/GMTW2026_Expert_1.gpx' },
  { name:'GMTW 2026 Expert 2',        cat:'expert',
    url:'https://raw.githubusercontent.com/GMTW42/GMTW42.github.io/main/GMTW2026_Expert_2.gpx' },
];

async function autoDownloadTracks() {
  let downloaded = 0;
  for (const def of AUTO_TRACKS) {
    // Skip if already loaded (check by sourceUrl or name)
    const alreadyLoaded = trackStore.tracks.some(
      t => t.sourceUrl === def.url || t.name === def.name
    );
    if (alreadyLoaded) continue;

    try {
      const resp = await fetch(def.url);
      if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
      const txt = await resp.text();
      const gpxStr = sanitizeGpx(txt);
      if (!gpxStr.startsWith('<')) throw new Error('Kein gültiges GPX');
      // silent=true: kein Toast/flyTo pro Track, kein Tab-Wechsel
      loadGpxXml(gpxStr, def.name, def.cat, null, def.url, true);
      downloaded++;
    } catch(e) {
      // Offline oder Netzwerkfehler — kein Crash, nur stille Protokollierung
      console.info(`Auto-Download übersprungen (${def.name}):`, e.message);
    }
  }
  if (downloaded > 0) toast(`⬇ ${downloaded} Strecke${downloaded!==1?'n':''} geladen`);
}

// ── DEEP LINK ──────────────────────────────────────────────────
window.addEventListener('load', async ()=>{
  initTheme();
  const params=new URLSearchParams(window.location.search);
  const locId=params.get('loc');
  if(locId&&MKR[locId]) setTimeout(()=>focusMarker(locId),700);
  // ?gpx=URL Parameter: Track direkt laden
  const gpxUrl=params.get('gpx');
  if(gpxUrl){
    const cat=params.get('cat')||'mittel';
    const name=decodeURIComponent(params.get('name')||gpxUrl.split('/').pop().replace('.gpx','')||'Track');
    toast('⏳ Lade GPX aus URL…');
    setTimeout(()=>createGpxLayer(useProxy?`https://corsproxy.io/?${encodeURIComponent(gpxUrl)}`:gpxUrl, cat, name),900);
  }
  // Gespeicherte Daten wiederherstellen (await: Auto-Download erst danach prüfen)
  restoreRecorder();
  await restoreTracks();
  // Fehlende Official-Tracks im Hintergrund laden (silent, offline-safe)
  autoDownloadTracks();
  // Run-Cache für sync renderTrackList befüllen
  _initRunCache();
});

// ── GPX SYSTEM ─────────────────────────────────────────────────
// ═══════════════════════════════════════════════════════════════
// ROOT CAUSE: leaflet-gpx nutzt XHR für URLs → auf iOS/Android
// liefern blob: URLs status=0 → 'loaded' Event feuert NIE.
//
// FIX: GPX-XML-String direkt an new L.GPX(string) übergeben.
// leaflet-gpx prüft: if(input.substr(0,1)==='<') → DOMParser.
// DOMParser hat KEINEN status-Check → 100% zuverlässig.
// ═══════════════════════════════════════════════════════════════

let useProxy = false;
function useCorsProxy() { useProxy=!useProxy; toast(useProxy?'🔀 CORS-Proxy aktiv':'🔀 Direktverbindung'); }

const trackStore = { tracks:[], _id:1 };
let gpxFilter = 'all';
let _cachedRuns = {}; // Sync-safe run cache — refreshed by _initRunCache() and after each save
let _activeDetailId = null; // Track ID whose detail panel is currently open

// GPX-String bereinigen: BOM, Whitespace, XML-Startpunkt finden
function sanitizeGpx(str) {
  if (!str) return '';
  // BOM entfernen (UTF-8: 0xFEFF, manchmal als 3-Byte-Sequenz)
  if (str.charCodeAt(0) === 0xFEFF) str = str.slice(1);
  str = str.trim();

  // HTML-Dokumente sofort abweisen — z.B. GitHub /blob/ Seiten
  const low = str.substring(0, 120).toLowerCase();
  if (low.startsWith('<!doctype html') || low.startsWith('<html') ||
      low.includes('<html ') || low.includes('<html>')) {
    return '';
  }

  // XML-Startpunkt finden wenn nötig
  if (!str.startsWith('<')) {
    const xmlIdx = str.indexOf('<?xml');
    const gpxIdx = str.indexOf('<gpx');
    const start = Math.min(
      xmlIdx >= 0 ? xmlIdx : Infinity,
      gpxIdx >= 0 ? gpxIdx : Infinity
    );
    if (isFinite(start)) str = str.slice(start);
    else return ''; // kein XML-Startpunkt gefunden
  }

  // Nochmal prüfen ob es GPX-Inhalte gibt
  if (!str.includes('<trk') && !str.includes('<rte') && !str.includes('<wpt') && !str.includes('<gpx')) {
    return '';
  }

  return str;
}

function openGpxPanel(tab='load') {
  closeAll();
  document.getElementById('gpx-panel').classList.add('open');
  document.getElementById('backdrop').classList.add('show');
  switchGpxTab(tab, document.querySelector(`.gpx-tab[data-tab="${tab}"]`));
  map.invalidateSize();
}
function closeGpxPanel() {
  document.getElementById('gpx-panel').classList.remove('open');
  document.getElementById('backdrop').classList.remove('show');
  map.invalidateSize();
}
function switchGpxTab(tab, btn) {
  document.querySelectorAll('.gpx-tab').forEach(t => t.classList.remove('on'));
  document.querySelectorAll('.gpx-content').forEach(c => c.classList.remove('on'));
  if (btn) btn.classList.add('on');
  else { const b = document.querySelector(`.gpx-tab[data-tab="${tab}"]`); if(b) b.classList.add('on'); }
  const el = document.getElementById(`gpx-tab-${tab}`);
  if (el) { el.classList.add('on'); if(tab==='tracks') renderTrackList(); }
}

// ── DATEI-UPLOAD ───────────────────────────────────────────────
function handleGpxFiles(input) {
  const files = Array.from(input.files);
  if (!files.length) return;
  const cat = document.getElementById('gpx-cat').value;
  let pending = files.length;
  // input.value erst nach ALLEN Lesevorgängen zurücksetzen
  const done = () => { if (--pending <= 0) input.value = ''; };

  files.forEach(file => {
    if (trackStore.tracks.length >= 50) { toast('⚠️ Max. 50 Tracks'); done(); return; }

    const reader = new FileReader();

    reader.onload = function(ev) {
      try {
        const gpxStr = sanitizeGpx(ev.target.result);

        if (!gpxStr.startsWith('<')) {
          toast('❌ ' + escHtml(file.name) + ': Kein XML-Inhalt'); done(); return;
        }
        if (!gpxStr.includes('trk') && !gpxStr.includes('rte') && !gpxStr.includes('wpt')) {
          toast('❌ ' + escHtml(file.name) + ': Keine Track-Daten'); done(); return;
        }

        const name = file.name.replace(/\.gpx$/i, '').replace(/[_-]+/g, ' ').trim() || 'Track';
        // DIREKT als XML-String laden — kein Blob, kein XHR!
        loadGpxXml(gpxStr, name, cat);
      } catch(err) {
        toast('❌ Fehler beim Lesen: ' + escHtml(file.name));
        console.error('GPX file read error:', err);
      }
      done();
    };

    reader.onerror = () => { toast('❌ Datei nicht lesbar: ' + escHtml(file.name)); done(); };
    reader.readAsText(file, 'UTF-8');
  });
}

// ── URL-LADEN ─────────────────────────────────────────────────
async function loadGpxFromUrl() {
  const inp = document.getElementById('gpx-url-inp');
  let url = inp.value.trim();
  if (!url) { toast('⚠️ URL eingeben'); return; }
  if (trackStore.tracks.length >= 50) { toast('⚠️ Max. 50 Tracks'); return; }

  // ── AUTO-KORREKTUREN ──────────────────────────────────────
  // GitHub: /blob/-URL → raw.githubusercontent.com
  if (url.includes('github.com') && url.includes('/blob/')) {
    url = url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
    toast('ℹ️ GitHub-URL → Raw-URL umgewandelt');
  }
  // Gist direkt: gist.github.com → raw (falls versehentlich)
  if (url.includes('gist.github.com') && !url.includes('/raw')) {
    url = url + '/raw';
  }

  const cat = document.getElementById('gpx-cat').value;
  // Trackname aus dem originalen URL-Pfad (vor der Umwandlung)
  const name = url.split('/').pop().split('?')[0]
    .replace(/\.gpx$/i,'').replace(/[_-]+/g,' ').trim() || 'Track';
  inp.value = '';
  toast('⏳ Lade ' + escHtml(name) + '…');

  // Fetch-Versuche: direkt → Proxy (außer Proxy ist schon aktiv)
  const fetchUrls = useProxy
    ? [`https://corsproxy.io/?${encodeURIComponent(url)}`]
    : [url, `https://corsproxy.io/?${encodeURIComponent(url)}`];

  let lastErr = '';
  for (let i = 0; i < fetchUrls.length; i++) {
    const fetchUrl = fetchUrls[i];
    const isProxy = fetchUrl.includes('corsproxy.io');
    try {
      const resp = await fetch(fetchUrl, { mode:'cors', credentials:'omit' });
      if (!resp.ok) throw new Error(`HTTP ${resp.status}: ${resp.statusText}`);

      const txt = await resp.text();
      const gpxStr = sanitizeGpx(txt);

      if (!gpxStr) {
        // sanitizeGpx hat leeren String zurückgegeben
        if (txt.toLowerCase().includes('<!doctype html') || txt.toLowerCase().includes('<html')) {
          throw new Error('Antwort ist eine HTML-Seite, keine GPX-Datei. Prüfe die URL (Raw-Link nötig?)');
        }
        throw new Error('Antwort enthält keine GPX-Trackdaten');
      }

      if (!gpxStr.startsWith('<')) {
        throw new Error('Kein gültiges XML: ' + gpxStr.substring(0, 40));
      }

      loadGpxXml(gpxStr, name, cat, null, url);
      return; // Erfolg

    } catch(err) {
      lastErr = err.message;
      console.warn(`GPX fetch [${isProxy?'proxy':'direkt'}] fehlgeschlagen:`, err.message);
      if (i < fetchUrls.length - 1) {
        toast('⚠️ Direkt gescheitert, versuche CORS-Proxy…');
        await new Promise(r => setTimeout(r, 400)); // kurze Pause
      }
    }
  }

  // Alle Versuche fehlgeschlagen
  const hint = lastErr.includes('HTML') ? ' (Raw-URL verwenden!)' :
               lastErr.includes('HTTP 4') ? ' (Datei nicht gefunden)' :
               lastErr.includes('HTTP 5') ? ' (Server-Fehler)' : '';
  toast('❌ GPX konnte nicht geladen werden' + hint);
  console.error('GPX URL load failed:', lastErr);
}

// ── KERN-FUNKTION: XML-String → Leaflet-Layer ─────────────────
// Übergibt den XML-String direkt an L.GPX.
// leaflet-gpx erkennt '<' als Präfix → DOMParser (kein XHR!).
function loadGpxXml(gpxStr, name, cat, existingId=null, sourceUrl=null, silent=false) {
  if (!gpxStr) {
    toast('❌ Kein GPX-Inhalt für: ' + escHtml(name));
    return null;
  }
  if (!gpxStr.startsWith('<')) {
    toast('❌ Kein XML für: ' + escHtml(name) + ' (beginnt mit: ' + gpxStr.substring(0,20) + ')');
    return null;
  }
  // HTML-Dokument abfangen (z.B. GitHub /blob/ Seite)
  const _gpxLow = gpxStr.substring(0, 60).toLowerCase();
  if (_gpxLow.startsWith('<!doctype html') || _gpxLow.includes('<html')) {
    toast('❌ ' + escHtml(name) + ': HTML-Seite statt GPX. Bitte Raw-URL verwenden.');
    return null;
  }

  const color = GPX_COLORS[cat] || '#27AE60';
  const id = existingId || ('trk-' + trackStore._id++);

  const layer = new L.GPX(gpxStr, {
    async: true,
    marker_options: {
      startIconUrl: null, endIconUrl: null, shadowUrl: null,
      wptIconUrls: { '': null }
    },
    polyline_options: {
      color, weight: 4.5, opacity: 0.9, lineCap: 'round', lineJoin: 'round'
    }
  });

  layer.on('loaded', function(e) {
    const gl = e.target;

    let dist = '?', dur = '—';
    try { dist = (gl.get_distance() / 1000).toFixed(2); } catch(ex) {}
    try {
      const ms = gl.get_total_time();
      if (ms) {
        const m = Math.round(ms / 60000);
        dur = m >= 60 ? `${Math.floor(m/60)}h ${m%60}m` : `${m}m`;
      }
    } catch(ex) {}

    const bounds = (() => {
      try { const b = gl.getBounds(); return (b && b.isValid && b.isValid()) ? b : null; }
      catch(ex) { return null; }
    })();

    const track = {
      id, name, cat, color,
      gpxLayer: gl, visible: true,
      sourceUrl: sourceUrl || null,
      gpxString: gpxStr,       // für localStorage & QR immer speichern
      bounds,
      stats: { dist, dur },
      elevData: extractElevData(gl)
    };

    trackStore.tracks.push(track);
    // Respect current filter: hide from map if category doesn't match
    // (track.visible stays true — this is a view-filter, not a user preference)
    if (gpxFilter !== 'all' && track.cat !== gpxFilter) {
      map.removeLayer(gl);
    }
    // Add start marker on map (independent from recorder)
    _addStartMarker(track);
    updateGpxBadge();
    renderTrackList();
    persistTracks();

    if (!silent) {
      toast(`✅ "${escHtml(name)}" · ${dist} km`);
      if (bounds) map.flyToBounds(bounds, { padding:[44,44], maxZoom:16, animate:true, duration:1.2 });
      switchGpxTab('tracks', null);
    }
  });

  layer.on('error', function(e) {
    const msg = (e && e.err) ? String(e.err).substring(0, 80) : 'Parse-Fehler';
    toast('❌ GPX: ' + msg);
    console.error('L.GPX error:', e, '\nGPX start:', gpxStr.substring(0, 300));
  });

  layer.addTo(map);
  return layer;
}

// Alias-Funktion für Abwärtskompatibilität
function loadGpxFromString(gpxStr, name, cat) {
  loadGpxXml(sanitizeGpx(gpxStr), name, cat);
}

// ── TRACK-VERWALTUNG ──────────────────────────────────────────
function toggleTrack(id) {
  const t = trackStore.tracks.find(t => t.id===id); if(!t) return;
  if (t.visible) {
    map.removeLayer(t.gpxLayer); t.visible=false;
  } else {
    t.visible=true;
    // Only add to map if the current category filter allows this track
    if (gpxFilter === 'all' || t.cat === gpxFilter) t.gpxLayer.addTo(map);
  }
  renderTrackList();
}

function removeTrack(id) {
  const idx = trackStore.tracks.findIndex(t => t.id===id); if(idx<0) return;
  _removeStartMarker(trackStore.tracks[idx]); // remove start marker first
  map.removeLayer(trackStore.tracks[idx].gpxLayer);
  trackStore.tracks.splice(idx, 1);
  updateGpxBadge();
  renderTrackList();
  persistTracks();
  document.getElementById('elev-panel').style.display = 'none';
  toast('🗑 Track entfernt');
}

function zoomTrack(id) {
  const t = trackStore.tracks.find(t => t.id===id); if(!t) return;
  try {
    const b = t.bounds || t.gpxLayer.getBounds();
    if (b && b.isValid && b.isValid())
      map.flyToBounds(b, { padding:[44,44], maxZoom:16, animate:true, duration:1 });
  } catch(e) { console.warn('zoomTrack error:', e); }
}

function filterTracks(cat, btn) {
  gpxFilter = cat;
  document.querySelectorAll('.cat-fbtn').forEach(b => b.classList.remove('on'));
  if (btn) btn.classList.add('on');
  document.getElementById('elev-panel').style.display = 'none';
  // Sync map layers: add/remove based on category match AND user visibility preference
  trackStore.tracks.forEach(t => {
    const shouldShow = (cat === 'all' || t.cat === cat) && t.visible;
    if (shouldShow) { if (!map.hasLayer(t.gpxLayer)) t.gpxLayer.addTo(map); }
    else            { if (map.hasLayer(t.gpxLayer))  map.removeLayer(t.gpxLayer); }
  });
  renderTrackList();
}

function renderTrackList() {
  const cont = document.getElementById('trk-list'); if(!cont) return;
  const list = gpxFilter==='all'
    ? trackStore.tracks
    : trackStore.tracks.filter(t => t.cat===gpxFilter);

  if (!list.length) {
    cont.innerHTML = `<div style="padding:20px 16px;text-align:center;color:var(--td);`
      + `font-family:var(--fh);font-size:13px;font-weight:700;text-transform:uppercase;`
      + `letter-spacing:1px">${trackStore.tracks.length
        ? 'Keine Tracks in dieser Kategorie' : 'Noch keine Tracks geladen'}</div>`;
    document.getElementById('gpx-track-cnt').textContent =
      trackStore.tracks.length + ' Track' + (trackStore.tracks.length!==1?'s':'');
    return;
  }

  cont.innerHTML = '';
  list.forEach(t => {
    const runCount = (_cachedRuns[t.id]||[]).length;
    const bestRun  = (_cachedRuns[t.id]||[]).slice().sort((a,b)=>a.totalMs-b.totalMs)[0];
    const isRacing = typeof RACE !== 'undefined' && RACE.trackId===t.id && RACE.state!=='idle' && RACE.state!=='finished';
    const row = document.createElement('div');
    row.className = 'trk-row'; row.setAttribute('role','listitem');
    const hasElev = !!(t.elevData && t.elevData.length > 1);
    row.innerHTML =
      `<div class="trk-dot" style="background:${t.color}"></div>`
      + `<div class="trk-inf" style="cursor:pointer" onclick="openTrackDetail('${t.id}')">`
      +   `<div class="trk-nm">${escHtml(t.name)}${isRacing?'<span style="color:var(--exp);font-size:10px;margin-left:6px">● LIVE</span>':''}</div>`
      +   `<div class="trk-meta">${escHtml(t.cat.charAt(0).toUpperCase()+t.cat.slice(1))}`
      +     ` · ${t.stats.dist} km · ${t.stats.dur}${hasElev?' · 📈':''}${runCount>0?` · <span style="color:var(--ac)">${runCount}×</span>${bestRun?' '+_fmtTime(bestRun.totalMs):''}`:''}</div>`
      + `</div>`
      + `<div class="trk-btns">`
      +   `<button class="trk-btn${t.visible?' on':''}" aria-label="${t.visible?'Ausblenden':'Einblenden'}" onclick="toggleTrack('${t.id}')">`
      +   (t.visible
          ? '<svg width="14" height="14" viewBox="0 0 14 14" fill="none"><path d="M1 7C1 7 3 3 7 3s6 4 6 4-2 4-6 4S1 7 1 7Z" stroke="currentColor" stroke-width="1.4"/><circle cx="7" cy="7" r="1.8" fill="currentColor"/></svg>'
          : '<svg width="14" height="14" viewBox="0 0 14 14" fill="none"><path d="M1 7C1 7 3 3 7 3s6 4 6 4-2 4-6 4S1 7 1 7Z" stroke="currentColor" stroke-width="1.4" opacity=".3"/><path d="M2 2L12 12" stroke="currentColor" stroke-width="1.4" stroke-linecap="round"/></svg>')
      +   `</button>`
      +   `<button class="trk-btn" style="color:var(--ac)" aria-label="QR/GPX" onclick="openTrackQR('${t.id}')">`
      +     `<svg width="13" height="13" viewBox="0 0 14 14" fill="none"><rect x="1" y="1" width="4" height="4" rx=".5" stroke="currentColor" stroke-width="1.3"/><rect x="9" y="1" width="4" height="4" rx=".5" stroke="currentColor" stroke-width="1.3"/><rect x="1" y="9" width="4" height="4" rx=".5" stroke="currentColor" stroke-width="1.3"/><path d="M9 9h1v1M11 9h1M9 11v1M11 12h1M12 11v-1" stroke="currentColor" stroke-width="1.3" stroke-linecap="round"/></svg>`
      +   `</button>`
      +   `<button class="trk-btn" style="color:#ef4444" aria-label="Löschen" onclick="removeTrack('${t.id}')">`
      +     `<svg width="14" height="14" viewBox="0 0 14 14" fill="none"><path d="M2 4H12M5 4V2H9V4M11 4L10 12H4L3 4" stroke="currentColor" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round"/></svg>`
      +   `</button>`
      + `</div>`;
    cont.appendChild(row);

    // Inline detail panel placeholder — filled asynchronously by _fillDetailSlot()
    if (_activeDetailId === t.id) {
      const slot = document.createElement('div');
      slot.id = 'trk-detail-slot';
      slot.className = 'trk-detail-loading';
      slot.textContent = 'Lädt…';
      cont.appendChild(slot);
    }
  });

  document.getElementById('gpx-track-cnt').textContent =
    trackStore.tracks.length + ' Track' + (trackStore.tracks.length!==1?'s':'');
}

function updateGpxBadge() {
  const b = document.getElementById('gpx-cnt');
  const n = trackStore.tracks.length;
  b.textContent = n; b.style.display = n ? '' : 'none';
}

// ── DRAG & DROP ───────────────────────────────────────────────
const dropOverlay = document.getElementById('gpx-drop-overlay');
document.addEventListener('dragover', e => {
  if ([...e.dataTransfer.items].some(i => i.kind==='file')) {
    e.preventDefault(); dropOverlay.style.display = 'flex';
  }
});
document.addEventListener('dragleave', e => {
  if (!e.relatedTarget || !document.contains(e.relatedTarget))
    dropOverlay.style.display = 'none';
});
document.addEventListener('drop', e => {
  e.preventDefault(); dropOverlay.style.display = 'none';
  const cat = document.getElementById('gpx-cat').value;
  [...e.dataTransfer.files]
    .filter(f => f.name.toLowerCase().endsWith('.gpx') || f.type.includes('gpx'))
    .forEach(file => {
      const reader = new FileReader();
      reader.onload = ev => {
        const gpxStr = sanitizeGpx(ev.target.result);
        if (gpxStr.startsWith('<'))
          loadGpxXml(gpxStr, file.name.replace(/\.gpx$/i,''), cat);
        else
          toast('❌ ' + escHtml(file.name) + ': Kein XML');
      };
      reader.readAsText(file, 'UTF-8');
    });
});

// ── INDEXEDDB: TRACKS (via localforage — kein Quota-Limit) ────
async function persistTracks() {
  try {
    const rows = trackStore.tracks.map(t => ({
      id:        t.id,
      name:      t.name,
      cat:       t.cat,
      color:     t.color,
      visible:   t.visible,
      stats:     t.stats,
      gpxString: t.gpxString || null,
      sourceUrl: t.sourceUrl || null
    }));
    await localforage.setItem(LS.K.TRACKS, rows);
  } catch(e) {
    console.warn('IndexedDB persistTracks error:', e);
  }
}

async function restoreTracks() {
  let saved;
  try {
    saved = await localforage.getItem(LS.K.TRACKS);
  } catch(e) {
    console.warn('IndexedDB restoreTracks error, LS-Fallback:', e);
    saved = LS.get(LS.K.TRACKS, []);
  }
  if (!saved || !saved.length) return;

  let restored = 0, skipped = 0;
  for (const t of saved) {
    if (trackStore.tracks.length >= 50) break;
    if (!t.gpxString) { skipped++; continue; }

    const gpxStr = sanitizeGpx(t.gpxString);
    if (!gpxStr.startsWith('<')) { skipped++; continue; }

    // Warten auf loaded/error Event mit Timeout-Sicherheitsnetz
    const ok = await new Promise(resolve => {
      const timeout = setTimeout(() => { console.warn('GPX restore timeout:', t.name); resolve(false); }, 10000);

      const layer = new L.GPX(gpxStr, {
        async: true,
        marker_options: { startIconUrl:null, endIconUrl:null, shadowUrl:null, wptIconUrls:{'':null} },
        polyline_options: { color:t.color||'#27AE60', weight:4.5, opacity:0.9, lineCap:'round', lineJoin:'round' }
      });

      layer.on('loaded', function(e) {
        clearTimeout(timeout);
        const gl = e.target;
        let dist=t.stats?.dist||'?', dur=t.stats?.dur||'—';
        try { dist=(gl.get_distance()/1000).toFixed(2); } catch(ex) {}
        const bounds = (() => {
          try { const b=gl.getBounds(); return (b&&b.isValid&&b.isValid())?b:null; } catch(ex){ return null; }
        })();
        const track = {
          id:t.id, name:t.name, cat:t.cat, color:t.color,
          gpxLayer:gl, visible:t.visible!==false,
          sourceUrl:t.sourceUrl||null, gpxString:gpxStr,
          bounds, stats:{ dist, dur }, elevData:extractElevData(gl)
        };
        trackStore.tracks.push(track);
        // Layer wurde unten via layer.addTo(map) hinzugefügt (triggers 'loaded').
        // Jetzt Sichtbarkeit anpassen: user-Präferenz UND aktiver Filter
        const shouldBeOnMap = track.visible && (gpxFilter === 'all' || track.cat === gpxFilter);
        if (!shouldBeOnMap) map.removeLayer(gl);
        // Start marker auf Karte (unabhängig vom Recorder)
        _addStartMarker(track);
        resolve(true);
      });

      layer.on('error', function(e) {
        clearTimeout(timeout);
        console.warn('GPX restore error for', t.name, e);
        resolve(false);
      });

      // WICHTIG: Layer zur Karte hinzufügen, damit 'loaded' feuert
      layer.addTo(map);
    });

    if (ok) restored++; else skipped++;
  }

  updateGpxBadge();
  renderTrackList();
  if (restored > 0) toast(`💾 ${restored} Track${restored!==1?'s':''} wiederhergestellt`);
  if (skipped > 0)  console.info(`${skipped} Tracks übersprungen (kein GPX gespeichert)`);
}

// ── ELEVATION PROFIL ───────────────────────────────────────────
function extractElevData(gpxLayer){
  try{
    const elevs=[];
    gpxLayer.eachLayer(layer=>{
      if(layer.getLatLngs){
        const lls=layer.getLatLngs();
        const flat=Array.isArray(lls[0])?lls.flat():lls;
        flat.forEach(ll=>{if(ll.alt!=null&&!isNaN(ll.alt))elevs.push(ll.alt);});
      }
    });
    return elevs.length>=2?elevs:null;
  }catch(e){return null;}
}

function showElevProfile(id){
  const t=trackStore.tracks.find(t=>t.id===id);
  const panel=document.getElementById('elev-panel');
  if(!t||!t.elevData||t.elevData.length<2){panel.style.display='none';return;}
  panel.style.display='block';
  const canvas=document.getElementById('elev-canvas');
  const W=Math.max(200,panel.clientWidth-24),H=80;
  canvas.width=W;canvas.height=H;
  const data=t.elevData;
  const minE=Math.min(...data),maxE=Math.max(...data);
  const range=maxE-minE||1;
  let gain=0;
  for(let i=1;i<data.length;i++){const d=data[i]-data[i-1];if(d>0)gain+=d;}
  const ctx=canvas.getContext('2d');
  // Hintergrund
  ctx.fillStyle=isDark?'rgba(37,46,66,.8)':'rgba(220,226,236,.8)';
  ctx.fillRect(0,0,W,H);
  // Füll-Gradient
  const grad=ctx.createLinearGradient(0,0,0,H);
  grad.addColorStop(0,t.color+'cc');
  grad.addColorStop(1,t.color+'22');
  ctx.beginPath();
  data.forEach((e,i)=>{
    const x=(i/(data.length-1))*W;
    const y=H-((e-minE)/range)*(H-10)-5;
    i===0?ctx.moveTo(x,H):void 0;
    ctx.lineTo(x,y);
  });
  ctx.lineTo(W,H);ctx.lineTo(0,H);ctx.closePath();
  ctx.fillStyle=grad;ctx.fill();
  // Linie
  ctx.beginPath();ctx.strokeStyle=t.color;ctx.lineWidth=2.5;ctx.lineJoin='round';
  data.forEach((e,i)=>{
    const x=(i/(data.length-1))*W;
    const y=H-((e-minE)/range)*(H-10)-5;
    i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
  });
  ctx.stroke();
  document.getElementById('elev-min').textContent=Math.round(minE);
  document.getElementById('elev-max').textContent=Math.round(maxE);
  document.getElementById('elev-gain').textContent=Math.round(gain);
  document.getElementById('elev-dist').textContent=t.stats.dist;
}

// ── TRACK QR-CODE ──────────────────────────────────────────────
let curTrkQrId=null;

function openTrackQR(trackId){
  const t=trackStore.tracks.find(t=>t.id===trackId);if(!t){toast('❌ Track nicht gefunden');return;}
  curTrkQrId=trackId;
  document.getElementById('trk-qr-nm').textContent=t.name;

  // GPX-Inhalt gewinnen
  extractGpxFromLayer(t).then(gpxStr=>{
    const gpxBytes=new Blob([gpxStr]).size;
    const catLabel=t.cat.charAt(0).toUpperCase()+t.cat.slice(1);
    document.getElementById('trk-qr-info').innerHTML=`<strong>${escHtml(t.name)}</strong><br>${escHtml(catLabel)} · ${t.stats.dist} km · ${Math.round(gpxBytes/1024)} KB`;
    
    // QR-Strategie: URL > Data-URI (klein) > Google Maps Start/Ziel
    let qrData,hintText;
    if(t.sourceUrl&&!t.sourceUrl.startsWith('blob:')){
      qrData=t.sourceUrl;
      hintText='QR scannen → GPX-URL öffnen';
    } else if(gpxBytes<=2800){
      const b64=btoa(unescape(encodeURIComponent(gpxStr)));
      qrData=`data:application/gpx+xml;base64,${b64}`;
      hintText='QR scannen → GPX direkt laden';
    } else {
      const pts=extractWaypoints(t);
      qrData=`https://www.google.com/maps/dir/?api=1&origin=${pts.start}&destination=${pts.end}&travelmode=bicycling`;
      hintText='QR = Start/Ziel in Google Maps (GPX zu groß)';
      document.getElementById('trk-qr-info').innerHTML+=`<br><span style="color:var(--mit);font-size:10px">⚠ GPX ${Math.round(gpxBytes/1024)} KB – zeigt Start/Ziel</span>`;
    }

    document.getElementById('trk-qr-hint').textContent=hintText;
    // QR lokal zeichnen
    const canvas=document.getElementById('trk-qr-canvas');
    drawQR(canvas,qrData,164,'#0b0e14','#ffffff');
    // GPX für Download speichern
    document.getElementById('trk-qr-dl-btn').dataset.gpx=gpxStr;
    document.getElementById('trk-qr-dl-btn').dataset.name=t.name;

    closeAll();
    const m=document.getElementById('trk-qrm');
    m.style.opacity='0';m.style.visibility='visible';m.style.transform='translate(-50%,-50%) scale(.88)';
    requestAnimationFrame(()=>{
      m.style.transition='all .25s cubic-bezier(.32,.72,0,1)';
      m.style.opacity='1';m.style.transform='translate(-50%,-50%) scale(1)';
    });
    document.getElementById('backdrop').classList.add('show');
  });
}

async function extractGpxFromLayer(track){
  // Wenn Original-GPX-String gespeichert: direkt verwenden
  if(track.gpxString) return track.gpxString;
  // Sonst aus Layer-Geometrie rekonstruieren
  const lines=[];
  track.gpxLayer.eachLayer(layer=>{
    if(layer.getLatLngs){try{const c=layer.getLatLngs();if(c&&c.length)lines.push(Array.isArray(c[0])?c.flat():c);}catch(e){}}
  });
  const allPts=lines.flat();
  if(!allPts.length) return buildSimpleGpx(track.name,[]);
  const pts=allPts.map(ll=>`    <trkpt lat="${ll.lat.toFixed(7)}" lon="${ll.lng.toFixed(7)}">${ll.alt!=null?`\n      <ele>${ll.alt.toFixed(1)}</ele>`:''}\n    </trkpt>`).join('\n');
  return `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="GMTW Trail Map" xmlns="http://www.topografix.com/GPX/1/1">
  <metadata><n>${escXml(track.name)}</n></metadata>
  <trk><n>${escXml(track.name)}</n><desc>Kategorie: ${escXml(track.cat)} · ${track.stats.dist} km</desc>
    <trkseg>\n${pts}\n    </trkseg></trk>
</gpx>`;
}

function buildSimpleGpx(name){return `<?xml version="1.0" encoding="UTF-8"?><gpx version="1.1" creator="GMTW Trail Map"><trk><n>${escXml(name)}</n></trk></gpx>`;}
function extractWaypoints(track){
  try{const b=track.gpxLayer.getBounds();return{start:`${b.getSouthWest().lat.toFixed(5)},${b.getSouthWest().lng.toFixed(5)}`,end:`${b.getNorthEast().lat.toFixed(5)},${b.getNorthEast().lng.toFixed(5)}`};}
  catch(e){return{start:'0,0',end:'0,0'};}
}

function trkQrDownloadGpx(){
  const btn=document.getElementById('trk-qr-dl-btn');
  const gpxStr=btn.dataset.gpx,name=btn.dataset.name||'GMTW_Track';
  if(!gpxStr){toast('❌ Kein GPX verfügbar');return;}
  dlFile(name+'.gpx',gpxStr,'application/gpx+xml');
  toast('⬇ GPX gespeichert!');
}
function trkQrDownloadImg(){
  const canvas=document.getElementById('trk-qr-canvas');
  const t=trackStore.tracks.find(t=>t.id===curTrkQrId);
  const name=(t?t.name:'GMTW_Track').replace(/[^a-zA-Z0-9_-]/g,'_');
  downloadCanvas(canvas,name+'_QR.png');
}
function trkQrCopyUrl(){
  const t=trackStore.tracks.find(t=>t.id===curTrkQrId);
  const url=(t&&t.sourceUrl)?t.sourceUrl:window.location.href;
  if(navigator.clipboard) navigator.clipboard.writeText(url).then(()=>toast('📋 Link kopiert!'));
  else{legacyCopy(url);toast('📋 Link kopiert!');}
}

// ── STRECKEN-AUFNAHME ──────────────────────────────────────────
const recorder={
  isRecording:false,isPaused:false,
  points:[],watchId:null,
  elapsed:0,_segStart:null,
  _timerInt:null,_lastPos:null,_lastTime:null,
  totalDist:0,previewLine:null,MIN_SPEED:0.5
};

function haversine(lat1,lng1,lat2,lng2){
  const R=6371000,r=Math.PI/180;
  const dLat=(lat2-lat1)*r,dLng=(lng2-lng1)*r;
  const a=Math.sin(dLat/2)**2+Math.cos(lat1*r)*Math.cos(lat2*r)*Math.sin(dLng/2)**2;
  return R*2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));
}

function recStart(){
  if(!('geolocation'in navigator)){showGpsHint('GPS nicht verfügbar','Geolocation wird für die Aufnahme benötigt.');return;}
  recorder.isRecording=true;recorder.isPaused=false;
  recorder.points=[];recorder.elapsed=0;recorder.totalDist=0;
  recorder._lastPos=null;recorder._lastTime=null;recorder._segStart=Date.now();
  recUpdateUI();
  toast('🔴 Aufnahme läuft…');
  document.getElementById('rec-bar').classList.add('show');
  if(recorder.previewLine){map.removeLayer(recorder.previewLine);recorder.previewLine=null;}
  recorder.previewLine=L.polyline([],{color:'#ef4444',weight:3,opacity:.85,dashArray:'6 4'}).addTo(map);
  recorder.watchId=navigator.geolocation.watchPosition(
    pos=>recOnPosition(pos),
    err=>{toast('❌ GPS-Fehler bei Aufnahme');recStop();},
    {enableHighAccuracy:true,timeout:15000,maximumAge:1000}
  );
  recorder._timerInt=setInterval(recTickDisplay,1000);
}

function recOnPosition(pos){
  if(!recorder.isRecording||recorder.isPaused)return;
  const{latitude:lat,longitude:lng,altitude:ele,speed,accuracy}=pos.coords;
  if(accuracy>50)return; // Schlechte Genauigkeit ignorieren
  const pt={lat,lng,ele:ele||0,time:new Date(pos.timestamp).toISOString(),speed:speed||0};
  if(recorder._lastPos){
    const dist=haversine(recorder._lastPos.lat,recorder._lastPos.lng,lat,lng);
    const dt=(pos.timestamp-recorder._lastTime)/1000;
    const spd=dt>0?dist/dt:0;
    const moving=(speed!==null&&speed>recorder.MIN_SPEED)||(spd>recorder.MIN_SPEED);
    if(moving)recorder.totalDist+=dist;
  }
  recorder._lastPos={lat,lng};recorder._lastTime=pos.timestamp;
  recorder.points.push(pt);
  recorder.previewLine.addLatLng([lat,lng]);
  document.getElementById('rec-pts').textContent=recorder.points.length;
  document.getElementById('rec-dist').textContent=(recorder.totalDist/1000).toFixed(2);
}

function recPause(){
  if(!recorder.isRecording)return;
  recorder.isPaused=!recorder.isPaused;
  if(recorder.isPaused){
    if(recorder._segStart!==null){recorder.elapsed+=(Date.now()-recorder._segStart);recorder._segStart=null;}
  } else {
    recorder._segStart=Date.now();
  }
  document.getElementById('rec-pause-btn').textContent=recorder.isPaused?'Weiter':'Pause';
  document.getElementById('rec-status-txt').textContent=recorder.isPaused?'Pausiert':'Aufnahme läuft';
  document.getElementById('rec-status-txt').style.color=recorder.isPaused?'var(--mit)':'#ef4444';
  toast(recorder.isPaused?'⏸ Pause':'▶ Aufnahme weiter');
}

function recStop(){
  if(recorder._segStart!==null){recorder.elapsed+=(Date.now()-recorder._segStart);recorder._segStart=null;}
  recorder.isRecording=false;recorder.isPaused=false;
  if(recorder.watchId!==null){navigator.geolocation.clearWatch(recorder.watchId);recorder.watchId=null;}
  clearInterval(recorder._timerInt);recorder._timerInt=null;
  document.getElementById('rec-bar').classList.remove('show');
  document.getElementById('rec-status-txt').textContent=`Beendet · ${recorder.points.length} Punkte`;
  document.getElementById('rec-status-txt').style.color='var(--ac)';
  document.getElementById('rec-start-btn').style.display='';
  document.getElementById('rec-pause-btn').style.display='none';
  document.getElementById('rec-stop-btn').style.display='none';
  if(!recorder.points.length){toast('⚠️ Keine GPS-Punkte aufgezeichnet');recReset();return;}
  document.getElementById('rec-save-section').style.display='';
  LS.del(LS.K.REC); // Autosave löschen
  toast(`✅ Aufnahme beendet · ${recorder.points.length} Punkte`);
}

function recReset(){
  if(recorder.watchId!==null){navigator.geolocation.clearWatch(recorder.watchId);recorder.watchId=null;}
  clearInterval(recorder._timerInt);recorder._timerInt=null;
  if(recorder.previewLine){map.removeLayer(recorder.previewLine);recorder.previewLine=null;}
  recorder.isRecording=false;recorder.isPaused=false;
  recorder.points=[];recorder.elapsed=0;recorder.totalDist=0;recorder._segStart=null;recorder._lastPos=null;
  document.getElementById('rec-bar').classList.remove('show');
  document.getElementById('rec-save-section').style.display='none';
  document.getElementById('rec-name-inp').value='';
  document.getElementById('rec-timer').textContent='00:00:00';
  document.getElementById('rec-dist').textContent='0.0';
  document.getElementById('rec-pts').textContent='0';
  document.getElementById('rec-speed').textContent='0.0';
  recUpdateUI();
  document.getElementById('rec-status-txt').textContent='Bereit';
  document.getElementById('rec-status-txt').style.color='var(--tm)';
  LS.del(LS.K.REC);
  toast('🗑 Aufnahme verworfen');
}

function recUpdateUI(){
  const s=recorder.isRecording;
  document.getElementById('rec-start-btn').style.display=s?'none':'';
  document.getElementById('rec-pause-btn').style.display=s?'':'none';
  document.getElementById('rec-stop-btn').style.display=s?'':'none';
  document.getElementById('rec-status-txt').textContent=s?'Aufnahme läuft':'Bereit';
  document.getElementById('rec-status-txt').style.color=s?'#ef4444':'var(--tm)';
}

function recTickDisplay(){
  let display=recorder.elapsed;
  if(recorder.isRecording&&!recorder.isPaused&&recorder._segStart!==null)
    display+=(Date.now()-recorder._segStart);
  const totalSec=Math.floor(display/1000);
  const hh=Math.floor(totalSec/3600),mm=Math.floor((totalSec%3600)/60),ss=totalSec%60;
  const str=`${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}`;
  document.getElementById('rec-timer').textContent=str;
  document.getElementById('rec-bar-txt').textContent=str;
  if(recorder.points.length>0){
    const last=recorder.points[recorder.points.length-1];
    document.getElementById('rec-speed').textContent=((last.speed||0)*3.6).toFixed(1);
  }
}

// ── AUFNAHME SPEICHERN ─────────────────────────────────────────
function recBuildGpxString(name){
  const pts=recorder.points.map(p=>`    <trkpt lat="${p.lat.toFixed(7)}" lon="${p.lng.toFixed(7)}">\n      <ele>${(p.ele||0).toFixed(1)}</ele>\n      <time>${p.time}</time>\n    </trkpt>`).join('\n');
  return `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="GMTW Trail Map" xmlns="http://www.topografix.com/GPX/1/1">
  <metadata><n>${escXml(name)}</n><time>${new Date().toISOString()}</time></metadata>
  <trk><n>${escXml(name)}</n>
    <desc>Aufgezeichnet mit GMTW Trail Map · ${(recorder.totalDist/1000).toFixed(2)} km</desc>
    <trkseg>\n${pts}\n    </trkseg>
  </trk>
</gpx>`;
}

function recAddToMap(){
  if(!recorder.points.length){toast('⚠️ Keine Punkte aufgezeichnet');return;}
  const name=document.getElementById('rec-name-inp').value.trim()||'GMTW Aufnahme';
  const cat=document.getElementById('rec-save-cat').value;
  const gpxStr=recBuildGpxString(name);
  loadGpxFromString(gpxStr,name,cat);
  // Preview-Linie entfernen (wird durch GPX-Layer ersetzt)
  if(recorder.previewLine){map.removeLayer(recorder.previewLine);recorder.previewLine=null;}
  // Recorder zurücksetzen
  recorder.points=[];recorder.elapsed=0;recorder.totalDist=0;recorder._segStart=null;
  document.getElementById('rec-save-section').style.display='none';
  document.getElementById('rec-name-inp').value='';
  document.getElementById('rec-timer').textContent='00:00:00';
  document.getElementById('rec-dist').textContent='0.0';
  document.getElementById('rec-pts').textContent='0';
  recUpdateUI();
  document.getElementById('rec-status-txt').textContent='Bereit';
  document.getElementById('rec-status-txt').style.color='var(--tm)';
  LS.del(LS.K.REC);
  toast(`✅ "${escHtml(name)}" zur Karte hinzugefügt!`);
  setTimeout(()=>switchGpxTab('tracks',document.querySelector('.gpx-tab[data-tab="tracks"]')),400);
}

function recExportGpx(){
  if(!recorder.points.length){toast('⚠️ Keine Punkte zum Speichern');return;}
  const name=document.getElementById('rec-name-inp').value.trim()||'GMTW_Track';
  dlFile(name+'.gpx',recBuildGpxString(name),'application/gpx+xml');
  toast('⬇ GPX gespeichert!');
}

function recExportJson(){
  if(!recorder.points.length){toast('⚠️ Keine Punkte zum Speichern');return;}
  const name=document.getElementById('rec-name-inp').value.trim()||'GMTW_Track';
  dlFile(name+'.json',JSON.stringify({name,creator:'GMTW Trail Map',created:new Date().toISOString(),stats:{points:recorder.points.length,distanceKm:(recorder.totalDist/1000).toFixed(3),elapsedMs:recorder.elapsed},points:recorder.points},null,2),'application/json');
  toast('⬇ JSON gespeichert!');
}

function dlFile(filename,content,mime){
  const blob=new Blob([content],{type:mime});
  const url=URL.createObjectURL(blob);
  const a=document.createElement('a');a.href=url;a.download=filename;
  document.body.appendChild(a);a.click();document.body.removeChild(a);URL.revokeObjectURL(url);
}

// ── LOKALSTORAGE: RECORDER PERSISTENZ ─────────────────────────
function persistRecorder(){
  if(recorder.points.length>0){
    LS.set(LS.K.REC,{points:recorder.points,totalDist:recorder.totalDist,elapsed:recorder.elapsed,savedAt:Date.now()});
  }
}

function restoreRecorder(){
  const saved=LS.get(LS.K.REC);
  if(!saved||!saved.points||!saved.points.length)return;
  const ageMins=Math.round((Date.now()-saved.savedAt)/60000);
  const ageTxt=ageMins<60?`${ageMins} Min`:`${Math.round(ageMins/60)} Std`;
  setTimeout(()=>{
    if(confirm(`📍 Unterbrochene Aufnahme gefunden!\n${saved.points.length} Punkte · ${(saved.totalDist/1000).toFixed(2)} km · vor ${ageTxt}\n\nWiederherstellen?`)){
      recorder.points=saved.points;
      recorder.totalDist=saved.totalDist;
      recorder.elapsed=saved.elapsed;
      recorder._lastPos=saved.points.length>0?{lat:saved.points[saved.points.length-1].lat,lng:saved.points[saved.points.length-1].lng}:null;
      if(recorder.previewLine)map.removeLayer(recorder.previewLine);
      recorder.previewLine=L.polyline(saved.points.map(p=>[p.lat,p.lng]),{color:'#ef4444',weight:3,opacity:.85,dashArray:'6 4'}).addTo(map);
      document.getElementById('rec-pts').textContent=saved.points.length;
      document.getElementById('rec-dist').textContent=(saved.totalDist/1000).toFixed(2);
      document.getElementById('rec-save-section').style.display='';
      document.getElementById('rec-status-txt').textContent=`Wiederhergestellt · ${saved.points.length} Punkte`;
      document.getElementById('rec-status-txt').style.color='var(--ac)';
      toast(`✅ ${saved.points.length} Punkte wiederhergestellt`);
      openGpxPanel('rec');
    } else {
      LS.del(LS.K.REC);
    }
  },1800);
}

// ── BEFOREUNLOAD SAFETY NET ────────────────────────────────────
window.addEventListener('beforeunload',e=>{
  if(recorder.isRecording&&recorder.points.length>0){
    persistRecorder();
    e.preventDefault();
    e.returnValue=`Aufnahme läuft! ${recorder.points.length} GPS-Punkte werden gespeichert.`;
    return e.returnValue;
  }
  if(!recorder.isRecording&&recorder.points.length>0) persistRecorder();
});
// Autosave alle 15 Sekunden
setInterval(()=>{if(recorder.isRecording&&recorder.points.length>0)persistRecorder();},15000);

// leaflet-gpx ist inline eingebettet — kein Fallback nötig

// ══════════════════════════════════════════════════════════════
// ── START MARKERS ─────────────────────────────────────────────
// Sichtbarer Startpunkt-Marker jedes Tracks — Klick öffnet Detail-Panel
// Vollständig unabhängig vom GPX-Recorder!
// ══════════════════════════════════════════════════════════════

function _addStartMarker(track) {
  try {
    const pts = _getGpxPoints(track.gpxLayer);
    if (!pts.length) return;
    const sp = pts[0];
    // Colored flag pin shaped like map pin (pointing to exact start)
    const html = `<div class="start-pin" style="background:${track.color}" title="${esc(track.name)}"><span class="start-pin-flag">🚩</span></div>`;
    const icon = L.divIcon({className:'', html, iconSize:[26,32], iconAnchor:[13,32]});
    const mkr = L.marker([sp.lat, sp.lng], {icon, zIndexOffset:800, title:`Start: ${track.name}`})
      .addTo(map)
      .on('click', () => {
        openGpxPanel('tracks');
        setTimeout(() => openTrackDetail(track.id), 200);
      });
    track._startMkr = mkr;
  } catch(e) { console.warn('_addStartMarker error:', e); }
}

function _removeStartMarker(track) {
  if (track && track._startMkr) {
    try { map.removeLayer(track._startMkr); } catch(e) {}
    track._startMkr = null;
  }
}

// ══════════════════════════════════════════════════════════════
// ── NAVIGATION ENGINE ─────────────────────────────────────────
// ══════════════════════════════════════════════════════════════
const NAV = { active:false, trackId:null, startPt:null, routeLine:null };

// Bearing from A to B in degrees [0-360]
function _bearing(lat1,lon1,lat2,lon2){
  const dLon=(lon2-lon1)*Math.PI/180;
  const φ1=lat1*Math.PI/180, φ2=lat2*Math.PI/180;
  const y=Math.sin(dLon)*Math.cos(φ2);
  const x=Math.cos(φ1)*Math.sin(φ2)-Math.sin(φ1)*Math.cos(φ2)*Math.cos(dLon);
  return((Math.atan2(y,x)*180/Math.PI)+360)%360;
}
// Haversine distance in meters
function _distM(lat1,lon1,lat2,lon2){
  const R=6371000, dLat=(lat2-lat1)*Math.PI/180, dLon=(lon2-lon1)*Math.PI/180;
  const a=Math.sin(dLat/2)**2+Math.cos(lat1*Math.PI/180)*Math.cos(lat2*Math.PI/180)*Math.sin(dLon/2)**2;
  return R*2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));
}
// Bearing arrow emoji
function _bearingArrow(deg){
  const dirs=['↑','↗','→','↘','↓','↙','←','↖'];
  return dirs[Math.round(deg/45)%8];
}
// Human-readable distance
function _fmtDist(m){
  return m>=1000?`${(m/1000).toFixed(1)} km`:`${Math.round(m)} m`;
}
// Format ms as mm:ss.t
function _fmtTime(ms, tenths=true){
  if(ms==null||isNaN(ms))return'—';
  const neg=ms<0;ms=Math.abs(ms);
  const mins=Math.floor(ms/60000);
  const secs=Math.floor((ms%60000)/1000);
  const t=Math.floor((ms%1000)/100);
  let s=(neg?'-':'')+(mins<10?'0':'')+mins+':'+(secs<10?'0':'')+secs;
  if(tenths)s+='.'+t;
  return s;
}

// Extract the first LatLng of a GPX layer (start point) and a few more for direction
function _getGpxPoints(gpxLayer) {
  const pts = [];
  gpxLayer.eachLayer(layer => {
    if (layer.getLatLngs) {
      const raw = layer.getLatLngs();
      const flat = Array.isArray(raw[0]) ? raw.flat() : raw;
      flat.forEach(ll => pts.push({lat:ll.lat,lng:ll.lng}));
    }
  });
  return pts; // [{lat,lng}, ...]
}

// Compute 3 checkpoints + 1 finish using Turf.js lineChunk
function _computeCheckpoints(pts) {
  if (!window.turf || pts.length < 2) return null;
  const coords = pts.map(p => [p.lng, p.lat]); // turf uses [lng,lat]
  const line = turf.lineString(coords);
  const totalKm = turf.length(line, {units:'kilometers'});
  if (totalKm < 0.05) return null; // too short
  const segKm = totalKm / 4;
  const cps = [];
  for (let i = 1; i <= 4; i++) {
    const pt = turf.along(line, segKm * i, {units:'kilometers'});
    cps.push({
      lat: pt.geometry.coordinates[1],
      lng: pt.geometry.coordinates[0],
      isFinish: i === 4,
      label: i === 4 ? 'Ziel' : `S${i}`
    });
  }
  return {checkpoints:cps, totalKm};
}

// Draw start line perpendicular to track (6m wide)
function _drawStartLine(startPt, secondPt) {
  if (!window.turf) return null;
  const bearing = turf.bearing(
    turf.point([startPt.lng, startPt.lat]),
    turf.point([secondPt.lng, secondPt.lat])
  );
  const left  = turf.destination(turf.point([startPt.lng, startPt.lat]), 0.003, bearing - 90, {units:'kilometers'});
  const right = turf.destination(turf.point([startPt.lng, startPt.lat]), 0.003, bearing + 90, {units:'kilometers'});
  const lLatLng = [left.geometry.coordinates[1],  left.geometry.coordinates[0]];
  const rLatLng = [right.geometry.coordinates[1], right.geometry.coordinates[0]];
  return L.polyline([lLatLng, rLatLng], {
    color:'#c8ff00', weight:5, opacity:.9, dashArray:null
  }).addTo(map);
}

// Start navigation to track start
async function startNavigation(trackId) {
  const t = trackStore.tracks.find(t => t.id === trackId);
  if (!t) return;
  const pts = _getGpxPoints(t.gpxLayer);
  if (!pts.length) { toast('⚠️ Track hat keine Koordinaten'); return; }

  // Stop previous navigation
  stopNavigation(false);

  NAV.active = true;
  NAV.trackId = trackId;
  NAV.startPt = pts[0];

  // Google Maps link
  const gmUrl = `https://www.google.com/maps/dir/?api=1&destination=${pts[0].lat},${pts[0].lng}&travelmode=bicycling`;
  document.getElementById('nh-gmaps').href = gmUrl;
  document.getElementById('nh-title').textContent = `→ ${escHtml(t.name)}`;
  document.getElementById('nh-dist').textContent = '…';
  document.getElementById('nh-sub').textContent = 'GPS wird aktiviert…';
  document.getElementById('nav-hud').classList.add('show');

  // Fly to track start so user can see where to go
  map.flyTo([pts[0].lat, pts[0].lng], 16, {animate:true, duration:1.5});

  try {
    _gpsAutoFollow = false; // don't override the fly-to
    await ensureGpsActive();
    toast('🧭 Navigation zum Start aktiviert');
  } catch(e) {
    showGpsHint('GPS nötig', 'Erlaube Standortzugriff für die Navigation.');
    stopNavigation(false);
  }
}

function stopNavigation(showToast=true) {
  if (NAV.routeLine) { map.removeLayer(NAV.routeLine); NAV.routeLine = null; }
  NAV.active = false; NAV.trackId = null; NAV.startPt = null;
  document.getElementById('nav-hud').classList.remove('show');
  if (showToast) toast('🛑 Navigation beendet');
}

// Called every GPS update when navigation is active
function _onNavGpsUpdate(lat, lng, acc) {
  if (!NAV.active || !NAV.startPt) return;
  const dist = _distM(lat, lng, NAV.startPt.lat, NAV.startPt.lng);
  const bear = _bearing(lat, lng, NAV.startPt.lat, NAV.startPt.lng);
  const arrow = _bearingArrow(bear);

  document.getElementById('nh-arrow').textContent = arrow;
  document.getElementById('nh-dist').textContent = _fmtDist(dist);
  document.getElementById('nh-sub').textContent = `${Math.round(bear)}° · ±${Math.round(acc)}m`;

  // Draw/update route line from user to start
  if (NAV.routeLine) NAV.routeLine.setLatLngs([[lat,lng],[NAV.startPt.lat,NAV.startPt.lng]]);
  else NAV.routeLine = L.polyline([[lat,lng],[NAV.startPt.lat,NAV.startPt.lng]],
    {color:'var(--log)',weight:3,opacity:.7,dashArray:'8 10'}).addTo(map);

  // Auto-transition: when very close to start, begin pre-race approach mode
  if (dist < 50 && RACE.state === 'idle' && NAV.trackId) {
    beginPreRace(NAV.trackId);
  }
}

// ══════════════════════════════════════════════════════════════
// ── RACE STATE MACHINE ─────────────────────────────────────────
// ══════════════════════════════════════════════════════════════
const RACE = {
  state: 'idle',     // idle|approaching|at_line|go|racing|paused|finished
  trackId: null,
  trackName: '',
  startPt: null,     // {lat,lng}
  startLine: null,   // Leaflet polyline
  checkpoints: [],   // [{lat,lng,isFinish,label}]
  cpMarkers: [],     // Leaflet markers on map
  nextCpIdx: 0,      // which checkpoint to watch next

  // Timing (all in ms, using performance.now())
  startTs: null,
  pausedMs: 0,
  pauseStartTs: null,
  splitTimes: [],    // [ms] per completed split (up to 4)
  lastSplitTs: null,

  // Auto-pause detection
  _speedSamples: [],
  _lowSpeedSince: null,

  // Canvas approach state
  _lastAcc: null,        // last GPS accuracy (for canvas display)
  _confirmShown: false,  // whether the 2m start confirm was shown
  _backgroundMode: false,// true → race runs silently in background after user confirms

  // Resources to clean up
  gpsWatcher: null,
  wakeLock: null,
  timerInterval: null,
  _canvasRaf: null,      // requestAnimationFrame handle for canvas
  lastRunData: null  // for export/QR
};

function _raceElapsed() {
  if (!RACE.startTs) return 0;
  const raw = performance.now() - RACE.startTs - RACE.pausedMs;
  return Math.max(0, raw);
}

function _showRacePage(pageId) {
  ['rp-approaching','rp-approach','rp-go','rp-running','rp-results']
    .forEach(id => { const el=document.getElementById(id); if(el) el.style.display='none'; });
  const el = document.getElementById(pageId);
  if (el) el.style.display = pageId === 'rp-approach' ? 'block' : '';
  // Stop canvas animation if leaving approach page
  if (pageId !== 'rp-approach' && RACE._canvasRaf) {
    cancelAnimationFrame(RACE._canvasRaf); RACE._canvasRaf = null;
  }
}

// ── CANVAS APPROACH DRAWING ────────────────────────────────────
// Renders the distance warning canvas (5m → 2m approach animation)
// Completely independent from GPX recorder
function _drawApproachCanvas(distM) {
  const canvas = document.getElementById('approach-canvas');
  if (!canvas || !canvas.getContext) return;
  const parent = canvas.parentElement;
  if (!parent) return;
  const W = parent.clientWidth  || window.innerWidth;
  const H = parent.clientHeight || window.innerHeight;
  if (canvas.width !== W)  canvas.width  = W;
  if (canvas.height !== H) canvas.height = H;
  const ctx = canvas.getContext('2d');

  // ── Background
  ctx.fillStyle = isDark ? '#0b0e14' : '#121624';
  ctx.fillRect(0, 0, W, H);

  const atStart = distM <= 2;

  if (atStart) {
    // ══ START LINE VIEW ══════════════════════════════════
    // Vertical edge bars
    ctx.fillStyle = '#c8ff00';
    ctx.fillRect(0, 0, 6, H);
    ctx.fillRect(W - 6, 0, 6, H);

    // Horizontal start line
    const lineY = Math.round(H * 0.52);
    ctx.fillStyle = '#c8ff00';
    ctx.fillRect(0, lineY - 5, W, 10);

    // "START" lettering
    const fStart = Math.min(Math.round(W * 0.27), 90);
    ctx.font = `900 ${fStart}px 'Barlow Condensed',sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = '#c8ff00';
    ctx.shadowColor = '#c8ff00';
    ctx.shadowBlur = 18;
    ctx.fillText('START', W / 2, lineY - fStart * 0.65);
    ctx.shadowBlur = 0;

    // Distance in cm below line
    const cm = Math.round(distM * 100);
    ctx.font = `600 20px 'Barlow Condensed',sans-serif`;
    ctx.fillStyle = 'rgba(255,255,255,0.55)';
    ctx.fillText(`${cm} cm`, W / 2, lineY + 32);

  } else {
    // ══ APPROACHING VIEW (5m → 2m) ═══════════════════════
    // Progress 0 at 5m → 1 at 2m
    const progress = Math.max(0, Math.min(1, (5 - distM) / 3));

    // Color: amber at 5m (#f59e0b) → lime at 2m (#c8ff00)
    const r = Math.round(245 - progress * 47);
    const g = Math.round(158 + progress * 97);
    const b = Math.round(11);
    const distColor = `rgb(${r},${g},${b})`;

    // Big distance number
    const numSize = Math.round(80 + progress * 70);  // 80px → 150px
    ctx.font = `900 ${numSize}px 'Barlow Condensed',sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = distColor;
    ctx.shadowColor = distColor;
    ctx.shadowBlur = 12 + progress * 16;
    ctx.fillText(`${Math.round(distM)} m`, W / 2, H / 2 - numSize * 0.3);
    ctx.shadowBlur = 0;

    // "Bitte vorwerts laufen" — grows as you approach
    const txtSize = Math.round(14 + progress * 34);   // 14px → 48px
    const txtAlpha = 0.3 + progress * 0.7;             // 0.3 → 1.0
    ctx.font = `600 ${txtSize}px 'Barlow',sans-serif`;
    ctx.fillStyle = `rgba(255,255,255,${txtAlpha.toFixed(2)})`;
    ctx.fillText('Bitte vorwerts laufen', W / 2, H / 2 + numSize * 0.6 + progress * 8);

    // GPS accuracy info at bottom
    ctx.font = `400 11px sans-serif`;
    ctx.fillStyle = 'rgba(255,255,255,0.25)';
    ctx.fillText(`GPS ±${RACE._lastAcc != null ? Math.round(RACE._lastAcc) : '?'}m`, W / 2, H - 28);
  }
}

// Called via requestAnimationFrame to keep canvas crisp during approach
function _scheduleCanvasUpdate(distM) {
  if (RACE._canvasRaf) cancelAnimationFrame(RACE._canvasRaf);
  RACE._canvasRaf = requestAnimationFrame(() => {
    RACE._canvasRaf = null;
    _drawApproachCanvas(distM);
  });
}

// User confirms / denies race start from the 2m dialog
function _confirmRaceStart(confirmed) {
  // Hide confirm buttons regardless
  const conf = document.getElementById('approach-confirm');
  if (conf) conf.classList.remove('show');

  if (!confirmed) {
    abortRace();
    return;
  }

  // YES — run race in background (no fullscreen overlay during race)
  RACE._backgroundMode = true;
  toast('🏁 Zeitmessung gestartet — Viel Erfolg!');
  if (navigator.vibrate) navigator.vibrate([200, 80, 200]);
  _crossStartLine();
}

async function beginPreRace(trackId) {
  if (RACE.state !== 'idle') return;
  const t = trackStore.tracks.find(t => t.id === trackId);
  if (!t) return;

  const pts = _getGpxPoints(t.gpxLayer);
  if (pts.length < 2) { toast('⚠️ Track zu kurz für Zeitnahme'); return; }

  RACE.state = 'approaching';
  RACE.trackId = trackId;
  RACE.trackName = t.name;
  RACE.startPt = pts[0];
  RACE.checkpoints = _computeCheckpoints(pts)?.checkpoints || [];
  RACE.nextCpIdx = 0;
  RACE.splitTimes = [];
  RACE.startTs = null;
  RACE.pausedMs = 0;
  RACE.pauseStartTs = null;
  RACE.lastSplitTs = null;
  RACE._speedSamples = [];
  RACE._lowSpeedSince = null;
  RACE._lastAcc = null;
  RACE._confirmShown = false;
  RACE._backgroundMode = false;
  if (RACE._canvasRaf) { cancelAnimationFrame(RACE._canvasRaf); RACE._canvasRaf = null; }

  // Show checkpoint markers on map
  _clearCpMarkers();
  if (RACE.checkpoints.length) {
    RACE.checkpoints.forEach((cp, i) => {
      const icon = L.divIcon({
        className:'',
        html:`<div class="chk-div${cp.isFinish?' finish':''}"></div>`,
        iconSize:[16,16], iconAnchor:[8,8]
      });
      RACE.cpMarkers.push(L.marker([cp.lat,cp.lng],{icon,zIndexOffset:900}).addTo(map)
        .bindTooltip(cp.label,{permanent:true,direction:'top',className:'map-label'}));
    });
  }

  // Show pre-race overlay
  document.getElementById('race-overlay').classList.add('show');
  _showRacePage('rp-approaching');
  document.getElementById('ra-track-nm').textContent = t.name;

  // Wake Lock
  try {
    if ('wakeLock' in navigator) RACE.wakeLock = await navigator.wakeLock.request('screen');
  } catch(e) { console.info('Wake Lock nicht verfügbar:', e.message); }

  // Ensure GPS
  try { await ensureGpsActive(); } catch(e) { /* handled */ }

  toast('🏁 Fahre zur Startlinie!');
}

function _clearCpMarkers() {
  RACE.cpMarkers.forEach(m => map.removeLayer(m));
  RACE.cpMarkers = [];
  if (RACE.startLine) { map.removeLayer(RACE.startLine); RACE.startLine = null; }
}

// GPS callback during pre-race & racing
function _onRaceGpsUpdate(lat, lng, acc, speed) {
  if (RACE.state === 'idle' || RACE.state === 'finished') return;

  const distToStart = _distM(lat, lng, RACE.startPt.lat, RACE.startPt.lng);

  // Track GPS accuracy for canvas display
  RACE._lastAcc = acc;

  if (RACE.state === 'approaching') {
    // Update simple approaching page with big distance number
    document.getElementById('ra-dist-val').textContent = Math.round(distToStart);
    document.getElementById('ra-gps-acc').textContent = `GPS ±${Math.round(acc)}m`;

    // At 5m (or less) with reasonable accuracy: switch to canvas approach
    if (distToStart <= 5 && acc <= 20) {
      _enterStartLine(lat, lng, acc);
    }
    return;
  }

  if (RACE.state === 'at_line') {
    // Update canvas with current distance (uses rAF for smoothness)
    _scheduleCanvasUpdate(distToStart);

    // At 2m: show confirmation dialog (only once)
    if (distToStart <= 2.0 && !RACE._confirmShown && acc <= 15) {
      RACE._confirmShown = true;
      const conf = document.getElementById('approach-confirm');
      if (conf) conf.classList.add('show');
      // Also draw the START view immediately
      _drawApproachCanvas(distToStart);
      if (navigator.vibrate) navigator.vibrate([300, 100, 300]);
    }

    // Auto-start fallback: if user is right on the line without having confirmed
    // (e.g., they swiped past the dialog) — don't auto-start, keep dialog visible
    return;
  }

  if (RACE.state === 'racing' || RACE.state === 'paused') {
    _processRacePosition(lat, lng, acc, speed);
    return;
  }
}

function _enterStartLine(lat, lng, acc) {
  RACE.state = 'at_line';
  RACE._confirmShown = false;

  // Pulse vibration — approach warning
  if (navigator.vibrate) navigator.vibrate([150, 80, 150]);

  // Draw start line on map (perpendicular to track direction)
  const pts = _getGpxPoints(trackStore.tracks.find(t=>t.id===RACE.trackId)?.gpxLayer || {eachLayer:()=>{}});
  if (pts.length >= 2) RACE.startLine = _drawStartLine(pts[0], pts[1]);

  // Show canvas approach page (replaces rp-startline)
  _showRacePage('rp-approach');
  document.getElementById('race-overlay').classList.add('show');
  // Immediate draw
  const dist = _distM(lat, lng, RACE.startPt.lat, RACE.startPt.lng);
  _drawApproachCanvas(dist);
}

function _crossStartLine() {
  if (RACE.state === 'go' || RACE.state === 'racing') return; // already fired
  RACE.state = 'go';

  if (navigator.vibrate) navigator.vibrate([300]);

  if (RACE._backgroundMode) {
    // ── BACKGROUND MODE: hide overlay, race runs silently ──────
    document.getElementById('race-overlay').classList.remove('show');
    if (RACE._canvasRaf) { cancelAnimationFrame(RACE._canvasRaf); RACE._canvasRaf = null; }
    // Start timer immediately (no GO-page delay in background mode)
    RACE.state = 'racing';
    RACE.startTs = performance.now();
    RACE.lastSplitTs = RACE.startTs;
    RACE.timerInterval = setInterval(_tickTimer, 100);
    stopNavigation(false);
    toast('▶ Los! Zeitmessung läuft…');
  } else {
    // ── NORMAL MODE: show GO page → running page ───────────────
    _showRacePage('rp-go');
    document.getElementById('race-overlay').classList.add('show');

    // Build split boxes for running page
    const grid = document.getElementById('rr-splits-grid');
    grid.innerHTML = '';
    const labels = ['Split 1','Split 2','Split 3','Ziel'];
    labels.forEach((lbl,i) => {
      const div = document.createElement('div');
      div.className = 'rr-split-box' + (i===0?' active':'');
      div.id = `rr-split-${i}`;
      div.innerHTML = `<div class="rr-split-lbl">${lbl}</div><div class="rr-split-val empty" id="rr-sv-${i}">—</div>`;
      grid.appendChild(div);
    });
    document.getElementById('rr-track-nm').textContent = RACE.trackName;

    // Start timer after short GO delay
    setTimeout(() => {
      RACE.state = 'racing';
      RACE.startTs = performance.now();
      RACE.lastSplitTs = RACE.startTs;
      _showRacePage('rp-running');
      RACE.timerInterval = setInterval(_tickTimer, 100);
      stopNavigation(false);
    }, 800);
  }
}

function _tickTimer() {
  if (RACE.state !== 'racing') return;
  const el = document.getElementById('rr-timer');
  if (el) el.textContent = _fmtTime(_raceElapsed());
}

function _processRacePosition(lat, lng, acc, speed) {
  // Auto-pause logic
  const spd = (speed != null && !isNaN(speed)) ? speed : 0;
  const kmh = spd * 3.6;
  document.getElementById('rr-speed-lbl').textContent = `${kmh.toFixed(1)} km/h · ±${Math.round(acc)}m`;

  if (RACE.state === 'racing') {
    if (spd < 0.5) {
      if (!RACE._lowSpeedSince) RACE._lowSpeedSince = performance.now();
      else if (performance.now() - RACE._lowSpeedSince > 4000) {
        // Auto-pause
        RACE.state = 'paused';
        RACE.pauseStartTs = performance.now();
        document.getElementById('rr-timer').classList.add('paused');
        document.getElementById('rr-pause-lbl').textContent = 'Auto-Pause';
        if (navigator.vibrate) navigator.vibrate([100, 50, 100]);
      }
    } else {
      RACE._lowSpeedSince = null;
    }
  } else if (RACE.state === 'paused') {
    if (spd > 0.5) {
      // Auto-resume
      RACE.pausedMs += performance.now() - RACE.pauseStartTs;
      RACE.pauseStartTs = null;
      RACE.state = 'racing';
      RACE._lowSpeedSince = null;
      document.getElementById('rr-timer').classList.remove('paused');
      document.getElementById('rr-pause-lbl').textContent = '';
      if (navigator.vibrate) navigator.vibrate([50]);
    }
  }

  // Check next checkpoint (only if racing, not paused)
  if (RACE.state !== 'racing') return;
  if (RACE.nextCpIdx >= RACE.checkpoints.length) return;

  const cp = RACE.checkpoints[RACE.nextCpIdx];
  const dToCp = _distM(lat, lng, cp.lat, cp.lng);

  if (dToCp < 5) {
    const now = performance.now();
    const splitMs = now - RACE.lastSplitTs;
    RACE.lastSplitTs = now;
    RACE.splitTimes.push(splitMs);

    if (navigator.vibrate) navigator.vibrate([100]);

    if (RACE._backgroundMode) {
      // Toast the split time silently
      const lbl = cp.isFinish ? '🏁 Ziel' : `⏱ ${cp.label}`;
      toast(`${lbl}: ${_fmtTime(splitMs)}`);
    } else {
      // Update running page split boxes
      const svEl = document.getElementById(`rr-sv-${RACE.nextCpIdx}`);
      const sbEl = document.getElementById(`rr-split-${RACE.nextCpIdx}`);
      if (svEl) { svEl.textContent = _fmtTime(splitMs); svEl.classList.remove('empty'); }
      if (sbEl) { sbEl.classList.remove('active'); sbEl.classList.add('done'); }
      const nextSb = document.getElementById(`rr-split-${RACE.nextCpIdx+1}`);
      if (nextSb) nextSb.classList.add('active');
    }

    if (cp.isFinish) {
      _finishRace();
    } else {
      RACE.nextCpIdx++;
    }
  }
}

async function _finishRace() {
  RACE.state = 'finished';
  clearInterval(RACE.timerInterval);
  RACE.timerInterval = null;
  if (navigator.vibrate) navigator.vibrate([200, 100, 200, 100, 400]);

  const totalMs = _raceElapsed();
  const run = {
    trackId:   RACE.trackId,
    trackName: RACE.trackName,
    date:      new Date().toISOString(),
    totalMs,
    splits:    RACE.splitTimes.slice()
  };
  RACE.lastRunData = run;

  // Save to IndexedDB
  await _saveRun(run);

  // Release wake lock
  if (RACE.wakeLock) { try { await RACE.wakeLock.release(); } catch(e){} RACE.wakeLock = null; }

  // Load leaderboard for this track
  const runs = await _getRunsForTrack(RACE.trackId);
  const rank = runs.sort((a,b)=>a.totalMs-b.totalMs).findIndex(r=>r.date===run.date);

  // Build results UI
  document.getElementById('rres-track-nm').textContent = RACE.trackName;
  document.getElementById('rres-total').textContent = _fmtTime(totalMs);

  const splitsGrid = document.getElementById('rres-splits-grid');
  splitsGrid.innerHTML = '';
  const slabels = ['Split 1','Split 2','Split 3','Ziel'];
  RACE.splitTimes.forEach((ms, i) => {
    const card = document.createElement('div');
    card.className = 'rres-split-card';
    card.innerHTML = `<div class="rres-split-lbl">${slabels[i]||'Split'}</div><div class="rres-split-val">${_fmtTime(ms)}</div>`;
    splitsGrid.appendChild(card);
  });

  // Leaderboard
  const lb = document.getElementById('rres-lb');
  lb.innerHTML = '';
  const sorted = [...runs].sort((a,b)=>a.totalMs-b.totalMs).slice(0,8);
  sorted.forEach((r, i) => {
    const isCur = r.date === run.date;
    const row = document.createElement('div');
    row.className = `rres-lb-row${i===0?' gold-row':''}${isCur?' cur-row':''}`;
    const rankCls = i===0?' gold':'';
    row.innerHTML = `<span class="rres-lb-rank${rankCls}">${i===0?'🥇':i+1}</span>
      <span class="rres-lb-date">${new Date(r.date).toLocaleDateString('de')}</span>
      <span class="rres-lb-time">${_fmtTime(r.totalMs)}</span>`;
    lb.appendChild(row);
  });

  // Generate QR code with race result data (compact JSON with timestamps)
  try {
    const qrPayload = JSON.stringify({
      track: run.trackName,
      date: run.date,
      total: _fmtTime(totalMs, false),
      splits: run.splits.map((ms,i) => ({ s: slabels[i]||`S${i+1}`, t: _fmtTime(ms, false) }))
    });
    const qrCanvas = document.getElementById('rres-qr-canvas');
    if (qrCanvas) drawQR(qrCanvas, qrPayload, 120, '#0b0e14', '#ffffff');
  } catch(e) { console.warn('QR render error:', e); }

  _showRacePage('rp-results');
  // Always show overlay at finish (even if race was in background mode)
  document.getElementById('race-overlay').classList.add('show');
  _clearCpMarkers();
  renderTrackList(); // refresh run counts in track list
}

function confirmAbortRace() {
  if (RACE.state === 'finished' || RACE.state === 'idle') { abortRace(); return; }
  document.getElementById('rr-confirm').classList.add('show');
  _showRacePage('rp-running'); // make sure running page is visible
}
function hideAbortConfirm() {
  document.getElementById('rr-confirm').classList.remove('show');
}
function abortRace() {
  clearInterval(RACE.timerInterval); RACE.timerInterval = null;
  if (RACE._canvasRaf) { cancelAnimationFrame(RACE._canvasRaf); RACE._canvasRaf = null; }
  if (RACE.wakeLock) { try{RACE.wakeLock.release();}catch(e){} RACE.wakeLock = null; }
  _clearCpMarkers();
  stopNavigation(false);
  RACE.state = 'idle';
  RACE.trackId = null;
  RACE._backgroundMode = false;
  RACE._confirmShown = false;
  document.getElementById('race-overlay').classList.remove('show');
  const conf = document.getElementById('approach-confirm');
  if (conf) conf.classList.remove('show');
  toast('🛑 Rennen abgebrochen');
}
function closeRaceOverlay() {
  if (RACE.state !== 'finished') { abortRace(); return; }
  RACE.state = 'idle';
  RACE.trackId = null;
  document.getElementById('race-overlay').classList.remove('show');
  renderTrackList(); // refresh leaderboard in list
}

// ══════════════════════════════════════════════════════════════
// ── LEADERBOARD & RUN STORAGE ──────────────────────────────────
// ══════════════════════════════════════════════════════════════
async function _saveRun(run) {
  try {
    const all = (await localforage.getItem(LS.K.RUNS)) || {};
    if (!all[run.trackId]) all[run.trackId] = [];
    all[run.trackId].push(run);
    // Keep max 50 runs per track, sorted best first
    all[run.trackId].sort((a,b)=>a.totalMs-b.totalMs);
    if (all[run.trackId].length > 50) all[run.trackId] = all[run.trackId].slice(0,50);
    await localforage.setItem(LS.K.RUNS, all);
    _cachedRuns = all; // refresh sync cache immediately
  } catch(e) { console.warn('Lauf speichern fehlgeschlagen:', e); }
}
async function _getRunsForTrack(trackId) {
  try {
    const all = (await localforage.getItem(LS.K.RUNS)) || {};
    return all[trackId] || [];
  } catch(e) { return []; }
}
async function _getAllRuns() {
  try { return (await localforage.getItem(LS.K.RUNS)) || {}; } catch(e) { return {}; }
}

function exportRunJson() {
  if (!RACE.lastRunData) return;
  const name = (RACE.lastRunData.trackName || 'run').replace(/[^a-zA-Z0-9_-]/g,'_');
  dlFile(`${name}_${new Date().toISOString().slice(0,10)}.json`,
    JSON.stringify(RACE.lastRunData, null, 2), 'application/json');
  toast('⬇ JSON exportiert');
}
function shareRunQr() {
  if (!RACE.lastRunData) return;
  const d = RACE.lastRunData;
  // Build compact QR payload with times + timestamps
  const payload = {
    track: d.trackName,
    date: d.date,
    total: _fmtTime(d.totalMs, false),
    splits: d.splits.map((ms,i)=>({s:`S${i+1}`,t:_fmtTime(ms,false)}))
  };
  const qrStr = JSON.stringify(payload);
  const canvas = document.getElementById('rres-qr-canvas');
  if (canvas) drawQR(canvas, qrStr, 120, '#0b0e14', '#ffffff');
  toast('📋 QR-Code generiert!');
}

// ══════════════════════════════════════════════════════════════
// ── TRACK DETAIL PANEL (in track list) ─────────────────────────
// ══════════════════════════════════════════════════════════════
// _activeDetailId is declared at trackStore level above for sync access

function openTrackDetail(trackId) {
  if (_activeDetailId === trackId) { closeTrackDetail(); return; }
  _activeDetailId = trackId;
  renderTrackList(); // sync render — adds placeholder slot
  _fillDetailSlot(); // async — fills placeholder with real content
}
function closeTrackDetail() {
  _activeDetailId = null;
  renderTrackList();
}

// Async: fills #trk-detail-slot with the rendered detail panel
async function _fillDetailSlot() {
  const slot = document.getElementById('trk-detail-slot');
  if (!slot || !_activeDetailId) return;
  const t = trackStore.tracks.find(t => t.id === _activeDetailId);
  if (!t) return;
  const div = await _renderTrackDetailPanel(t);
  if (slot.isConnected) { // still in DOM (not closed meanwhile)
    slot.className = ''; // remove loading style
    slot.style.cssText = '';
    slot.textContent = '';
    slot.appendChild(div);
  }
}

async function _renderTrackDetailPanel(t) {
  const runs = await _getRunsForTrack(t.id);
  const sorted = [...runs].sort((a,b)=>a.totalMs-b.totalMs);
  const startPts = _getGpxPoints(t.gpxLayer);
  const gmUrl = startPts.length
    ? `https://www.google.com/maps/dir/?api=1&destination=${startPts[0].lat},${startPts[0].lng}&travelmode=bicycling`
    : '#';

  const div = document.createElement('div');
  div.className = 'trk-detail';

  const lbHtml = sorted.length === 0
    ? `<div class="tdd-lb-empty">Noch keine Zeiten — erste Fahrt starten!</div>`
    : sorted.slice(0,5).map((r,i) => `
      <div class="tdd-lb-row${i===0?' gold-lb':''}">
        <span class="tdd-lb-rank${i===0?' gold':''}">${i===0?'🥇':i+1}</span>
        <span class="tdd-lb-date">${new Date(r.date).toLocaleDateString('de-DE',{day:'2-digit',month:'2-digit',year:'2-digit'})}</span>
        <span class="tdd-lb-time">${_fmtTime(r.totalMs)}</span>
      </div>`).join('');

  div.innerHTML = `
    <div class="tdd-head">
      <div class="tdd-dot" style="background:${t.color}"></div>
      <div class="tdd-name">${escHtml(t.name)}</div>
      <button class="tdd-close" onclick="closeTrackDetail()" aria-label="Schließen">×</button>
    </div>
    <div class="tdd-stats">
      <div class="tdd-stat"><div class="tdd-stat-val">${t.stats.dist}</div><div class="tdd-stat-lbl">km</div></div>
      <div class="tdd-stat"><div class="tdd-stat-val">${t.stats.dur||'—'}</div><div class="tdd-stat-lbl">Zeit</div></div>
      <div class="tdd-stat"><div class="tdd-stat-val">${sorted.length}</div><div class="tdd-stat-lbl">Runs</div></div>
    </div>
    <div class="tdd-btns">
      <button class="tdd-btn race" onclick="closeTrackDetail();beginPreRace('${t.id}')">
        <svg width="13" height="13" viewBox="0 0 13 13" fill="none"><polygon points="2,1 12,6.5 2,12" fill="currentColor"/></svg>
        Strecke starten &amp; Zeit messen
      </button>
      <button class="tdd-btn navi" onclick="closeTrackDetail();startNavigation('${t.id}')">
        <svg width="13" height="13" viewBox="0 0 13 13" fill="none"><path d="M6.5 1L12 6.5 6.5 12M1 6.5H11.5" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/></svg>
        Zur Startlinie navigieren
      </button>
      <button class="tdd-btn" style="background:transparent;color:var(--td);border:1px solid var(--bd2)" onclick="closeTrackDetail();zoomTrack('${t.id}');showElevProfile('${t.id}')">
        <svg width="13" height="13" viewBox="0 0 13 13" fill="none"><circle cx="5.5" cy="5.5" r="4" stroke="currentColor" stroke-width="1.5"/><path d="M9 9L12 12" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>
        Auf Karte anzeigen
      </button>
      <a class="tdd-btn gmaps" href="${gmUrl}" target="_blank" rel="noopener">
        <svg width="11" height="13" viewBox="0 0 11 13" fill="none"><path d="M5.5 0C2.46 0 0 2.46 0 5.5 0 9.63 5.5 13 5.5 13s5.5-3.37 5.5-7.5C11 2.46 8.54 0 5.5 0zm0 7.5a2 2 0 110-4 2 2 0 010 4z" fill="currentColor"/></svg>
        Start in Google Maps öffnen
      </a>
    </div>
    <div class="tdd-lb">
      <div class="tdd-lb-head">🏆 Bestenliste</div>
      ${lbHtml}
      ${sorted.length > 0 ? `<button class="tdd-lb-export" onclick="exportTrackRunsJson('${t.id}')">⬇ Alle Zeiten als JSON</button>` : ''}
    </div>`;
  return div;
}

async function exportTrackRunsJson(trackId) {
  const runs = await _getRunsForTrack(trackId);
  const t = trackStore.tracks.find(t=>t.id===trackId);
  const name = (t?.name||trackId).replace(/[^a-zA-Z0-9_-]/g,'_');
  dlFile(`${name}_zeiten.json`, JSON.stringify({trackId,trackName:t?.name,runs},null,2), 'application/json');
  toast('⬇ Zeiten exportiert');
}

// ══════════════════════════════════════════════════════════════
// ── RUN CACHE — keeps renderTrackList() sync-safe ─────────────
// ══════════════════════════════════════════════════════════════
async function _initRunCache() {
  _cachedRuns = await _getAllRuns();
  renderTrackList();
}

</script>

<!-- ══ NAVIGATION HUD ══════════════════════════════════════════ -->
<div id="nav-hud" role="status" aria-live="polite">
  <div class="nh-arrow" id="nh-arrow">↑</div>
  <div class="nh-txt">
    <div class="nh-title" id="nh-title">Zum Startpunkt</div>
    <div class="nh-dist" id="nh-dist">—</div>
    <div class="nh-sub" id="nh-sub">GPS wird aktiviert…</div>
    <a class="nh-gmaps" id="nh-gmaps" href="#" target="_blank" rel="noopener noreferrer">
      <svg width="11" height="11" viewBox="0 0 11 11" fill="none"><path d="M5.5 1C3.29 1 1.5 2.79 1.5 5c0 3.07 4 7 4 7s4-3.93 4-7c0-2.21-1.79-4-4-4zm0 5.4a1.4 1.4 0 110-2.8 1.4 1.4 0 010 2.8z" fill="currentColor"/></svg>
      Google Maps öffnen
    </a>
  </div>
  <button class="nh-close" onclick="stopNavigation()" aria-label="Navigation beenden">×</button>
</div>

<!-- ══ RACE OVERLAY ════════════════════════════════════════════ -->
<div id="race-overlay" role="dialog" aria-modal="true" aria-label="Rennen">
  <button class="race-overlay-x" id="race-x-btn" onclick="confirmAbortRace()" aria-label="Rennen abbrechen">×</button>

  <!-- Seite 1: Annäherung (> 5 m) — einfache Distanzanzeige -->
  <div class="race-approaching" id="rp-approaching" style="display:none">
    <div class="ra-icon">🚴</div>
    <div class="ra-title">Zum Startpunkt fahren</div>
    <div class="ra-track" id="ra-track-nm">—</div>
    <div class="ra-num" id="ra-dist-val">—</div>
    <div class="ra-unit">Meter bis Start</div>
    <div class="ra-acc" id="ra-gps-acc"></div>
    <div class="ra-hint">Nähere dich der Startlinie (5 m → Start-Warnung)</div>
  </div>

  <!-- Seite 2: Canvas-Annäherung (≤ 5 m) — Bitte vorwerts laufen wächst an -->
  <div id="rp-approach">
    <!-- Canvas füllt die gesamte Seite — wird via JS beschriftet -->
    <canvas id="approach-canvas"></canvas>
    <!-- Start-Bestätigung erscheint bei 2 m als Overlay über dem Canvas -->
    <div id="approach-confirm">
      <div class="approach-confirm-q">Strecke starten &amp;<br>Zeit messen?</div>
      <div class="approach-confirm-btns">
        <button class="approach-btn-yes" onclick="_confirmRaceStart(true)">
          ✓ Ja, Start!
        </button>
        <button class="approach-btn-no" onclick="_confirmRaceStart(false)">
          Nein
        </button>
      </div>
    </div>
  </div>

  <!-- Seite 3: GO! -->
  <div class="race-go-page" id="rp-go" style="display:none">
    <div class="rg-go">GO!</div>
    <div class="rg-sub">Zeitmessung läuft</div>
  </div>

  <!-- Seite 4: Rennen läuft -->
  <div class="race-running" id="rp-running" style="display:none">
    <div class="rr-name" id="rr-track-nm">—</div>
    <div class="rr-timer" id="rr-timer">00:00.0</div>
    <div class="rr-pause-lbl" id="rr-pause-lbl"></div>
    <div class="rr-splits-grid" id="rr-splits-grid"><!-- dynamisch --></div>
    <div class="rr-speed-lbl" id="rr-speed-lbl"></div>
    <button class="rr-abort-btn" onclick="confirmAbortRace()">■ Abbrechen</button>
    <div class="rr-confirm-box" id="rr-confirm">
      <div class="rr-confirm-q">Rennen wirklich abbrechen?</div>
      <div class="rr-confirm-btns">
        <button onclick="abortRace()" style="background:var(--exp);color:#fff">Abbrechen</button>
        <button onclick="hideAbortConfirm()" style="background:var(--s3);color:var(--td)">Weiter!</button>
      </div>
    </div>
  </div>

  <!-- Seite 5: Ergebnisse -->
  <div class="race-results" id="rp-results" style="display:none">
    <div class="rres-crown">🏁</div>
    <div class="rres-title">Ziel erreicht!</div>
    <div class="rres-track" id="rres-track-nm">—</div>
    <div class="rres-total-time" id="rres-total">—</div>
    <div class="rres-total-lbl">Netto-Gesamtzeit</div>
    <div class="rres-splits-grid" id="rres-splits-grid"></div>
    <!-- QR-Code mit Zeiten + Zeitstempeln -->
    <div class="rres-qr-wrap">
      <canvas id="rres-qr-canvas" width="120" height="120" aria-label="Ergebnis QR-Code"></canvas>
    </div>
    <div style="font-size:10px;color:var(--td);text-align:center;margin-bottom:8px">QR scannen → Ergebnis teilen</div>
    <div class="rres-lb-head">🏆 Bestenliste</div>
    <div id="rres-lb"></div>
    <div class="rres-actions">
      <button class="rres-btn sec" onclick="exportRunJson()">⬇ JSON</button>
      <button class="rres-btn sec" onclick="shareRunQr()">🔄 QR neu</button>
      <button class="rres-btn prim" onclick="closeRaceOverlay()">Fertig</button>
    </div>
  </div>
</div>

</body>
</html>
