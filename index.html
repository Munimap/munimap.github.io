<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="GMTW Trail Map">
    <meta name="theme-color" content="#0b0e14">
    <meta name="msapplication-TileColor" content="#0b0e14">
    <meta name="msapplication-TileImage" content="icons/icon-144x144.png">
    <link rel="manifest" href="manifest.json">
    <!-- Favicon — mehrere Größen für Browser-Tab, Lesezeichen, Desktop-Verknüpfung -->
    <link rel="icon" type="image/png" sizes="16x16" href="icons/icon-16x16.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/icon-32x32.png">
    <link rel="icon" type="image/png" sizes="48x48" href="icons/icon-48x48.png">
    <link rel="icon" type="image/png" sizes="96x96" href="icons/icon-96x96.png">
    <link rel="shortcut icon" href="icons/icon-32x32.png">
    <!-- Apple Touch Icons — Homescreen-Icon auf iPhone und iPad -->
    <link rel="apple-touch-icon" sizes="180x180" href="icons/icon-180x180.png">
    <link rel="apple-touch-icon" sizes="167x167" href="icons/icon-192x192.png">
    <link rel="apple-touch-icon" sizes="152x152" href="icons/icon-152x152.png">
    <link rel="apple-touch-icon" sizes="144x144" href="icons/icon-144x144.png">
    <link rel="apple-touch-icon" href="icons/icon-180x180.png">
    <title>GMTW · Trail Map</title>
    <!-- Bunny Fonts — DSGVO-konformer Ersatz für Google Fonts (kein Tracking, EU-Hosting) -->
    <link rel="preconnect" href="https://fonts.bunny.net">
    <link href="https://fonts.bunny.net/css2?family=Barlow+Condensed:wght@400;600;700;800&family=Barlow:wght@400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha384-sHL9NAb7lN7rfvG5lfHpm643Xkcjzp4jFvuavGOndn6pjVqS6ny56CAt3nsEVT4H"
      crossorigin="anonymous"/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
      integrity="sha384-cxOPjt7s7Iz04uaHJceBmS+qpjv2JkIHNVcuOrM+YHwZOmJGBXI00mdUXEq65HTH"
      crossorigin="anonymous"></script>
    <!-- localforage 1.10.0 — IndexedDB-Wrapper (GPX-Caching, kein Quota-Limit) -->
    <script src="https://cdn.jsdelivr.net/npm/localforage@1.10.0/dist/localforage.min.js"></script>
    <!-- Turf.js 7 — Geo-Berechnungen (Distanz, Sektoren, Geofencing) -->
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@7/turf.min.js"></script>
    <!-- jsQR 1.4.0 — QR-Code-Lesebibliothek (kein Tracking, rein lokal) -->
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>
    <!-- pako 2.1.0 — DEFLATE/INFLATE Komprimierung für QR-Track-Transfer (kein Tracking) -->
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
    <!-- leaflet-gpx 1.7.0 — inline (kein CDN, kein SRI-Risiko) -->
    <script>
/**

 *GMTW MAP
 */

/*
 * Thanks to Pavel Shramov who provided the initial implementation and Leaflet
 * integration. Original code was at https://github.com/shramov/leaflet-plugins.
 *
 * It was then cleaned-up and modified to record and make available more
 * information about the GPX track while it is being parsed so that the result
 * can be used to display additional information about the track that is
 * rendered on the Leaflet map.
 */

var L = L || require('leaflet');

var _MAX_POINT_INTERVAL_MS = 15000;
var _SECOND_IN_MILLIS = 1000;
var _MINUTE_IN_MILLIS = 60 * _SECOND_IN_MILLIS;
var _HOUR_IN_MILLIS = 60 * _MINUTE_IN_MILLIS;
var _DAY_IN_MILLIS = 24 * _HOUR_IN_MILLIS;

var _GPX_STYLE_NS = 'http://www.topografix.com/GPX/gpx_style/0/2';

var _DEFAULT_MARKER_OPTS = {
  startIconUrl: 'pin-icon-start.png',
  endIconUrl: 'pin-icon-end.png',
  shadowUrl: 'pin-shadow.png',
  wptIcons: [],
  wptIconsType: [],
  wptIconUrls : {
    '': 'pin-icon-wpt.png',
  },
  wptIconTypeUrls : {
    '': 'pin-icon-wpt.png',
  },
  pointMatchers: [],
  iconSize: [33, 45],
  shadowSize: [50, 50],
  iconAnchor: [16, 45],
  shadowAnchor: [16, 47],
  clickable: false
};
var _DEFAULT_POLYLINE_OPTS = {
  color: 'blue'
};
var _DEFAULT_GPX_OPTS = {
  parseElements: ['track', 'route', 'waypoint'],
  joinTrackSegments: true
};

L.GPX = L.FeatureGroup.extend({
  initialize: function(gpx, options) {
    options.max_point_interval = options.max_point_interval || _MAX_POINT_INTERVAL_MS;
    options.marker_options = this._merge_objs(
      _DEFAULT_MARKER_OPTS,
      options.marker_options || {});
    options.polyline_options = options.polyline_options || {};
    options.gpx_options = this._merge_objs(
      _DEFAULT_GPX_OPTS,
      options.gpx_options || {});

    L.Util.setOptions(this, options);

    // Base icon class for track pins.
    L.GPXTrackIcon = L.Icon.extend({ options: options.marker_options });

    this._gpx = gpx;
    this._layers = {};
    this._init_info();

    if (gpx) {
      this._parse(gpx, options, this.options.async);
    }
  },

  get_duration_string: function(duration, hidems) {
    var s = '';

    if (duration >= _DAY_IN_MILLIS) {
      s += Math.floor(duration / _DAY_IN_MILLIS) + 'd ';
      duration = duration % _DAY_IN_MILLIS;
    }

    if (duration >= _HOUR_IN_MILLIS) {
      s += Math.floor(duration / _HOUR_IN_MILLIS) + ':';
      duration = duration % _HOUR_IN_MILLIS;
    }

    var mins = Math.floor(duration / _MINUTE_IN_MILLIS);
    duration = duration % _MINUTE_IN_MILLIS;
    if (mins < 10) s += '0';
    s += mins + '\'';

    var secs = Math.floor(duration / _SECOND_IN_MILLIS);
    duration = duration % _SECOND_IN_MILLIS;
    if (secs < 10) s += '0';
    s += secs;

    if (!hidems && duration > 0) s += '.' + Math.round(Math.floor(duration)*1000)/1000;
    else s += '"';

    return s;
  },

  get_duration_string_iso: function(duration, hidems) {
    var s = this.get_duration_string(duration, hidems);
    return s.replace("'",':').replace('"','');
  },

  // Public methods
  to_miles:            function(v) { return v / 1.60934; },
  to_ft:               function(v) { return v * 3.28084; },
  m_to_km:             function(v) { return v / 1000; },
  m_to_mi:             function(v) { return v / 1609.34; },
  ms_to_kmh:           function(v) { return v * 3.6; },
  ms_to_mih:           function(v) { return v / 1609.34 * 3600; },

  get_name:            function() { return this._info.name; },
  get_desc:            function() { return this._info.desc; },
  get_author:          function() { return this._info.author; },
  get_copyright:       function() { return this._info.copyright; },
  get_distance:        function() { return this._info.length; },
  get_distance_imp:    function() { return this.to_miles(this.m_to_km(this.get_distance())); },

  get_start_time:      function() { return this._info.duration.start; },
  get_end_time:        function() { return this._info.duration.end; },
  get_moving_time:     function() { return this._info.duration.moving; },
  get_total_time:      function() { return this._info.duration.total; },

  get_moving_pace:     function() { return this.get_moving_time() / this.m_to_km(this.get_distance()); },
  get_moving_pace_imp: function() { return this.get_moving_time() / this.get_distance_imp(); },

  get_moving_speed:    function() { return this.m_to_km(this.get_distance()) / (this.get_moving_time() / (3600 * 1000)) ; },
  get_moving_speed_imp:function() { return this.to_miles(this.m_to_km(this.get_distance())) / (this.get_moving_time() / (3600 * 1000)) ; },

  get_total_speed:     function() { return this.m_to_km(this.get_distance()) / (this.get_total_time() / (3600 * 1000)); },
  get_total_speed_imp: function() { return this.to_miles(this.m_to_km(this.get_distance())) / (this.get_total_time() / (3600 * 1000)); },

  get_elevation_gain:     function() { return this._info.elevation.gain; },
  get_elevation_loss:     function() { return this._info.elevation.loss; },
  get_elevation_gain_imp: function() { return this.to_ft(this.get_elevation_gain()); },
  get_elevation_loss_imp: function() { return this.to_ft(this.get_elevation_loss()); },
  get_elevation_data:     function() {
    var _this = this;
    return this._info.elevation._points.map(
      function(p) { return _this._prepare_data_point(p, _this.m_to_km, null,
        function(a, b) { return a.toFixed(2) + ' km, ' + b.toFixed(0) + ' m'; });
      });
  },
  get_elevation_data_imp: function() {
    var _this = this;
    return this._info.elevation._points.map(
      function(p) { return _this._prepare_data_point(p, _this.m_to_mi, _this.to_ft,
        function(a, b) { return a.toFixed(2) + ' mi, ' + b.toFixed(0) + ' ft'; });
      });
  },
  get_elevation_max:      function() { return this._info.elevation.max; },
  get_elevation_min:      function() { return this._info.elevation.min; },
  get_elevation_max_imp:  function() { return this.to_ft(this.get_elevation_max()); },
  get_elevation_min_imp:  function() { return this.to_ft(this.get_elevation_min()); },

  get_speed_data:         function() {
    var _this = this;
    return this._info.speed._points.map(
      function(p) { return _this._prepare_data_point(p, _this.m_to_km, _this.ms_to_kmh,
        function(a, b) { return a.toFixed(2) + ' km, ' + b.toFixed(2) + ' km/h'; });
      });
  },
  get_speed_data_imp: function() {
    var _this = this;
    return this._info.speed._points.map(
      function(p) { return _this._prepare_data_point(p, _this.m_to_mi, _this.ms_to_mih,
        function(a, b) { return a.toFixed(2) + ' mi, ' + b.toFixed(2) + ' mi/h'; });
      });
  },
  get_speed_max:          function() { return this.m_to_km(this._info.speed.max) * 3600; },
  get_speed_max_imp:      function() { return this.to_miles(this.get_speed_max()); },

  get_average_hr:         function() { return this._info.hr.avg; },
  get_average_temp:         function() { return this._info.atemp.avg; },
  get_average_cadence:         function() { return this._info.cad.avg; },
  get_heartrate_data:     function() {
    var _this = this;
    return this._info.hr._points.map(
      function(p) { return _this._prepare_data_point(p, _this.m_to_km, null,
        function(a, b) { return a.toFixed(2) + ' km, ' + b.toFixed(0) + ' bpm'; });
      });
  },
  get_heartrate_data_imp: function() {
    var _this = this;
    return this._info.hr._points.map(
      function(p) { return _this._prepare_data_point(p, _this.m_to_mi, null,
        function(a, b) { return a.toFixed(2) + ' mi, ' + b.toFixed(0) + ' bpm'; });
      });
  },
  get_cadence_data:     function() {
    var _this = this;
    return this._info.cad._points.map(
      function(p) { return _this._prepare_data_point(p, _this.m_to_km, null,
        function(a, b) { return a.toFixed(2) + ' km, ' + b.toFixed(0) + ' rpm'; });
      });
  },
  get_temp_data:     function() {
    var _this = this;
    return this._info.atemp._points.map(
      function(p) { return _this._prepare_data_point(p, _this.m_to_km, null,
        function(a, b) { return a.toFixed(2) + ' km, ' + b.toFixed(0) + ' degrees'; });
      });
  },
  get_cadence_data_imp:     function() {
    var _this = this;
    return this._info.cad._points.map(
      function(p) { return _this._prepare_data_point(p, _this.m_to_mi, null,
        function(a, b) { return a.toFixed(2) + ' mi, ' + b.toFixed(0) + ' rpm'; });
      });
  },
  get_temp_data_imp:     function() {
    var _this = this;
    return this._info.atemp._points.map(
      function(p) { return _this._prepare_data_point(p, _this.m_to_mi, null,
        function(a, b) { return a.toFixed(2) + ' mi, ' + b.toFixed(0) + ' degrees'; });
      });
  },

  reload: function() {
    this._init_info();
    this.clearLayers();
    this._parse(this._gpx, this.options, this.options.async);
  },

  // Private methods
  _merge_objs: function(a, b) {
    var _ = {};
    for (var attr in a) { _[attr] = a[attr]; }
    for (var attr in b) { _[attr] = b[attr]; }
    return _;
  },

  _prepare_data_point: function(p, trans1, trans2, trans_tooltip) {
    var r = [trans1 && trans1(p[0]) || p[0], trans2 && trans2(p[1]) || p[1]];
    r.push(trans_tooltip && trans_tooltip(r[0], r[1]) || (r[0] + ': ' + r[1]));
    return r;
  },

  _init_info: function() {
    this._info = {
      name: null,
      length: 0.0,
      elevation: {gain: 0.0, loss: 0.0, max: 0.0, min: Infinity, _points: []},
      speed : {max: 0.0, _points: []},
      hr: {avg: 0, _total: 0, _points: []},
      duration: {start: null, end: null, moving: 0, total: 0},
      atemp: {avg: 0, _total: 0, _points: []},
      cad: {avg: 0, _total: 0, _points: []}
    };
  },

  _load_xml: function(url, cb, options, async) {
    if (async == undefined) async = this.options.async;
    if (options == undefined) options = this.options;

    var req = new window.XMLHttpRequest();
    req.open('GET', url, async);
    try {
      req.overrideMimeType('text/xml'); // unsupported by IE
    } catch(e) {}
    req.onreadystatechange = function() {
      if (req.readyState != 4) return;
      if(req.status == 200) cb(req.responseXML, options);
    };
    req.send(null);
  },

  _parse: function(input, options, async) {
    var _this = this;
    var cb = function(gpx, options) {
      var layers = _this._parse_gpx_data(gpx, options);
      if (!layers) {
        _this.fire('error', { err: 'No parseable layers of type(s) ' + JSON.stringify(options.gpx_options.parseElements) });
        return;
      }
      _this.addLayer(layers);
      _this.fire('loaded', { layers: layers, element: gpx });
    }
    if (input.substr(0,1)==='<') { // direct XML has to start with a <
      var parser = new DOMParser();
      if (async) {
        setTimeout(function() {
          cb(parser.parseFromString(input, "text/xml"), options);
        });
      } else {
        cb(parser.parseFromString(input, "text/xml"), options);
      }
    } else {
      this._load_xml(input, cb, options, async);
    }
  },

  _parse_gpx_data: function(xml, options) {
    var i, t, l, el, layers = [];

    var name = xml.getElementsByTagName('name');
    if (name.length > 0) {
      this._info.name = name[0].textContent;
    }
    var desc = xml.getElementsByTagName('desc');
    if (desc.length > 0) {
      this._info.desc = desc[0].textContent;
    }
    var author = xml.getElementsByTagName('author');
    if (author.length > 0) {
      this._info.author = author[0].textContent;
    }
    var copyright = xml.getElementsByTagName('copyright');
    if (copyright.length > 0) {
      this._info.copyright = copyright[0].textContent;
    }

    var parseElements = options.gpx_options.parseElements;
    if (parseElements.indexOf('route') > -1) {
      // routes are <rtept> tags inside <rte> sections
      var routes = xml.getElementsByTagName('rte');
      for (i = 0; i < routes.length; i++) {
        layers = layers.concat(this._parse_segment(routes[i], options, {}, 'rtept'));
      }
    }

    if (parseElements.indexOf('track') > -1) {
      // tracks are <trkpt> tags in one or more <trkseg> sections in each <trk>
      var tracks = xml.getElementsByTagName('trk');
      for (i = 0; i < tracks.length; i++) {
        var track = tracks[i];
        var polyline_options = this._extract_styling(track);

        if (options.gpx_options.joinTrackSegments) {
          layers = layers.concat(this._parse_segment(track, options, polyline_options, 'trkpt'));
        } else {
          var segments = track.getElementsByTagName('trkseg');
          for (j = 0; j < segments.length; j++) {
            layers = layers.concat(this._parse_segment(segments[j], options, polyline_options, 'trkpt'));
          }
        }
      }
    }

    this._info.hr.avg = Math.round(this._info.hr._total / this._info.hr._points.length);
    this._info.cad.avg = Math.round(this._info.cad._total / this._info.cad._points.length);
    this._info.atemp.avg = Math.round(this._info.atemp._total / this._info.atemp._points.length);

    // parse waypoints and add markers for each of them
    if (parseElements.indexOf('waypoint') > -1) {
      el = xml.getElementsByTagName('wpt');
      for (i = 0; i < el.length; i++) {
        var ll = new L.LatLng(
            el[i].getAttribute('lat'),
            el[i].getAttribute('lon'));

        var nameEl = el[i].getElementsByTagName('name');
        var name = nameEl.length > 0 ? nameEl[0].textContent : '';

        var descEl = el[i].getElementsByTagName('desc');
        var desc = descEl.length > 0 ? descEl[0].textContent : '';

        var symEl = el[i].getElementsByTagName('sym');
        var symKey = symEl.length > 0 ? symEl[0].textContent : null;

        var typeEl = el[i].getElementsByTagName('type');
        var typeKey = typeEl.length > 0 ? typeEl[0].textContent : null;

        /*
         * Add waypoint marker based on the waypoint symbol key.
         *
         * First look for a configured icon for that symKey. If not found, look
         * for a configured icon URL for that symKey and build an icon from it.
         * If none of those match, look through the point matchers for a match
         * on the waypoint's name.
         *
         * Otherwise, fall back to the default icon if one was configured, or
         * finally to the default icon URL, if one was configured.
         */
        var wptIcons = options.marker_options.wptIcons;
        var wptIconUrls = options.marker_options.wptIconUrls;
        var wptIconsType = options.marker_options.wptIconsType;
        var wptIconTypeUrls = options.marker_options.wptIconTypeUrls;
        var ptMatchers = options.marker_options.pointMatchers || [];
        var symIcon;
        if (wptIcons && symKey && wptIcons[symKey]) {
          symIcon = wptIcons[symKey];
        } else if (wptIconsType && typeKey && wptIconsType[typeKey]) {
          symIcon = wptIconsType[typeKey];
        } else if (wptIconUrls && symKey && wptIconUrls[symKey]) {
          symIcon = new L.GPXTrackIcon({iconUrl: wptIconUrls[symKey]});
        } else if (wptIconTypeUrls && typeKey && wptIconTypeUrls[typeKey]) {
          symIcon = new L.GPXTrackIcon({iconUrl: wptIconTypeUrls[typeKey]});
        } else if (ptMatchers.length > 0) {
          for (var j = 0; j < ptMatchers.length; j++) {
            if (ptMatchers[j].regex.test(name)) {
              symIcon = ptMatchers[j].icon;
              break;
            }
          }
        } else if (wptIcons && wptIcons['']) {
          symIcon = wptIcons[''];
        } else if (wptIconUrls && wptIconUrls['']) {
          symIcon = new L.GPXTrackIcon({iconUrl: wptIconUrls['']});
        }

        if (!symIcon) {
          console.log(
            'No waypoint icon could be matched for symKey=%s,typeKey=%s,name=%s on waypoint %o',
            symKey, typeKey, name, el[i]);
          continue;
        }

        var marker = new L.Marker(ll, {
          clickable: options.marker_options.clickable,
          title: name,
          icon: symIcon,
          type: 'waypoint'
        });
        marker.bindPopup("<b>" + name + "</b>" + (desc.length > 0 ? '<br>' + desc : '')).openPopup();
        this.fire('addpoint', { point: marker, point_type: 'waypoint', element: el[i] });
        layers.push(marker);
      }
    }

    if (layers.length > 1) {
       return new L.FeatureGroup(layers);
    } else if (layers.length == 1) {
      return layers[0];
    }
  },

  _parse_segment: function(line, options, polyline_options, tag) {
    var el = line.getElementsByTagName(tag);
    if (!el.length) return [];

    var coords = [];
    var markers = [];
    var layers = [];
    var last = null;

    for (var i = 0; i < el.length; i++) {
      var _, ll = new L.LatLng(
        el[i].getAttribute('lat'),
        el[i].getAttribute('lon'));
      ll.meta = { time: null, ele: null, hr: null, cad: null, atemp: null, speed: null };

      _ = el[i].getElementsByTagName('time');
      if (_.length > 0) {
        ll.meta.time = new Date(Date.parse(_[0].textContent));
      } else {
        ll.meta.time = new Date('1970-01-01T00:00:00');
      }
      var time_diff = last != null ? Math.abs(ll.meta.time - last.meta.time) : 0;

      _ = el[i].getElementsByTagName('ele');
      if (_.length > 0) {
        ll.meta.ele = parseFloat(_[0].textContent);
      } else {
        // If the point doesn't have an <ele> tag, assume it has the same
        // elevation as the point before it (if it had one).
        ll.meta.ele = last != null ? last.meta.ele : null;
      }
      var ele_diff = last != null ? ll.meta.ele - last.meta.ele : 0;
      var dist_3d = last != null ? this._dist3d(last, ll) : 0;

      _ = el[i].getElementsByTagName('speed');
      if (_.length > 0) {
        ll.meta.speed = parseFloat(_[0].textContent);
      } else {
        // speed in meter per second
        ll.meta.speed = time_diff > 0 ? 1000.0 * dist_3d / time_diff : 0;
      }

      _ = el[i].getElementsByTagName('name');
      if (_.length > 0) {
        var name = _[0].textContent;
        var ptMatchers = options.marker_options.pointMatchers || [];

        for (var j = 0; j < ptMatchers.length; j++) {
          if (ptMatchers[j].regex.test(name)) {
            markers.push({ label: name, coords: ll, icon: ptMatchers[j].icon, element: el[i] });
            break;
          }
        }
      }

      _ = el[i].getElementsByTagNameNS('*', 'hr');
      if (_.length > 0) {
        ll.meta.hr = parseInt(_[0].textContent);
        this._info.hr._points.push([this._info.length, ll.meta.hr]);
        this._info.hr._total += ll.meta.hr;
      }

      _ = el[i].getElementsByTagNameNS('*', 'cad');
      if (_.length > 0) {
        ll.meta.cad = parseInt(_[0].textContent);
        this._info.cad._points.push([this._info.length, ll.meta.cad]);
        this._info.cad._total += ll.meta.cad;
      }

      _ = el[i].getElementsByTagNameNS('*', 'atemp');
      if (_.length > 0) {
        ll.meta.atemp = parseInt(_[0].textContent);
        this._info.atemp._points.push([this._info.length, ll.meta.atemp]);
        this._info.atemp._total += ll.meta.atemp;
      }

      if (ll.meta.ele > this._info.elevation.max) {
        this._info.elevation.max = ll.meta.ele;
      }
      if (ll.meta.ele < this._info.elevation.min) {
        this._info.elevation.min = ll.meta.ele;
      }
      this._info.elevation._points.push([this._info.length, ll.meta.ele]);

      if (ll.meta.speed > this._info.speed.max) {
        this._info.speed.max = ll.meta.speed;
      }
      this._info.speed._points.push([this._info.length, ll.meta.speed]);

      if ((last == null) && (this._info.duration.start == null)) {
        this._info.duration.start = ll.meta.time;
      }
      this._info.duration.end = ll.meta.time;
      this._info.duration.total += time_diff;
      if (time_diff < options.max_point_interval) {
        this._info.duration.moving += time_diff;
      }

      this._info.length += dist_3d;

      if (ele_diff > 0) {
        this._info.elevation.gain += ele_diff;
      } else {
        this._info.elevation.loss += Math.abs(ele_diff);
      }

      last = ll;
      coords.push(ll);
    }

    // add track
    var l = new L.Polyline(coords, this._extract_styling(line, polyline_options, options.polyline_options));
    this.fire('addline', { line: l, element: line });
    layers.push(l);

    if (options.marker_options.startIcon || options.marker_options.startIconUrl) {
      // add start pin
      var marker = new L.Marker(coords[0], {
        clickable: options.marker_options.clickable,
        icon: options.marker_options.startIcon || new L.GPXTrackIcon({iconUrl: options.marker_options.startIconUrl})
      });
      this.fire('addpoint', { point: marker, point_type: 'start', element: el[0] });
      layers.push(marker);
    }

    if (options.marker_options.endIcon || options.marker_options.endIconUrl) {
      // add end pin
      var marker = new L.Marker(coords[coords.length-1], {
        clickable: options.marker_options.clickable,
        icon: options.marker_options.endIcon || new L.GPXTrackIcon({iconUrl: options.marker_options.endIconUrl})
      });
      this.fire('addpoint', { point: marker, point_type: 'end', element: el[el.length-1] });
      layers.push(marker);
    }

    // add named markers
    for (var i = 0; i < markers.length; i++) {
      var marker = new L.Marker(markers[i].coords, {
        clickable: options.marker_options.clickable,
        title: markers[i].label,
        icon: markers[i].icon
      });
      this.fire('addpoint', { point: marker, point_type: 'label', element: markers[i].element });
      layers.push(marker);
    }

    return layers;
  },

  _extract_styling: function(el, base, overrides) {
    var style = this._merge_objs(_DEFAULT_POLYLINE_OPTS, base);
    var e = el.getElementsByTagNameNS(_GPX_STYLE_NS, 'line');
    if (e.length > 0) {
      var _ = e[0].getElementsByTagName('color');
      if (_.length > 0) style.color = '#' + _[0].textContent;
      var _ = e[0].getElementsByTagName('opacity');
      if (_.length > 0) style.opacity = _[0].textContent;
      var _ = e[0].getElementsByTagName('weight');
      if (_.length > 0) style.weight = _[0].textContent;
      var _ = e[0].getElementsByTagName('linecap');
      if (_.length > 0) style.lineCap = _[0].textContent;
      var _ = e[0].getElementsByTagName('linejoin');
      if (_.length > 0) style.lineJoin = _[0].textContent;
      var _ = e[0].getElementsByTagName('dasharray');
      if (_.length > 0) style.dashArray = _[0].textContent;
      var _ = e[0].getElementsByTagName('dashoffset');
      if (_.length > 0) style.dashOffset = _[0].textContent;
    }
    return this._merge_objs(style, overrides)
  },

  _dist2d: function(a, b) {
    var R = 6371000;
    var dLat = this._deg2rad(b.lat - a.lat);
    var dLon = this._deg2rad(b.lng - a.lng);
    var r = Math.sin(dLat/2) *
      Math.sin(dLat/2) +
      Math.cos(this._deg2rad(a.lat)) *
      Math.cos(this._deg2rad(b.lat)) *
      Math.sin(dLon/2) *
      Math.sin(dLon/2);
    var c = 2 * Math.atan2(Math.sqrt(r), Math.sqrt(1-r));
    var d = R * c;
    return d;
  },

  _dist3d: function(a, b) {
    var planar = this._dist2d(a, b);
    var height = Math.abs(b.meta.ele - a.meta.ele);
    return Math.sqrt(Math.pow(planar, 2) + Math.pow(height, 2));
  },

  _deg2rad: function(deg) {
    return deg * Math.PI / 180;
  }
});

/* inline — L.GPX already attached to window.L */

    </script>
    <!-- QR-Code Generator (qrcode-generator 1.4.4) — inline, kein CDN -->
    <script>
//---------------------------------------------------------------------
//
// QR Code Generator for JavaScript
//
// Copyright (c) 2009 Kazuhiko Arase
//
// URL: http://www.d-project.com/
//
// Licensed under the MIT license:
//  http://www.opensource.org/licenses/mit-license.php
//
// The word 'QR Code' is registered trademark of
// DENSO WAVE INCORPORATED
//  http://www.denso-wave.com/qrcode/faqpatent-e.html
//
//---------------------------------------------------------------------

var qrcode = function() {

  //---------------------------------------------------------------------
  // qrcode
  //---------------------------------------------------------------------

  /**
   * qrcode
   * @param typeNumber 1 to 40
   * @param errorCorrectionLevel 'L','M','Q','H'
   */
  var qrcode = function(typeNumber, errorCorrectionLevel) {

    var PAD0 = 0xEC;
    var PAD1 = 0x11;

    var _typeNumber = typeNumber;
    var _errorCorrectionLevel = QRErrorCorrectionLevel[errorCorrectionLevel];
    var _modules = null;
    var _moduleCount = 0;
    var _dataCache = null;
    var _dataList = [];

    var _this = {};

    var makeImpl = function(test, maskPattern) {

      _moduleCount = _typeNumber * 4 + 17;
      _modules = function(moduleCount) {
        var modules = new Array(moduleCount);
        for (var row = 0; row < moduleCount; row += 1) {
          modules[row] = new Array(moduleCount);
          for (var col = 0; col < moduleCount; col += 1) {
            modules[row][col] = null;
          }
        }
        return modules;
      }(_moduleCount);

      setupPositionProbePattern(0, 0);
      setupPositionProbePattern(_moduleCount - 7, 0);
      setupPositionProbePattern(0, _moduleCount - 7);
      setupPositionAdjustPattern();
      setupTimingPattern();
      setupTypeInfo(test, maskPattern);

      if (_typeNumber >= 7) {
        setupTypeNumber(test);
      }

      if (_dataCache == null) {
        _dataCache = createData(_typeNumber, _errorCorrectionLevel, _dataList);
      }

      mapData(_dataCache, maskPattern);
    };

    var setupPositionProbePattern = function(row, col) {

      for (var r = -1; r <= 7; r += 1) {

        if (row + r <= -1 || _moduleCount <= row + r) continue;

        for (var c = -1; c <= 7; c += 1) {

          if (col + c <= -1 || _moduleCount <= col + c) continue;

          if ( (0 <= r && r <= 6 && (c == 0 || c == 6) )
              || (0 <= c && c <= 6 && (r == 0 || r == 6) )
              || (2 <= r && r <= 4 && 2 <= c && c <= 4) ) {
            _modules[row + r][col + c] = true;
          } else {
            _modules[row + r][col + c] = false;
          }
        }
      }
    };

    var getBestMaskPattern = function() {

      var minLostPoint = 0;
      var pattern = 0;

      for (var i = 0; i < 8; i += 1) {

        makeImpl(true, i);

        var lostPoint = QRUtil.getLostPoint(_this);

        if (i == 0 || minLostPoint > lostPoint) {
          minLostPoint = lostPoint;
          pattern = i;
        }
      }

      return pattern;
    };

    var setupTimingPattern = function() {

      for (var r = 8; r < _moduleCount - 8; r += 1) {
        if (_modules[r][6] != null) {
          continue;
        }
        _modules[r][6] = (r % 2 == 0);
      }

      for (var c = 8; c < _moduleCount - 8; c += 1) {
        if (_modules[6][c] != null) {
          continue;
        }
        _modules[6][c] = (c % 2 == 0);
      }
    };

    var setupPositionAdjustPattern = function() {

      var pos = QRUtil.getPatternPosition(_typeNumber);

      for (var i = 0; i < pos.length; i += 1) {

        for (var j = 0; j < pos.length; j += 1) {

          var row = pos[i];
          var col = pos[j];

          if (_modules[row][col] != null) {
            continue;
          }

          for (var r = -2; r <= 2; r += 1) {

            for (var c = -2; c <= 2; c += 1) {

              if (r == -2 || r == 2 || c == -2 || c == 2
                  || (r == 0 && c == 0) ) {
                _modules[row + r][col + c] = true;
              } else {
                _modules[row + r][col + c] = false;
              }
            }
          }
        }
      }
    };

    var setupTypeNumber = function(test) {

      var bits = QRUtil.getBCHTypeNumber(_typeNumber);

      for (var i = 0; i < 18; i += 1) {
        var mod = (!test && ( (bits >> i) & 1) == 1);
        _modules[Math.floor(i / 3)][i % 3 + _moduleCount - 8 - 3] = mod;
      }

      for (var i = 0; i < 18; i += 1) {
        var mod = (!test && ( (bits >> i) & 1) == 1);
        _modules[i % 3 + _moduleCount - 8 - 3][Math.floor(i / 3)] = mod;
      }
    };

    var setupTypeInfo = function(test, maskPattern) {

      var data = (_errorCorrectionLevel << 3) | maskPattern;
      var bits = QRUtil.getBCHTypeInfo(data);

      // vertical
      for (var i = 0; i < 15; i += 1) {

        var mod = (!test && ( (bits >> i) & 1) == 1);

        if (i < 6) {
          _modules[i][8] = mod;
        } else if (i < 8) {
          _modules[i + 1][8] = mod;
        } else {
          _modules[_moduleCount - 15 + i][8] = mod;
        }
      }

      // horizontal
      for (var i = 0; i < 15; i += 1) {

        var mod = (!test && ( (bits >> i) & 1) == 1);

        if (i < 8) {
          _modules[8][_moduleCount - i - 1] = mod;
        } else if (i < 9) {
          _modules[8][15 - i - 1 + 1] = mod;
        } else {
          _modules[8][15 - i - 1] = mod;
        }
      }

      // fixed module
      _modules[_moduleCount - 8][8] = (!test);
    };

    var mapData = function(data, maskPattern) {

      var inc = -1;
      var row = _moduleCount - 1;
      var bitIndex = 7;
      var byteIndex = 0;
      var maskFunc = QRUtil.getMaskFunction(maskPattern);

      for (var col = _moduleCount - 1; col > 0; col -= 2) {

        if (col == 6) col -= 1;

        while (true) {

          for (var c = 0; c < 2; c += 1) {

            if (_modules[row][col - c] == null) {

              var dark = false;

              if (byteIndex < data.length) {
                dark = ( ( (data[byteIndex] >>> bitIndex) & 1) == 1);
              }

              var mask = maskFunc(row, col - c);

              if (mask) {
                dark = !dark;
              }

              _modules[row][col - c] = dark;
              bitIndex -= 1;

              if (bitIndex == -1) {
                byteIndex += 1;
                bitIndex = 7;
              }
            }
          }

          row += inc;

          if (row < 0 || _moduleCount <= row) {
            row -= inc;
            inc = -inc;
            break;
          }
        }
      }
    };

    var createBytes = function(buffer, rsBlocks) {

      var offset = 0;

      var maxDcCount = 0;
      var maxEcCount = 0;

      var dcdata = new Array(rsBlocks.length);
      var ecdata = new Array(rsBlocks.length);

      for (var r = 0; r < rsBlocks.length; r += 1) {

        var dcCount = rsBlocks[r].dataCount;
        var ecCount = rsBlocks[r].totalCount - dcCount;

        maxDcCount = Math.max(maxDcCount, dcCount);
        maxEcCount = Math.max(maxEcCount, ecCount);

        dcdata[r] = new Array(dcCount);

        for (var i = 0; i < dcdata[r].length; i += 1) {
          dcdata[r][i] = 0xff & buffer.getBuffer()[i + offset];
        }
        offset += dcCount;

        var rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);
        var rawPoly = qrPolynomial(dcdata[r], rsPoly.getLength() - 1);

        var modPoly = rawPoly.mod(rsPoly);
        ecdata[r] = new Array(rsPoly.getLength() - 1);
        for (var i = 0; i < ecdata[r].length; i += 1) {
          var modIndex = i + modPoly.getLength() - ecdata[r].length;
          ecdata[r][i] = (modIndex >= 0)? modPoly.getAt(modIndex) : 0;
        }
      }

      var totalCodeCount = 0;
      for (var i = 0; i < rsBlocks.length; i += 1) {
        totalCodeCount += rsBlocks[i].totalCount;
      }

      var data = new Array(totalCodeCount);
      var index = 0;

      for (var i = 0; i < maxDcCount; i += 1) {
        for (var r = 0; r < rsBlocks.length; r += 1) {
          if (i < dcdata[r].length) {
            data[index] = dcdata[r][i];
            index += 1;
          }
        }
      }

      for (var i = 0; i < maxEcCount; i += 1) {
        for (var r = 0; r < rsBlocks.length; r += 1) {
          if (i < ecdata[r].length) {
            data[index] = ecdata[r][i];
            index += 1;
          }
        }
      }

      return data;
    };

    var createData = function(typeNumber, errorCorrectionLevel, dataList) {

      var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectionLevel);

      var buffer = qrBitBuffer();

      for (var i = 0; i < dataList.length; i += 1) {
        var data = dataList[i];
        buffer.put(data.getMode(), 4);
        buffer.put(data.getLength(), QRUtil.getLengthInBits(data.getMode(), typeNumber) );
        data.write(buffer);
      }

      // calc num max data.
      var totalDataCount = 0;
      for (var i = 0; i < rsBlocks.length; i += 1) {
        totalDataCount += rsBlocks[i].dataCount;
      }

      if (buffer.getLengthInBits() > totalDataCount * 8) {
        throw 'code length overflow. ('
          + buffer.getLengthInBits()
          + '>'
          + totalDataCount * 8
          + ')';
      }

      // end code
      if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {
        buffer.put(0, 4);
      }

      // padding
      while (buffer.getLengthInBits() % 8 != 0) {
        buffer.putBit(false);
      }

      // padding
      while (true) {

        if (buffer.getLengthInBits() >= totalDataCount * 8) {
          break;
        }
        buffer.put(PAD0, 8);

        if (buffer.getLengthInBits() >= totalDataCount * 8) {
          break;
        }
        buffer.put(PAD1, 8);
      }

      return createBytes(buffer, rsBlocks);
    };

    _this.addData = function(data, mode) {

      mode = mode || 'Byte';

      var newData = null;

      switch(mode) {
      case 'Numeric' :
        newData = qrNumber(data);
        break;
      case 'Alphanumeric' :
        newData = qrAlphaNum(data);
        break;
      case 'Byte' :
        newData = qr8BitByte(data);
        break;
      case 'Kanji' :
        newData = qrKanji(data);
        break;
      default :
        throw 'mode:' + mode;
      }

      _dataList.push(newData);
      _dataCache = null;
    };

    _this.isDark = function(row, col) {
      if (row < 0 || _moduleCount <= row || col < 0 || _moduleCount <= col) {
        throw row + ',' + col;
      }
      return _modules[row][col];
    };

    _this.getModuleCount = function() {
      return _moduleCount;
    };

    _this.make = function() {
      if (_typeNumber < 1) {
        var typeNumber = 1;

        for (; typeNumber < 40; typeNumber++) {
          var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, _errorCorrectionLevel);
          var buffer = qrBitBuffer();

          for (var i = 0; i < _dataList.length; i++) {
            var data = _dataList[i];
            buffer.put(data.getMode(), 4);
            buffer.put(data.getLength(), QRUtil.getLengthInBits(data.getMode(), typeNumber) );
            data.write(buffer);
          }

          var totalDataCount = 0;
          for (var i = 0; i < rsBlocks.length; i++) {
            totalDataCount += rsBlocks[i].dataCount;
          }

          if (buffer.getLengthInBits() <= totalDataCount * 8) {
            break;
          }
        }

        _typeNumber = typeNumber;
      }

      makeImpl(false, getBestMaskPattern() );
    };

    _this.createTableTag = function(cellSize, margin) {

      cellSize = cellSize || 2;
      margin = (typeof margin == 'undefined')? cellSize * 4 : margin;

      var qrHtml = '';

      qrHtml += '<table style="';
      qrHtml += ' border-width: 0px; border-style: none;';
      qrHtml += ' border-collapse: collapse;';
      qrHtml += ' padding: 0px; margin: ' + margin + 'px;';
      qrHtml += '">';
      qrHtml += '<tbody>';

      for (var r = 0; r < _this.getModuleCount(); r += 1) {

        qrHtml += '<tr>';

        for (var c = 0; c < _this.getModuleCount(); c += 1) {
          qrHtml += '<td style="';
          qrHtml += ' border-width: 0px; border-style: none;';
          qrHtml += ' border-collapse: collapse;';
          qrHtml += ' padding: 0px; margin: 0px;';
          qrHtml += ' width: ' + cellSize + 'px;';
          qrHtml += ' height: ' + cellSize + 'px;';
          qrHtml += ' background-color: ';
          qrHtml += _this.isDark(r, c)? '#000000' : '#ffffff';
          qrHtml += ';';
          qrHtml += '"/>';
        }

        qrHtml += '</tr>';
      }

      qrHtml += '</tbody>';
      qrHtml += '</table>';

      return qrHtml;
    };

    _this.createSvgTag = function(cellSize, margin, alt, title) {

      var opts = {};
      if (typeof arguments[0] == 'object') {
        // Called by options.
        opts = arguments[0];
        // overwrite cellSize and margin.
        cellSize = opts.cellSize;
        margin = opts.margin;
        alt = opts.alt;
        title = opts.title;
      }

      cellSize = cellSize || 2;
      margin = (typeof margin == 'undefined')? cellSize * 4 : margin;

      // Compose alt property surrogate
      alt = (typeof alt === 'string') ? {text: alt} : alt || {};
      alt.text = alt.text || null;
      alt.id = (alt.text) ? alt.id || 'qrcode-description' : null;

      // Compose title property surrogate
      title = (typeof title === 'string') ? {text: title} : title || {};
      title.text = title.text || null;
      title.id = (title.text) ? title.id || 'qrcode-title' : null;

      var size = _this.getModuleCount() * cellSize + margin * 2;
      var c, mc, r, mr, qrSvg='', rect;

      rect = 'l' + cellSize + ',0 0,' + cellSize +
        ' -' + cellSize + ',0 0,-' + cellSize + 'z ';

      qrSvg += '<svg version="1.1" xmlns="http://www.w3.org/2000/svg"';
      qrSvg += !opts.scalable ? ' width="' + size + 'px" height="' + size + 'px"' : '';
      qrSvg += ' viewBox="0 0 ' + size + ' ' + size + '" ';
      qrSvg += ' preserveAspectRatio="xMinYMin meet"';
      qrSvg += (title.text || alt.text) ? ' role="img" aria-labelledby="' +
          escapeXml([title.id, alt.id].join(' ').trim() ) + '"' : '';
      qrSvg += '>';
      qrSvg += (title.text) ? '<title id="' + escapeXml(title.id) + '">' +
          escapeXml(title.text) + '</title>' : '';
      qrSvg += (alt.text) ? '<description id="' + escapeXml(alt.id) + '">' +
          escapeXml(alt.text) + '</description>' : '';
      qrSvg += '<rect width="100%" height="100%" fill="white" cx="0" cy="0"/>';
      qrSvg += '<path d="';

      for (r = 0; r < _this.getModuleCount(); r += 1) {
        mr = r * cellSize + margin;
        for (c = 0; c < _this.getModuleCount(); c += 1) {
          if (_this.isDark(r, c) ) {
            mc = c*cellSize+margin;
            qrSvg += 'M' + mc + ',' + mr + rect;
          }
        }
      }

      qrSvg += '" stroke="transparent" fill="black"/>';
      qrSvg += '</svg>';

      return qrSvg;
    };

    _this.createDataURL = function(cellSize, margin) {

      cellSize = cellSize || 2;
      margin = (typeof margin == 'undefined')? cellSize * 4 : margin;

      var size = _this.getModuleCount() * cellSize + margin * 2;
      var min = margin;
      var max = size - margin;

      return createDataURL(size, size, function(x, y) {
        if (min <= x && x < max && min <= y && y < max) {
          var c = Math.floor( (x - min) / cellSize);
          var r = Math.floor( (y - min) / cellSize);
          return _this.isDark(r, c)? 0 : 1;
        } else {
          return 1;
        }
      } );
    };

    _this.createImgTag = function(cellSize, margin, alt) {

      cellSize = cellSize || 2;
      margin = (typeof margin == 'undefined')? cellSize * 4 : margin;

      var size = _this.getModuleCount() * cellSize + margin * 2;

      var img = '';
      img += '<img';
      img += '\u0020src="';
      img += _this.createDataURL(cellSize, margin);
      img += '"';
      img += '\u0020width="';
      img += size;
      img += '"';
      img += '\u0020height="';
      img += size;
      img += '"';
      if (alt) {
        img += '\u0020alt="';
        img += escapeXml(alt);
        img += '"';
      }
      img += '/>';

      return img;
    };

    var escapeXml = function(s) {
      var escaped = '';
      for (var i = 0; i < s.length; i += 1) {
        var c = s.charAt(i);
        switch(c) {
        case '<': escaped += '&lt;'; break;
        case '>': escaped += '&gt;'; break;
        case '&': escaped += '&amp;'; break;
        case '"': escaped += '&quot;'; break;
        default : escaped += c; break;
        }
      }
      return escaped;
    };

    var _createHalfASCII = function(margin) {
      var cellSize = 1;
      margin = (typeof margin == 'undefined')? cellSize * 2 : margin;

      var size = _this.getModuleCount() * cellSize + margin * 2;
      var min = margin;
      var max = size - margin;

      var y, x, r1, r2, p;

      var blocks = {
        '██': '█',
        '█ ': '▀',
        ' █': '▄',
        '  ': ' '
      };

      var blocksLastLineNoMargin = {
        '██': '▀',
        '█ ': '▀',
        ' █': ' ',
        '  ': ' '
      };

      var ascii = '';
      for (y = 0; y < size; y += 2) {
        r1 = Math.floor((y - min) / cellSize);
        r2 = Math.floor((y + 1 - min) / cellSize);
        for (x = 0; x < size; x += 1) {
          p = '█';

          if (min <= x && x < max && min <= y && y < max && _this.isDark(r1, Math.floor((x - min) / cellSize))) {
            p = ' ';
          }

          if (min <= x && x < max && min <= y+1 && y+1 < max && _this.isDark(r2, Math.floor((x - min) / cellSize))) {
            p += ' ';
          }
          else {
            p += '█';
          }

          // Output 2 characters per pixel, to create full square. 1 character per pixels gives only half width of square.
          ascii += (margin < 1 && y+1 >= max) ? blocksLastLineNoMargin[p] : blocks[p];
        }

        ascii += '\n';
      }

      if (size % 2 && margin > 0) {
        return ascii.substring(0, ascii.length - size - 1) + Array(size+1).join('▀');
      }

      return ascii.substring(0, ascii.length-1);
    };

    _this.createASCII = function(cellSize, margin) {
      cellSize = cellSize || 1;

      if (cellSize < 2) {
        return _createHalfASCII(margin);
      }

      cellSize -= 1;
      margin = (typeof margin == 'undefined')? cellSize * 2 : margin;

      var size = _this.getModuleCount() * cellSize + margin * 2;
      var min = margin;
      var max = size - margin;

      var y, x, r, p;

      var white = Array(cellSize+1).join('██');
      var black = Array(cellSize+1).join('  ');

      var ascii = '';
      var line = '';
      for (y = 0; y < size; y += 1) {
        r = Math.floor( (y - min) / cellSize);
        line = '';
        for (x = 0; x < size; x += 1) {
          p = 1;

          if (min <= x && x < max && min <= y && y < max && _this.isDark(r, Math.floor((x - min) / cellSize))) {
            p = 0;
          }

          // Output 2 characters per pixel, to create full square. 1 character per pixels gives only half width of square.
          line += p ? white : black;
        }

        for (r = 0; r < cellSize; r += 1) {
          ascii += line + '\n';
        }
      }

      return ascii.substring(0, ascii.length-1);
    };

    _this.renderTo2dContext = function(context, cellSize) {
      cellSize = cellSize || 2;
      var length = _this.getModuleCount();
      for (var row = 0; row < length; row++) {
        for (var col = 0; col < length; col++) {
          context.fillStyle = _this.isDark(row, col) ? 'black' : 'white';
          context.fillRect(row * cellSize, col * cellSize, cellSize, cellSize);
        }
      }
    }

    return _this;
  };

  //---------------------------------------------------------------------
  // qrcode.stringToBytes
  //---------------------------------------------------------------------

  qrcode.stringToBytesFuncs = {
    'default' : function(s) {
      var bytes = [];
      for (var i = 0; i < s.length; i += 1) {
        var c = s.charCodeAt(i);
        bytes.push(c & 0xff);
      }
      return bytes;
    }
  };

  qrcode.stringToBytes = qrcode.stringToBytesFuncs['default'];

  //---------------------------------------------------------------------
  // qrcode.createStringToBytes
  //---------------------------------------------------------------------

  /**
   * @param unicodeData base64 string of byte array.
   * [16bit Unicode],[16bit Bytes], ...
   * @param numChars
   */
  qrcode.createStringToBytes = function(unicodeData, numChars) {

    // create conversion map.

    var unicodeMap = function() {

      var bin = base64DecodeInputStream(unicodeData);
      var read = function() {
        var b = bin.read();
        if (b == -1) throw 'eof';
        return b;
      };

      var count = 0;
      var unicodeMap = {};
      while (true) {
        var b0 = bin.read();
        if (b0 == -1) break;
        var b1 = read();
        var b2 = read();
        var b3 = read();
        var k = String.fromCharCode( (b0 << 8) | b1);
        var v = (b2 << 8) | b3;
        unicodeMap[k] = v;
        count += 1;
      }
      if (count != numChars) {
        throw count + ' != ' + numChars;
      }

      return unicodeMap;
    }();

    var unknownChar = '?'.charCodeAt(0);

    return function(s) {
      var bytes = [];
      for (var i = 0; i < s.length; i += 1) {
        var c = s.charCodeAt(i);
        if (c < 128) {
          bytes.push(c);
        } else {
          var b = unicodeMap[s.charAt(i)];
          if (typeof b == 'number') {
            if ( (b & 0xff) == b) {
              // 1byte
              bytes.push(b);
            } else {
              // 2bytes
              bytes.push(b >>> 8);
              bytes.push(b & 0xff);
            }
          } else {
            bytes.push(unknownChar);
          }
        }
      }
      return bytes;
    };
  };

  //---------------------------------------------------------------------
  // QRMode
  //---------------------------------------------------------------------

  var QRMode = {
    MODE_NUMBER :    1 << 0,
    MODE_ALPHA_NUM : 1 << 1,
    MODE_8BIT_BYTE : 1 << 2,
    MODE_KANJI :     1 << 3
  };

  //---------------------------------------------------------------------
  // QRErrorCorrectionLevel
  //---------------------------------------------------------------------

  var QRErrorCorrectionLevel = {
    L : 1,
    M : 0,
    Q : 3,
    H : 2
  };

  //---------------------------------------------------------------------
  // QRMaskPattern
  //---------------------------------------------------------------------

  var QRMaskPattern = {
    PATTERN000 : 0,
    PATTERN001 : 1,
    PATTERN010 : 2,
    PATTERN011 : 3,
    PATTERN100 : 4,
    PATTERN101 : 5,
    PATTERN110 : 6,
    PATTERN111 : 7
  };

  //---------------------------------------------------------------------
  // QRUtil
  //---------------------------------------------------------------------

  var QRUtil = function() {

    var PATTERN_POSITION_TABLE = [
      [],
      [6, 18],
      [6, 22],
      [6, 26],
      [6, 30],
      [6, 34],
      [6, 22, 38],
      [6, 24, 42],
      [6, 26, 46],
      [6, 28, 50],
      [6, 30, 54],
      [6, 32, 58],
      [6, 34, 62],
      [6, 26, 46, 66],
      [6, 26, 48, 70],
      [6, 26, 50, 74],
      [6, 30, 54, 78],
      [6, 30, 56, 82],
      [6, 30, 58, 86],
      [6, 34, 62, 90],
      [6, 28, 50, 72, 94],
      [6, 26, 50, 74, 98],
      [6, 30, 54, 78, 102],
      [6, 28, 54, 80, 106],
      [6, 32, 58, 84, 110],
      [6, 30, 58, 86, 114],
      [6, 34, 62, 90, 118],
      [6, 26, 50, 74, 98, 122],
      [6, 30, 54, 78, 102, 126],
      [6, 26, 52, 78, 104, 130],
      [6, 30, 56, 82, 108, 134],
      [6, 34, 60, 86, 112, 138],
      [6, 30, 58, 86, 114, 142],
      [6, 34, 62, 90, 118, 146],
      [6, 30, 54, 78, 102, 126, 150],
      [6, 24, 50, 76, 102, 128, 154],
      [6, 28, 54, 80, 106, 132, 158],
      [6, 32, 58, 84, 110, 136, 162],
      [6, 26, 54, 82, 110, 138, 166],
      [6, 30, 58, 86, 114, 142, 170]
    ];
    var G15 = (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0);
    var G18 = (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0);
    var G15_MASK = (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1);

    var _this = {};

    var getBCHDigit = function(data) {
      var digit = 0;
      while (data != 0) {
        digit += 1;
        data >>>= 1;
      }
      return digit;
    };

    _this.getBCHTypeInfo = function(data) {
      var d = data << 10;
      while (getBCHDigit(d) - getBCHDigit(G15) >= 0) {
        d ^= (G15 << (getBCHDigit(d) - getBCHDigit(G15) ) );
      }
      return ( (data << 10) | d) ^ G15_MASK;
    };

    _this.getBCHTypeNumber = function(data) {
      var d = data << 12;
      while (getBCHDigit(d) - getBCHDigit(G18) >= 0) {
        d ^= (G18 << (getBCHDigit(d) - getBCHDigit(G18) ) );
      }
      return (data << 12) | d;
    };

    _this.getPatternPosition = function(typeNumber) {
      return PATTERN_POSITION_TABLE[typeNumber - 1];
    };

    _this.getMaskFunction = function(maskPattern) {

      switch (maskPattern) {

      case QRMaskPattern.PATTERN000 :
        return function(i, j) { return (i + j) % 2 == 0; };
      case QRMaskPattern.PATTERN001 :
        return function(i, j) { return i % 2 == 0; };
      case QRMaskPattern.PATTERN010 :
        return function(i, j) { return j % 3 == 0; };
      case QRMaskPattern.PATTERN011 :
        return function(i, j) { return (i + j) % 3 == 0; };
      case QRMaskPattern.PATTERN100 :
        return function(i, j) { return (Math.floor(i / 2) + Math.floor(j / 3) ) % 2 == 0; };
      case QRMaskPattern.PATTERN101 :
        return function(i, j) { return (i * j) % 2 + (i * j) % 3 == 0; };
      case QRMaskPattern.PATTERN110 :
        return function(i, j) { return ( (i * j) % 2 + (i * j) % 3) % 2 == 0; };
      case QRMaskPattern.PATTERN111 :
        return function(i, j) { return ( (i * j) % 3 + (i + j) % 2) % 2 == 0; };

      default :
        throw 'bad maskPattern:' + maskPattern;
      }
    };

    _this.getErrorCorrectPolynomial = function(errorCorrectLength) {
      var a = qrPolynomial([1], 0);
      for (var i = 0; i < errorCorrectLength; i += 1) {
        a = a.multiply(qrPolynomial([1, QRMath.gexp(i)], 0) );
      }
      return a;
    };

    _this.getLengthInBits = function(mode, type) {

      if (1 <= type && type < 10) {

        // 1 - 9

        switch(mode) {
        case QRMode.MODE_NUMBER    : return 10;
        case QRMode.MODE_ALPHA_NUM : return 9;
        case QRMode.MODE_8BIT_BYTE : return 8;
        case QRMode.MODE_KANJI     : return 8;
        default :
          throw 'mode:' + mode;
        }

      } else if (type < 27) {

        // 10 - 26

        switch(mode) {
        case QRMode.MODE_NUMBER    : return 12;
        case QRMode.MODE_ALPHA_NUM : return 11;
        case QRMode.MODE_8BIT_BYTE : return 16;
        case QRMode.MODE_KANJI     : return 10;
        default :
          throw 'mode:' + mode;
        }

      } else if (type < 41) {

        // 27 - 40

        switch(mode) {
        case QRMode.MODE_NUMBER    : return 14;
        case QRMode.MODE_ALPHA_NUM : return 13;
        case QRMode.MODE_8BIT_BYTE : return 16;
        case QRMode.MODE_KANJI     : return 12;
        default :
          throw 'mode:' + mode;
        }

      } else {
        throw 'type:' + type;
      }
    };

    _this.getLostPoint = function(qrcode) {

      var moduleCount = qrcode.getModuleCount();

      var lostPoint = 0;

      // LEVEL1

      for (var row = 0; row < moduleCount; row += 1) {
        for (var col = 0; col < moduleCount; col += 1) {

          var sameCount = 0;
          var dark = qrcode.isDark(row, col);

          for (var r = -1; r <= 1; r += 1) {

            if (row + r < 0 || moduleCount <= row + r) {
              continue;
            }

            for (var c = -1; c <= 1; c += 1) {

              if (col + c < 0 || moduleCount <= col + c) {
                continue;
              }

              if (r == 0 && c == 0) {
                continue;
              }

              if (dark == qrcode.isDark(row + r, col + c) ) {
                sameCount += 1;
              }
            }
          }

          if (sameCount > 5) {
            lostPoint += (3 + sameCount - 5);
          }
        }
      };

      // LEVEL2

      for (var row = 0; row < moduleCount - 1; row += 1) {
        for (var col = 0; col < moduleCount - 1; col += 1) {
          var count = 0;
          if (qrcode.isDark(row, col) ) count += 1;
          if (qrcode.isDark(row + 1, col) ) count += 1;
          if (qrcode.isDark(row, col + 1) ) count += 1;
          if (qrcode.isDark(row + 1, col + 1) ) count += 1;
          if (count == 0 || count == 4) {
            lostPoint += 3;
          }
        }
      }

      // LEVEL3

      for (var row = 0; row < moduleCount; row += 1) {
        for (var col = 0; col < moduleCount - 6; col += 1) {
          if (qrcode.isDark(row, col)
              && !qrcode.isDark(row, col + 1)
              &&  qrcode.isDark(row, col + 2)
              &&  qrcode.isDark(row, col + 3)
              &&  qrcode.isDark(row, col + 4)
              && !qrcode.isDark(row, col + 5)
              &&  qrcode.isDark(row, col + 6) ) {
            lostPoint += 40;
          }
        }
      }

      for (var col = 0; col < moduleCount; col += 1) {
        for (var row = 0; row < moduleCount - 6; row += 1) {
          if (qrcode.isDark(row, col)
              && !qrcode.isDark(row + 1, col)
              &&  qrcode.isDark(row + 2, col)
              &&  qrcode.isDark(row + 3, col)
              &&  qrcode.isDark(row + 4, col)
              && !qrcode.isDark(row + 5, col)
              &&  qrcode.isDark(row + 6, col) ) {
            lostPoint += 40;
          }
        }
      }

      // LEVEL4

      var darkCount = 0;

      for (var col = 0; col < moduleCount; col += 1) {
        for (var row = 0; row < moduleCount; row += 1) {
          if (qrcode.isDark(row, col) ) {
            darkCount += 1;
          }
        }
      }

      var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
      lostPoint += ratio * 10;

      return lostPoint;
    };

    return _this;
  }();

  //---------------------------------------------------------------------
  // QRMath
  //---------------------------------------------------------------------

  var QRMath = function() {

    var EXP_TABLE = new Array(256);
    var LOG_TABLE = new Array(256);

    // initialize tables
    for (var i = 0; i < 8; i += 1) {
      EXP_TABLE[i] = 1 << i;
    }
    for (var i = 8; i < 256; i += 1) {
      EXP_TABLE[i] = EXP_TABLE[i - 4]
        ^ EXP_TABLE[i - 5]
        ^ EXP_TABLE[i - 6]
        ^ EXP_TABLE[i - 8];
    }
    for (var i = 0; i < 255; i += 1) {
      LOG_TABLE[EXP_TABLE[i] ] = i;
    }

    var _this = {};

    _this.glog = function(n) {

      if (n < 1) {
        throw 'glog(' + n + ')';
      }

      return LOG_TABLE[n];
    };

    _this.gexp = function(n) {

      while (n < 0) {
        n += 255;
      }

      while (n >= 256) {
        n -= 255;
      }

      return EXP_TABLE[n];
    };

    return _this;
  }();

  //---------------------------------------------------------------------
  // qrPolynomial
  //---------------------------------------------------------------------

  function qrPolynomial(num, shift) {

    if (typeof num.length == 'undefined') {
      throw num.length + '/' + shift;
    }

    var _num = function() {
      var offset = 0;
      while (offset < num.length && num[offset] == 0) {
        offset += 1;
      }
      var _num = new Array(num.length - offset + shift);
      for (var i = 0; i < num.length - offset; i += 1) {
        _num[i] = num[i + offset];
      }
      return _num;
    }();

    var _this = {};

    _this.getAt = function(index) {
      return _num[index];
    };

    _this.getLength = function() {
      return _num.length;
    };

    _this.multiply = function(e) {

      var num = new Array(_this.getLength() + e.getLength() - 1);

      for (var i = 0; i < _this.getLength(); i += 1) {
        for (var j = 0; j < e.getLength(); j += 1) {
          num[i + j] ^= QRMath.gexp(QRMath.glog(_this.getAt(i) ) + QRMath.glog(e.getAt(j) ) );
        }
      }

      return qrPolynomial(num, 0);
    };

    _this.mod = function(e) {

      if (_this.getLength() - e.getLength() < 0) {
        return _this;
      }

      var ratio = QRMath.glog(_this.getAt(0) ) - QRMath.glog(e.getAt(0) );

      var num = new Array(_this.getLength() );
      for (var i = 0; i < _this.getLength(); i += 1) {
        num[i] = _this.getAt(i);
      }

      for (var i = 0; i < e.getLength(); i += 1) {
        num[i] ^= QRMath.gexp(QRMath.glog(e.getAt(i) ) + ratio);
      }

      // recursive call
      return qrPolynomial(num, 0).mod(e);
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // QRRSBlock
  //---------------------------------------------------------------------

  var QRRSBlock = function() {

    var RS_BLOCK_TABLE = [

      // L
      // M
      // Q
      // H

      // 1
      [1, 26, 19],
      [1, 26, 16],
      [1, 26, 13],
      [1, 26, 9],

      // 2
      [1, 44, 34],
      [1, 44, 28],
      [1, 44, 22],
      [1, 44, 16],

      // 3
      [1, 70, 55],
      [1, 70, 44],
      [2, 35, 17],
      [2, 35, 13],

      // 4
      [1, 100, 80],
      [2, 50, 32],
      [2, 50, 24],
      [4, 25, 9],

      // 5
      [1, 134, 108],
      [2, 67, 43],
      [2, 33, 15, 2, 34, 16],
      [2, 33, 11, 2, 34, 12],

      // 6
      [2, 86, 68],
      [4, 43, 27],
      [4, 43, 19],
      [4, 43, 15],

      // 7
      [2, 98, 78],
      [4, 49, 31],
      [2, 32, 14, 4, 33, 15],
      [4, 39, 13, 1, 40, 14],

      // 8
      [2, 121, 97],
      [2, 60, 38, 2, 61, 39],
      [4, 40, 18, 2, 41, 19],
      [4, 40, 14, 2, 41, 15],

      // 9
      [2, 146, 116],
      [3, 58, 36, 2, 59, 37],
      [4, 36, 16, 4, 37, 17],
      [4, 36, 12, 4, 37, 13],

      // 10
      [2, 86, 68, 2, 87, 69],
      [4, 69, 43, 1, 70, 44],
      [6, 43, 19, 2, 44, 20],
      [6, 43, 15, 2, 44, 16],

      // 11
      [4, 101, 81],
      [1, 80, 50, 4, 81, 51],
      [4, 50, 22, 4, 51, 23],
      [3, 36, 12, 8, 37, 13],

      // 12
      [2, 116, 92, 2, 117, 93],
      [6, 58, 36, 2, 59, 37],
      [4, 46, 20, 6, 47, 21],
      [7, 42, 14, 4, 43, 15],

      // 13
      [4, 133, 107],
      [8, 59, 37, 1, 60, 38],
      [8, 44, 20, 4, 45, 21],
      [12, 33, 11, 4, 34, 12],

      // 14
      [3, 145, 115, 1, 146, 116],
      [4, 64, 40, 5, 65, 41],
      [11, 36, 16, 5, 37, 17],
      [11, 36, 12, 5, 37, 13],

      // 15
      [5, 109, 87, 1, 110, 88],
      [5, 65, 41, 5, 66, 42],
      [5, 54, 24, 7, 55, 25],
      [11, 36, 12, 7, 37, 13],

      // 16
      [5, 122, 98, 1, 123, 99],
      [7, 73, 45, 3, 74, 46],
      [15, 43, 19, 2, 44, 20],
      [3, 45, 15, 13, 46, 16],

      // 17
      [1, 135, 107, 5, 136, 108],
      [10, 74, 46, 1, 75, 47],
      [1, 50, 22, 15, 51, 23],
      [2, 42, 14, 17, 43, 15],

      // 18
      [5, 150, 120, 1, 151, 121],
      [9, 69, 43, 4, 70, 44],
      [17, 50, 22, 1, 51, 23],
      [2, 42, 14, 19, 43, 15],

      // 19
      [3, 141, 113, 4, 142, 114],
      [3, 70, 44, 11, 71, 45],
      [17, 47, 21, 4, 48, 22],
      [9, 39, 13, 16, 40, 14],

      // 20
      [3, 135, 107, 5, 136, 108],
      [3, 67, 41, 13, 68, 42],
      [15, 54, 24, 5, 55, 25],
      [15, 43, 15, 10, 44, 16],

      // 21
      [4, 144, 116, 4, 145, 117],
      [17, 68, 42],
      [17, 50, 22, 6, 51, 23],
      [19, 46, 16, 6, 47, 17],

      // 22
      [2, 139, 111, 7, 140, 112],
      [17, 74, 46],
      [7, 54, 24, 16, 55, 25],
      [34, 37, 13],

      // 23
      [4, 151, 121, 5, 152, 122],
      [4, 75, 47, 14, 76, 48],
      [11, 54, 24, 14, 55, 25],
      [16, 45, 15, 14, 46, 16],

      // 24
      [6, 147, 117, 4, 148, 118],
      [6, 73, 45, 14, 74, 46],
      [11, 54, 24, 16, 55, 25],
      [30, 46, 16, 2, 47, 17],

      // 25
      [8, 132, 106, 4, 133, 107],
      [8, 75, 47, 13, 76, 48],
      [7, 54, 24, 22, 55, 25],
      [22, 45, 15, 13, 46, 16],

      // 26
      [10, 142, 114, 2, 143, 115],
      [19, 74, 46, 4, 75, 47],
      [28, 50, 22, 6, 51, 23],
      [33, 46, 16, 4, 47, 17],

      // 27
      [8, 152, 122, 4, 153, 123],
      [22, 73, 45, 3, 74, 46],
      [8, 53, 23, 26, 54, 24],
      [12, 45, 15, 28, 46, 16],

      // 28
      [3, 147, 117, 10, 148, 118],
      [3, 73, 45, 23, 74, 46],
      [4, 54, 24, 31, 55, 25],
      [11, 45, 15, 31, 46, 16],

      // 29
      [7, 146, 116, 7, 147, 117],
      [21, 73, 45, 7, 74, 46],
      [1, 53, 23, 37, 54, 24],
      [19, 45, 15, 26, 46, 16],

      // 30
      [5, 145, 115, 10, 146, 116],
      [19, 75, 47, 10, 76, 48],
      [15, 54, 24, 25, 55, 25],
      [23, 45, 15, 25, 46, 16],

      // 31
      [13, 145, 115, 3, 146, 116],
      [2, 74, 46, 29, 75, 47],
      [42, 54, 24, 1, 55, 25],
      [23, 45, 15, 28, 46, 16],

      // 32
      [17, 145, 115],
      [10, 74, 46, 23, 75, 47],
      [10, 54, 24, 35, 55, 25],
      [19, 45, 15, 35, 46, 16],

      // 33
      [17, 145, 115, 1, 146, 116],
      [14, 74, 46, 21, 75, 47],
      [29, 54, 24, 19, 55, 25],
      [11, 45, 15, 46, 46, 16],

      // 34
      [13, 145, 115, 6, 146, 116],
      [14, 74, 46, 23, 75, 47],
      [44, 54, 24, 7, 55, 25],
      [59, 46, 16, 1, 47, 17],

      // 35
      [12, 151, 121, 7, 152, 122],
      [12, 75, 47, 26, 76, 48],
      [39, 54, 24, 14, 55, 25],
      [22, 45, 15, 41, 46, 16],

      // 36
      [6, 151, 121, 14, 152, 122],
      [6, 75, 47, 34, 76, 48],
      [46, 54, 24, 10, 55, 25],
      [2, 45, 15, 64, 46, 16],

      // 37
      [17, 152, 122, 4, 153, 123],
      [29, 74, 46, 14, 75, 47],
      [49, 54, 24, 10, 55, 25],
      [24, 45, 15, 46, 46, 16],

      // 38
      [4, 152, 122, 18, 153, 123],
      [13, 74, 46, 32, 75, 47],
      [48, 54, 24, 14, 55, 25],
      [42, 45, 15, 32, 46, 16],

      // 39
      [20, 147, 117, 4, 148, 118],
      [40, 75, 47, 7, 76, 48],
      [43, 54, 24, 22, 55, 25],
      [10, 45, 15, 67, 46, 16],

      // 40
      [19, 148, 118, 6, 149, 119],
      [18, 75, 47, 31, 76, 48],
      [34, 54, 24, 34, 55, 25],
      [20, 45, 15, 61, 46, 16]
    ];

    var qrRSBlock = function(totalCount, dataCount) {
      var _this = {};
      _this.totalCount = totalCount;
      _this.dataCount = dataCount;
      return _this;
    };

    var _this = {};

    var getRsBlockTable = function(typeNumber, errorCorrectionLevel) {

      switch(errorCorrectionLevel) {
      case QRErrorCorrectionLevel.L :
        return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
      case QRErrorCorrectionLevel.M :
        return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
      case QRErrorCorrectionLevel.Q :
        return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
      case QRErrorCorrectionLevel.H :
        return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
      default :
        return undefined;
      }
    };

    _this.getRSBlocks = function(typeNumber, errorCorrectionLevel) {

      var rsBlock = getRsBlockTable(typeNumber, errorCorrectionLevel);

      if (typeof rsBlock == 'undefined') {
        throw 'bad rs block @ typeNumber:' + typeNumber +
            '/errorCorrectionLevel:' + errorCorrectionLevel;
      }

      var length = rsBlock.length / 3;

      var list = [];

      for (var i = 0; i < length; i += 1) {

        var count = rsBlock[i * 3 + 0];
        var totalCount = rsBlock[i * 3 + 1];
        var dataCount = rsBlock[i * 3 + 2];

        for (var j = 0; j < count; j += 1) {
          list.push(qrRSBlock(totalCount, dataCount) );
        }
      }

      return list;
    };

    return _this;
  }();

  //---------------------------------------------------------------------
  // qrBitBuffer
  //---------------------------------------------------------------------

  var qrBitBuffer = function() {

    var _buffer = [];
    var _length = 0;

    var _this = {};

    _this.getBuffer = function() {
      return _buffer;
    };

    _this.getAt = function(index) {
      var bufIndex = Math.floor(index / 8);
      return ( (_buffer[bufIndex] >>> (7 - index % 8) ) & 1) == 1;
    };

    _this.put = function(num, length) {
      for (var i = 0; i < length; i += 1) {
        _this.putBit( ( (num >>> (length - i - 1) ) & 1) == 1);
      }
    };

    _this.getLengthInBits = function() {
      return _length;
    };

    _this.putBit = function(bit) {

      var bufIndex = Math.floor(_length / 8);
      if (_buffer.length <= bufIndex) {
        _buffer.push(0);
      }

      if (bit) {
        _buffer[bufIndex] |= (0x80 >>> (_length % 8) );
      }

      _length += 1;
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // qrNumber
  //---------------------------------------------------------------------

  var qrNumber = function(data) {

    var _mode = QRMode.MODE_NUMBER;
    var _data = data;

    var _this = {};

    _this.getMode = function() {
      return _mode;
    };

    _this.getLength = function(buffer) {
      return _data.length;
    };

    _this.write = function(buffer) {

      var data = _data;

      var i = 0;

      while (i + 2 < data.length) {
        buffer.put(strToNum(data.substring(i, i + 3) ), 10);
        i += 3;
      }

      if (i < data.length) {
        if (data.length - i == 1) {
          buffer.put(strToNum(data.substring(i, i + 1) ), 4);
        } else if (data.length - i == 2) {
          buffer.put(strToNum(data.substring(i, i + 2) ), 7);
        }
      }
    };

    var strToNum = function(s) {
      var num = 0;
      for (var i = 0; i < s.length; i += 1) {
        num = num * 10 + chatToNum(s.charAt(i) );
      }
      return num;
    };

    var chatToNum = function(c) {
      if ('0' <= c && c <= '9') {
        return c.charCodeAt(0) - '0'.charCodeAt(0);
      }
      throw 'illegal char :' + c;
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // qrAlphaNum
  //---------------------------------------------------------------------

  var qrAlphaNum = function(data) {

    var _mode = QRMode.MODE_ALPHA_NUM;
    var _data = data;

    var _this = {};

    _this.getMode = function() {
      return _mode;
    };

    _this.getLength = function(buffer) {
      return _data.length;
    };

    _this.write = function(buffer) {

      var s = _data;

      var i = 0;

      while (i + 1 < s.length) {
        buffer.put(
          getCode(s.charAt(i) ) * 45 +
          getCode(s.charAt(i + 1) ), 11);
        i += 2;
      }

      if (i < s.length) {
        buffer.put(getCode(s.charAt(i) ), 6);
      }
    };

    var getCode = function(c) {

      if ('0' <= c && c <= '9') {
        return c.charCodeAt(0) - '0'.charCodeAt(0);
      } else if ('A' <= c && c <= 'Z') {
        return c.charCodeAt(0) - 'A'.charCodeAt(0) + 10;
      } else {
        switch (c) {
        case ' ' : return 36;
        case '$' : return 37;
        case '%' : return 38;
        case '*' : return 39;
        case '+' : return 40;
        case '-' : return 41;
        case '.' : return 42;
        case '/' : return 43;
        case ':' : return 44;
        default :
          throw 'illegal char :' + c;
        }
      }
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // qr8BitByte
  //---------------------------------------------------------------------

  var qr8BitByte = function(data) {

    var _mode = QRMode.MODE_8BIT_BYTE;
    var _data = data;
    var _bytes = qrcode.stringToBytes(data);

    var _this = {};

    _this.getMode = function() {
      return _mode;
    };

    _this.getLength = function(buffer) {
      return _bytes.length;
    };

    _this.write = function(buffer) {
      for (var i = 0; i < _bytes.length; i += 1) {
        buffer.put(_bytes[i], 8);
      }
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // qrKanji
  //---------------------------------------------------------------------

  var qrKanji = function(data) {

    var _mode = QRMode.MODE_KANJI;
    var _data = data;

    var stringToBytes = qrcode.stringToBytesFuncs['SJIS'];
    if (!stringToBytes) {
      throw 'sjis not supported.';
    }
    !function(c, code) {
      // self test for sjis support.
      var test = stringToBytes(c);
      if (test.length != 2 || ( (test[0] << 8) | test[1]) != code) {
        throw 'sjis not supported.';
      }
    }('\u53cb', 0x9746);

    var _bytes = stringToBytes(data);

    var _this = {};

    _this.getMode = function() {
      return _mode;
    };

    _this.getLength = function(buffer) {
      return ~~(_bytes.length / 2);
    };

    _this.write = function(buffer) {

      var data = _bytes;

      var i = 0;

      while (i + 1 < data.length) {

        var c = ( (0xff & data[i]) << 8) | (0xff & data[i + 1]);

        if (0x8140 <= c && c <= 0x9FFC) {
          c -= 0x8140;
        } else if (0xE040 <= c && c <= 0xEBBF) {
          c -= 0xC140;
        } else {
          throw 'illegal char at ' + (i + 1) + '/' + c;
        }

        c = ( (c >>> 8) & 0xff) * 0xC0 + (c & 0xff);

        buffer.put(c, 13);

        i += 2;
      }

      if (i < data.length) {
        throw 'illegal char at ' + (i + 1);
      }
    };

    return _this;
  };

  //=====================================================================
  // GIF Support etc.
  //

  //---------------------------------------------------------------------
  // byteArrayOutputStream
  //---------------------------------------------------------------------

  var byteArrayOutputStream = function() {

    var _bytes = [];

    var _this = {};

    _this.writeByte = function(b) {
      _bytes.push(b & 0xff);
    };

    _this.writeShort = function(i) {
      _this.writeByte(i);
      _this.writeByte(i >>> 8);
    };

    _this.writeBytes = function(b, off, len) {
      off = off || 0;
      len = len || b.length;
      for (var i = 0; i < len; i += 1) {
        _this.writeByte(b[i + off]);
      }
    };

    _this.writeString = function(s) {
      for (var i = 0; i < s.length; i += 1) {
        _this.writeByte(s.charCodeAt(i) );
      }
    };

    _this.toByteArray = function() {
      return _bytes;
    };

    _this.toString = function() {
      var s = '';
      s += '[';
      for (var i = 0; i < _bytes.length; i += 1) {
        if (i > 0) {
          s += ',';
        }
        s += _bytes[i];
      }
      s += ']';
      return s;
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // base64EncodeOutputStream
  //---------------------------------------------------------------------

  var base64EncodeOutputStream = function() {

    var _buffer = 0;
    var _buflen = 0;
    var _length = 0;
    var _base64 = '';

    var _this = {};

    var writeEncoded = function(b) {
      _base64 += String.fromCharCode(encode(b & 0x3f) );
    };

    var encode = function(n) {
      if (n < 0) {
        // error.
      } else if (n < 26) {
        return 0x41 + n;
      } else if (n < 52) {
        return 0x61 + (n - 26);
      } else if (n < 62) {
        return 0x30 + (n - 52);
      } else if (n == 62) {
        return 0x2b;
      } else if (n == 63) {
        return 0x2f;
      }
      throw 'n:' + n;
    };

    _this.writeByte = function(n) {

      _buffer = (_buffer << 8) | (n & 0xff);
      _buflen += 8;
      _length += 1;

      while (_buflen >= 6) {
        writeEncoded(_buffer >>> (_buflen - 6) );
        _buflen -= 6;
      }
    };

    _this.flush = function() {

      if (_buflen > 0) {
        writeEncoded(_buffer << (6 - _buflen) );
        _buffer = 0;
        _buflen = 0;
      }

      if (_length % 3 != 0) {
        // padding
        var padlen = 3 - _length % 3;
        for (var i = 0; i < padlen; i += 1) {
          _base64 += '=';
        }
      }
    };

    _this.toString = function() {
      return _base64;
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // base64DecodeInputStream
  //---------------------------------------------------------------------

  var base64DecodeInputStream = function(str) {

    var _str = str;
    var _pos = 0;
    var _buffer = 0;
    var _buflen = 0;

    var _this = {};

    _this.read = function() {

      while (_buflen < 8) {

        if (_pos >= _str.length) {
          if (_buflen == 0) {
            return -1;
          }
          throw 'unexpected end of file./' + _buflen;
        }

        var c = _str.charAt(_pos);
        _pos += 1;

        if (c == '=') {
          _buflen = 0;
          return -1;
        } else if (c.match(/^\s$/) ) {
          // ignore if whitespace.
          continue;
        }

        _buffer = (_buffer << 6) | decode(c.charCodeAt(0) );
        _buflen += 6;
      }

      var n = (_buffer >>> (_buflen - 8) ) & 0xff;
      _buflen -= 8;
      return n;
    };

    var decode = function(c) {
      if (0x41 <= c && c <= 0x5a) {
        return c - 0x41;
      } else if (0x61 <= c && c <= 0x7a) {
        return c - 0x61 + 26;
      } else if (0x30 <= c && c <= 0x39) {
        return c - 0x30 + 52;
      } else if (c == 0x2b) {
        return 62;
      } else if (c == 0x2f) {
        return 63;
      } else {
        throw 'c:' + c;
      }
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // gifImage (B/W)
  //---------------------------------------------------------------------

  var gifImage = function(width, height) {

    var _width = width;
    var _height = height;
    var _data = new Array(width * height);

    var _this = {};

    _this.setPixel = function(x, y, pixel) {
      _data[y * _width + x] = pixel;
    };

    _this.write = function(out) {

      //---------------------------------
      // GIF Signature

      out.writeString('GIF87a');

      //---------------------------------
      // Screen Descriptor

      out.writeShort(_width);
      out.writeShort(_height);

      out.writeByte(0x80); // 2bit
      out.writeByte(0);
      out.writeByte(0);

      //---------------------------------
      // Global Color Map

      // black
      out.writeByte(0x00);
      out.writeByte(0x00);
      out.writeByte(0x00);

      // white
      out.writeByte(0xff);
      out.writeByte(0xff);
      out.writeByte(0xff);

      //---------------------------------
      // Image Descriptor

      out.writeString(',');
      out.writeShort(0);
      out.writeShort(0);
      out.writeShort(_width);
      out.writeShort(_height);
      out.writeByte(0);

      //---------------------------------
      // Local Color Map

      //---------------------------------
      // Raster Data

      var lzwMinCodeSize = 2;
      var raster = getLZWRaster(lzwMinCodeSize);

      out.writeByte(lzwMinCodeSize);

      var offset = 0;

      while (raster.length - offset > 255) {
        out.writeByte(255);
        out.writeBytes(raster, offset, 255);
        offset += 255;
      }

      out.writeByte(raster.length - offset);
      out.writeBytes(raster, offset, raster.length - offset);
      out.writeByte(0x00);

      //---------------------------------
      // GIF Terminator
      out.writeString(';');
    };

    var bitOutputStream = function(out) {

      var _out = out;
      var _bitLength = 0;
      var _bitBuffer = 0;

      var _this = {};

      _this.write = function(data, length) {

        if ( (data >>> length) != 0) {
          throw 'length over';
        }

        while (_bitLength + length >= 8) {
          _out.writeByte(0xff & ( (data << _bitLength) | _bitBuffer) );
          length -= (8 - _bitLength);
          data >>>= (8 - _bitLength);
          _bitBuffer = 0;
          _bitLength = 0;
        }

        _bitBuffer = (data << _bitLength) | _bitBuffer;
        _bitLength = _bitLength + length;
      };

      _this.flush = function() {
        if (_bitLength > 0) {
          _out.writeByte(_bitBuffer);
        }
      };

      return _this;
    };

    var getLZWRaster = function(lzwMinCodeSize) {

      var clearCode = 1 << lzwMinCodeSize;
      var endCode = (1 << lzwMinCodeSize) + 1;
      var bitLength = lzwMinCodeSize + 1;

      // Setup LZWTable
      var table = lzwTable();

      for (var i = 0; i < clearCode; i += 1) {
        table.add(String.fromCharCode(i) );
      }
      table.add(String.fromCharCode(clearCode) );
      table.add(String.fromCharCode(endCode) );

      var byteOut = byteArrayOutputStream();
      var bitOut = bitOutputStream(byteOut);

      // clear code
      bitOut.write(clearCode, bitLength);

      var dataIndex = 0;

      var s = String.fromCharCode(_data[dataIndex]);
      dataIndex += 1;

      while (dataIndex < _data.length) {

        var c = String.fromCharCode(_data[dataIndex]);
        dataIndex += 1;

        if (table.contains(s + c) ) {

          s = s + c;

        } else {

          bitOut.write(table.indexOf(s), bitLength);

          if (table.size() < 0xfff) {

            if (table.size() == (1 << bitLength) ) {
              bitLength += 1;
            }

            table.add(s + c);
          }

          s = c;
        }
      }

      bitOut.write(table.indexOf(s), bitLength);

      // end code
      bitOut.write(endCode, bitLength);

      bitOut.flush();

      return byteOut.toByteArray();
    };

    var lzwTable = function() {

      var _map = {};
      var _size = 0;

      var _this = {};

      _this.add = function(key) {
        if (_this.contains(key) ) {
          throw 'dup key:' + key;
        }
        _map[key] = _size;
        _size += 1;
      };

      _this.size = function() {
        return _size;
      };

      _this.indexOf = function(key) {
        return _map[key];
      };

      _this.contains = function(key) {
        return typeof _map[key] != 'undefined';
      };

      return _this;
    };

    return _this;
  };

  var createDataURL = function(width, height, getPixel) {
    var gif = gifImage(width, height);
    for (var y = 0; y < height; y += 1) {
      for (var x = 0; x < width; x += 1) {
        gif.setPixel(x, y, getPixel(x, y) );
      }
    }

    var b = byteArrayOutputStream();
    gif.write(b);

    var base64 = base64EncodeOutputStream();
    var bytes = b.toByteArray();
    for (var i = 0; i < bytes.length; i += 1) {
      base64.writeByte(bytes[i]);
    }
    base64.flush();

    return 'data:image/gif;base64,' + base64;
  };

  //---------------------------------------------------------------------
  // returns qrcode function.

  return qrcode;
}();

// multibyte support
!function() {

  qrcode.stringToBytesFuncs['UTF-8'] = function(s) {
    // http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array
    function toUTF8Array(str) {
      var utf8 = [];
      for (var i=0; i < str.length; i++) {
        var charcode = str.charCodeAt(i);
        if (charcode < 0x80) utf8.push(charcode);
        else if (charcode < 0x800) {
          utf8.push(0xc0 | (charcode >> 6),
              0x80 | (charcode & 0x3f));
        }
        else if (charcode < 0xd800 || charcode >= 0xe000) {
          utf8.push(0xe0 | (charcode >> 12),
              0x80 | ((charcode>>6) & 0x3f),
              0x80 | (charcode & 0x3f));
        }
        // surrogate pair
        else {
          i++;
          // UTF-16 encodes 0x10000-0x10FFFF by
          // subtracting 0x10000 and splitting the
          // 20 bits of 0x0-0xFFFFF into two halves
          charcode = 0x10000 + (((charcode & 0x3ff)<<10)
            | (str.charCodeAt(i) & 0x3ff));
          utf8.push(0xf0 | (charcode >>18),
              0x80 | ((charcode>>12) & 0x3f),
              0x80 | ((charcode>>6) & 0x3f),
              0x80 | (charcode & 0x3f));
        }
      }
      return utf8;
    }
    return toUTF8Array(s);
  };

}();

if(typeof window!=='undefined'){window.qrcode=qrcode;}
    </script>
    <style>
        :root {
            --bg:#0b0e14; --s1:#161b26; --s2:#1e2535; --s3:#252e42;
            --bd:rgba(255,255,255,0.07); --bd2:rgba(255,255,255,0.12);
            --tx:#e4e9f0; --td:#7a8499; --tm:#3a4358;
            --ac:#c8ff00; --acd:#8fb800;
            --beg:#22c55e; --mit:#f59e0b; --exp:#ef4444; --log:#38bdf8; --fac:#a78bfa;
            --fh:'Barlow Condensed',sans-serif; --fb:'Barlow',sans-serif;
            --r:12px;
            --shadow:0 8px 24px rgba(0,0,0,.55);
            color-scheme: dark;
        }
        /* ═══ LIGHT MODE — WCAG AA konform (alle Kontraste ≥ 4.5:1) ═══ */
        [data-theme=light]{
            --bg:#edf1f7;         /* Karten-BG, warm-kühl */
            --s1:#ffffff;         /* Panel-/Kartenfläche */
            --s2:#f3f6fc;         /* Sekundäre Fläche */
            --s3:#e5eaf5;         /* Tertiäre Fläche */
            --bd:rgba(0,0,0,.10);
            --bd2:rgba(0,0,0,.24);
            /* Text — alle ≥ 4.5:1 auf weißem Hintergrund */
            --tx:#0c1420;         /* Primär ≈ 17:1 auf #fff */
            --td:#364255;         /* Sekundär ≈ 9:1 auf #fff */
            --tm:#5a6878;         /* Gedimmt ≈ 5.1:1 auf #fff */
            /* Akzent-Grün — dunkel genug für WCAG AA */
            --ac:#236b00;         /* ≈ 7.5:1 auf #fff ✓ */
            --acd:#174d00;
            --shadow:0 4px 20px rgba(0,0,0,.18);
            color-scheme: light;
        }
        /* Hochkontrast-Modus (optional, via Barrierefreiheit-Einstellungen) */
        [data-theme=light][data-a11y-hc]{
            --bg:#ffffff; --s1:#ffffff; --s2:#f2f2f2; --s3:#e5e5e5;
            --bd:rgba(0,0,0,.30); --bd2:rgba(0,0,0,.60);
            --tx:#000000; --td:#111111; --tm:#2a2a2a;
            --ac:#0f5200; --acd:#083800;
            --shadow:0 2px 12px rgba(0,0,0,.35);
        }
        [data-theme=light] .leaflet-popup-content-wrapper{
            background:var(--s1)!important; color:var(--tx)!important;
        }
        [data-theme=light] .leaflet-popup-tip{background:var(--s1)!important}
        [data-theme=light] .leaflet-popup-content{color:var(--tx)!important}
        [data-theme=light] .leaflet-control-zoom a{
            background:var(--s1)!important;color:var(--tx)!important;
            border-color:var(--bd2)!important;
        }
        [data-theme=light] .leaflet-control-attribution{
            background:rgba(237,241,247,.94)!important;color:var(--td)!important;
        }
        [data-theme=light] .path-lbl{
            background:rgba(255,255,255,.97)!important;
            border-color:rgba(160,90,0,.55)!important;
            color:var(--tx)!important;
        }
        [data-theme=light] #legend{background:rgba(255,255,255,.97)!important;}
        [data-theme=light] .ibtn,[data-theme=light] #titlepill,[data-theme=light] .fab{
            box-shadow:0 2px 10px rgba(0,0,0,.22)!important;
        }
        /* ── LIGHT MODE: MENU & PANEL CONTRAST FIXES ──────────────────────
           Alle Text-Elemente auf weißen/hellen Flächen: schwarz oder sehr dunkel.
           Kein Grau auf Weiß mehr. */
        [data-theme=light] .sp-hint{color:#364255!important}
        [data-theme=light] .sp-label{color:#0c1420!important}
        [data-theme=light] .sp-section{border-bottom-color:rgba(0,0,0,.14)!important}
        [data-theme=light] .sp-tab{color:#364255!important;background:#e8edf6!important;border-color:rgba(0,0,0,.14)!important}
        [data-theme=light] .sp-tab.active{color:#0c1420!important;background:#fff!important;border-bottom-color:#fff!important}
        [data-theme=light] .sp-input{background:#fff!important;color:#0c1420!important;border-color:rgba(0,0,0,.28)!important}
        [data-theme=light] .sp-input::placeholder{color:#6a7887!important}
        [data-theme=light] .sp-btn{color:#0c1420!important;border-color:rgba(0,0,0,.24)!important}
        [data-theme=light] .sp-btn.sec{background:#f0f4fd!important;color:#0c1420!important}
        [data-theme=light] .sp-btn.prim{background:var(--ac)!important;color:#fff!important}
        [data-theme=light] #settings-panel{background:#f3f6fc!important;border-color:rgba(0,0,0,.18)!important}
        /* Sheet (burger menu) */
        [data-theme=light] #sheet{background:#fff!important}
        [data-theme=light] .s-title{color:#0c1420!important}
        [data-theme=light] .cat-head{color:#0c1420!important;background:#e8edf6!important;border-color:rgba(0,0,0,.12)!important}
        [data-theme=light] .l-nm{color:#0c1420!important}
        [data-theme=light] .l-co{color:#364255!important}
        [data-theme=light] .lrow{border-bottom-color:rgba(0,0,0,.08)!important}
        [data-theme=light] .lbtn{background:#edf1f9!important;border-color:rgba(0,0,0,.2)!important;color:#0c1420!important}
        [data-theme=light] .lbtn.nav{background:var(--ac)!important;color:#fff!important}
        /* GPX panel */
        [data-theme=light] .gpx-label{color:#0c1420!important}
        [data-theme=light] .gpx-select,.gpx-input{background:#fff!important;color:#0c1420!important;border-color:rgba(0,0,0,.24)!important}
        [data-theme=light] .gpx-section{border-bottom-color:rgba(0,0,0,.1)!important}
        /* Settings profile, cm-item */
        [data-theme=light] .cm-item{border-color:rgba(0,0,0,.1)!important}
        [data-theme=light] .cm-name{color:#0c1420!important}
        [data-theme=light] .cm-cat{color:#364255!important}
        [data-theme=light] .cm-section-title{color:#0c1420!important}
        [data-theme=light] .cm-act-btn{background:#edf1f9!important;color:#0c1420!important;border-color:rgba(0,0,0,.18)!important}
        /* TTS bar */
        [data-theme=light] #tts-ctrl-bar{background:#fff!important;border-color:rgba(0,0,0,.22)!important}
        [data-theme=light] #tts-status-txt{color:#364255!important}
        [data-theme=light] .tts-ctrl-btn{background:#edf1f9!important;color:#0c1420!important;border-color:rgba(0,0,0,.22)!important}
        /* Navigation HUD */
        [data-theme=light] #nav-hud{background:#fff!important;border-color:rgba(0,0,0,.2)!important}
        [data-theme=light] .nh-title{color:#0c1420!important}
        [data-theme=light] .nh-dist{color:#0c1420!important}
        [data-theme=light] .nh-sub{color:#364255!important}
        /* Toast */
        [data-theme=light] #toast{background:#0c1420!important;color:#fff!important}
        /* Chip filters */
        [data-theme=light] .chip{background:#fff!important;color:#0c1420!important;border-color:rgba(0,0,0,.22)!important;box-shadow:0 1px 4px rgba(0,0,0,.12)!important}
        [data-theme=light] .chip.on{background:#0c1420!important;color:#fff!important}
        /* Topbar */
        [data-theme=light] #topbar{background:#fff!important;border-bottom-color:rgba(0,0,0,.12)!important}
        [data-theme=light] .ttl{color:#0c1420!important}
        [data-theme=light] .tsub{color:#364255!important}
        [data-theme=light] .ibtn{background:#fff!important;color:#0c1420!important;border-color:rgba(0,0,0,.18)!important}
        /* Profile quick buttons, lang buttons */
        [data-theme=light] .profile-quick-btn{background:#edf1f9!important;color:#0c1420!important;border-color:rgba(0,0,0,.18)!important}
        [data-theme=light] .lang-btn{background:#edf1f9!important;color:#0c1420!important;border-color:rgba(0,0,0,.2)!important}
        [data-theme=light] .lang-btn.active{background:var(--ac)!important;color:#fff!important;border-color:var(--ac)!important}
        /* A11Y big toggle */
        [data-theme=light] .a11y-big-toggle{background:#edf1f9!important;border-color:rgba(0,0,0,.2)!important;color:#0c1420!important}
        [data-theme=light] .a11y-big-toggle.on{background:var(--ac)!important;border-color:var(--ac)!important;color:#fff!important}
        /* ── LOCS POPUP — Light mode ──────────────────────────────── */
        [data-theme=light] .p-top{background:var(--s1)!important}
        [data-theme=light] .p-name{color:#0c1420!important}
        [data-theme=light] .p-desc{color:#364255!important}
        [data-theme=light] .p-crds{color:#5a6878!important}
        [data-theme=light] .p-acts{background:var(--s1)!important}
        /* LOCS popup action buttons */
        [data-theme=light] .pbtn{color:#0c1420!important}
        [data-theme=light] .pbtn.nav{background:var(--ac)!important;color:#fff!important;border-color:var(--ac)!important}
        [data-theme=light] .pbtn.nav:active{background:var(--acd)!important}
        [data-theme=light] .pbtn.shr{background:#dde3f4!important;color:#0c1420!important;border-color:rgba(0,0,0,.3)!important}
        [data-theme=light] .pbtn.spk{background:#dde3f4!important;color:#0c1420!important;border-color:rgba(0,0,0,.3)!important}
        /* ── GPX TRACK POPUP — Light mode ─────────────────────────── */
        [data-theme=light] .tpop-name{color:#0c1420!important}
        [data-theme=light] .tpop-meta{color:#364255!important}
        [data-theme=light] .tpop-gps{background:#dde3f4!important;color:#364255!important}
        [data-theme=light] .tpop-sep{border-color:rgba(0,0,0,.14)!important}
        [data-theme=light] .tpop-btn{color:#0c1420!important}
        [data-theme=light] .tpop-btn.navi{background:var(--ac)!important;color:#fff!important}
        [data-theme=light] .tpop-btn.race{background:#0f5fa0!important;color:#fff!important}
        [data-theme=light] .tpop-btn.sec{background:#dde3f4!important;color:#0c1420!important;border:1.5px solid rgba(0,0,0,.22)!important}
        [data-theme=light] .tpop-btn.spk{background:#dde3f4!important;color:#0c1420!important;border:1.5px solid rgba(0,0,0,.22)!important}
        /* ── CATEGORY FILTER BUTTONS — Light mode ──────────────────── */
        [data-theme=light] .cat-fbtn{background:#dde3f4!important;color:#0c1420!important;border-color:rgba(0,0,0,.28)!important;font-weight:800!important}
        /* ── SPEAK BUTTON — nur anzeigen wenn TTS aktiv ─────────────── */
        /* Standardmäßig versteckt; erscheint wenn html[data-a11y-on] gesetzt */
        html:not([data-a11y-on]) .pbtn.spk{display:none!important}
        html:not([data-a11y-on]) .tpop-btn.spk{display:none!important}
        /* Sichtbarer Fokus-Ring für Tastaturnavigation */
        :focus-visible{
            outline:3px solid var(--ac)!important;
            outline-offset:3px!important;
            border-radius:4px!important;
        }
        *,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
        body,html{width:100%;height:100%;overflow:hidden;font-family:var(--fb);background:var(--bg);color:var(--tx);-webkit-tap-highlight-color:transparent;-webkit-text-size-adjust:100%}
        button{font-family:inherit}
        #map{position:fixed;inset:0;z-index:1}

        /* LEAFLET */
        .leaflet-control-zoom{border:none!important;box-shadow:0 8px 24px rgba(0,0,0,.6)!important}
        .leaflet-control-zoom a{background:var(--s1)!important;color:var(--tx)!important;border:1px solid var(--bd2)!important;font-size:16px!important;width:34px!important;height:34px!important;line-height:34px!important}
        .leaflet-control-zoom a:hover{background:var(--s2)!important}
        .leaflet-control-zoom-in{border-radius:var(--r) var(--r) 0 0!important}
        .leaflet-control-zoom-out{border-radius:0 0 var(--r) var(--r)!important}
        .leaflet-popup-content-wrapper{background:var(--s1)!important;border:1px solid var(--bd2)!important;border-radius:16px!important;box-shadow:0 20px 60px rgba(0,0,0,.8)!important;padding:0!important;overflow:hidden}
        .leaflet-popup-content{margin:0!important;min-width:250px;max-width:290px}
        .leaflet-popup-tip-container{display:none}
        .leaflet-popup-close-button{color:var(--td)!important;font-size:20px!important;top:10px!important;right:10px!important;z-index:10;width:28px!important;height:28px!important;display:flex!important;align-items:center!important;justify-content:center!important;background:var(--s2)!important;border-radius:50%!important;line-height:1!important}
        .map-label{background:transparent!important;border:none!important;box-shadow:none!important;font-family:var(--fh)!important;font-size:11px!important;font-weight:700!important;letter-spacing:.6px!important;color:#fff!important;text-shadow:0 0 4px #000,0 0 10px rgba(0,0,0,.9),0 1px 3px #000!important;pointer-events:none!important;white-space:nowrap!important;text-transform:uppercase!important}
        .leaflet-tooltip{opacity:1!important}
        .path-lbl{background:rgba(11,14,20,.85)!important;border:1px solid rgba(245,158,11,.4)!important;color:#f59e0b!important;font-family:var(--fh)!important;font-size:11px!important;font-weight:700!important;letter-spacing:1px!important;border-radius:4px!important;padding:2px 7px!important;pointer-events:none!important}
        .leaflet-control-attribution{background:rgba(11,14,20,.7)!important;color:var(--td)!important;font-size:9px!important}

        /* TOP BAR */
        #topbar{position:fixed;top:0;left:0;right:0;z-index:500;padding:max(12px,env(safe-area-inset-top,12px)) 12px 0;pointer-events:none}
        #tbrow{display:flex;align-items:center;gap:8px;padding-bottom:10px}
        #tbrow>*{pointer-events:all}
        .ibtn{width:42px;height:42px;flex-shrink:0;background:var(--s1);border:1px solid var(--bd2);border-radius:var(--r);color:var(--tx);display:flex;align-items:center;justify-content:center;cursor:pointer;box-shadow:0 2px 8px rgba(0,0,0,.4);transition:background .15s,transform .1s}
        .ibtn:active{background:var(--s2);transform:scale(.9)}
        #titlepill{flex:1;min-width:0;background:var(--s1);border:1px solid var(--bd2);border-radius:var(--r);padding:7px 12px;box-shadow:0 2px 8px rgba(0,0,0,.4);display:flex;align-items:center;gap:10px}
        .logobadge{width:32px;height:32px;flex-shrink:0;background:var(--ac);border-radius:7px;display:flex;align-items:center;justify-content:center;font-family:var(--fh);font-size:12px;font-weight:900;color:var(--bg);letter-spacing:.5px}
        .ttl{font-family:var(--fh);font-size:15px;font-weight:800;letter-spacing:1.5px;text-transform:uppercase;color:var(--tx);line-height:1.1}
        .tsub{font-size:11px;color:var(--td)}

        /* FILTER BAR */
        #fbar{position:fixed;top:max(66px,calc(env(safe-area-inset-top,0px) + 66px));left:0;right:0;z-index:499;display:flex;gap:6px;padding:4px 12px 8px;overflow-x:auto;scrollbar-width:none;pointer-events:none}
        #fbar::-webkit-scrollbar{display:none}
        #fbar>*{pointer-events:all}
        .chip{flex-shrink:0;height:32px;padding:0 13px;border-radius:20px;border:1px solid var(--bd2);font-family:var(--fh);font-size:12px;font-weight:700;letter-spacing:.8px;text-transform:uppercase;background:rgba(11,14,20,.88);color:var(--td);cursor:pointer;white-space:nowrap;transition:all .2s;display:flex;align-items:center;gap:5px}
        .chip:active{transform:scale(.94)}
        .chip.on{border-color:transparent;color:#000}
        .chip[data-f=all].on{background:var(--tx)}
        .chip[data-f=beginner].on{background:var(--beg)}
        .chip[data-f=mittel].on{background:var(--mit)}
        .chip[data-f=expert].on{background:var(--exp)}
        .chip[data-f=logistik].on{background:var(--log)}

        /* FABS */
        .fabs{position:fixed;right:12px;bottom:calc(env(safe-area-inset-bottom,0px) + 110px);z-index:490;display:flex;flex-direction:column;gap:8px}
        .fab{width:46px;height:46px;background:var(--s1);border:1px solid var(--bd2);border-radius:13px;color:var(--tx);display:flex;align-items:center;justify-content:center;cursor:pointer;box-shadow:0 8px 24px rgba(0,0,0,.55);transition:all .15s}
        .fab:active{transform:scale(.88)}
        .fab.spin svg{animation:spin 1s linear infinite}
        @keyframes spin{to{transform:rotate(360deg)}}

        /* LEGEND */
        #legend{position:fixed;left:12px;bottom:calc(env(safe-area-inset-bottom,0px) + 110px);z-index:490;background:rgba(11,14,20,.88);border:1px solid var(--bd2);border-radius:var(--r);padding:9px 12px;backdrop-filter:blur(10px)}
        .lgnd-t{font-family:var(--fh);font-size:9px;font-weight:700;letter-spacing:2px;text-transform:uppercase;color:var(--tm);margin-bottom:7px}
        .lgnd-r{display:flex;align-items:center;gap:7px;margin-bottom:4px}
        .lgnd-r:last-child{margin-bottom:0}
        .lgnd-d{width:9px;height:9px;border-radius:2px;flex-shrink:0}
        .lgnd-l{font-family:var(--fh);font-size:11px;font-weight:700;text-transform:uppercase;color:var(--tx)}

        /* BACKDROP */
        #backdrop{position:fixed;inset:0;z-index:800;background:rgba(0,0,0,.65);opacity:0;visibility:hidden;transition:opacity .3s;backdrop-filter:blur(3px)}
        #backdrop.show{opacity:1;visibility:visible}

        /* SHEET */
        #sheet{position:fixed;bottom:0;left:0;right:0;z-index:900;background:var(--s1);border-top:1px solid var(--bd2);border-radius:20px 20px 0 0;max-height:82vh;transform:translateY(100%);transition:transform .4s cubic-bezier(.32,.72,0,1);display:flex;flex-direction:column;padding-bottom:env(safe-area-inset-bottom,0px)}
        #sheet.open{transform:translateY(0)}
        .s-handle{width:36px;height:4px;border-radius:2px;background:var(--bd2);margin:12px auto 0;flex-shrink:0}
        .s-head{padding:10px 16px 12px;flex-shrink:0;border-bottom:1px solid var(--bd);display:flex;align-items:center;justify-content:space-between;gap:10px}
        .s-title{font-family:var(--fh);font-size:19px;font-weight:800;letter-spacing:1px;text-transform:uppercase}
        .s-cnt{font-family:var(--fh);font-size:12px;font-weight:700;color:var(--td);background:var(--s2);padding:3px 9px;border-radius:20px;border:1px solid var(--bd)}
        .s-close{width:30px;height:30px;background:var(--s2);border:1px solid var(--bd);border-radius:50%;color:var(--td);cursor:pointer;display:flex;align-items:center;justify-content:center;flex-shrink:0;font-size:18px;line-height:1;transition:all .15s}
        .s-close:active{background:var(--s3)}
        .s-scroll{overflow-y:auto;flex:1;-webkit-overflow-scrolling:touch}
        .s-scroll::-webkit-scrollbar{width:3px}
        .s-scroll::-webkit-scrollbar-thumb{background:var(--bd2);border-radius:2px}
        .cat-head{padding:14px 16px 6px;font-family:var(--fh);font-size:10px;font-weight:700;letter-spacing:2.5px;text-transform:uppercase;color:var(--tm);display:flex;align-items:center;gap:8px}
        .cat-head::after{content:'';flex:1;height:1px;background:var(--bd)}
        .lrow{display:flex;align-items:center;gap:12px;padding:10px 16px;border-bottom:1px solid var(--bd);transition:background .12s;cursor:pointer}
        .lrow:active{background:var(--s2)}
        .lrow:last-child{border-bottom:none}
        .l-ico{width:38px;height:38px;border-radius:9px;flex-shrink:0;display:flex;align-items:center;justify-content:center;font-size:18px}
        .l-inf{flex:1;min-width:0}
        .l-nm{font-family:var(--fh);font-size:15px;font-weight:700;color:var(--tx);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;line-height:1.2}
        .l-co{font-size:10px;color:var(--td);font-family:monospace;margin-top:2px}
        .l-btns{display:flex;gap:6px;flex-shrink:0}
        .lbtn{width:34px;height:34px;border-radius:9px;background:var(--s2);border:1px solid var(--bd);color:var(--td);cursor:pointer;display:flex;align-items:center;justify-content:center;transition:all .15s}
        .lbtn:active{transform:scale(.86);background:var(--s3)}
        .lbtn.nav{background:var(--ac);border-color:var(--ac);color:var(--bg)}
        .lbtn.nav:active{background:var(--acd)}

        /* POPUP */
        .p-top{padding:14px 14px 10px;border-bottom:1px solid var(--bd)}
        .p-badge{display:inline-flex;align-items:center;gap:5px;padding:3px 9px;border-radius:20px;font-family:var(--fh);font-size:10px;font-weight:800;letter-spacing:1px;text-transform:uppercase;color:var(--bg);margin-bottom:8px}
        .p-name{font-family:var(--fh);font-size:18px;font-weight:800;color:var(--tx);line-height:1.2;margin-bottom:2px;padding-right:28px}
        .p-crds{font-size:10px;color:var(--tm);font-family:monospace}
        .p-desc{font-size:12px;color:var(--td);margin-top:6px;line-height:1.4}
        .p-acts{padding:10px 14px;display:flex;gap:8px}
        .pbtn{flex:1;padding:9px 8px;border-radius:10px;border:1px solid var(--bd2);font-family:var(--fh);font-size:12px;font-weight:800;letter-spacing:.8px;text-transform:uppercase;cursor:pointer;display:flex;align-items:center;justify-content:center;gap:6px;transition:all .15s}
        .pbtn:active{transform:scale(.94)}
        .pbtn.nav{background:var(--ac);border-color:var(--ac);color:var(--bg);flex:2}
        .pbtn.nav:active{background:var(--acd)}
        .pbtn.shr{background:var(--s2);color:var(--td)}

        /* QR MODAL */
        #qrm{position:fixed;top:50%;left:50%;z-index:1100;transform:translate(-50%,-50%) scale(.88);background:var(--s1);border:1px solid var(--bd2);border-radius:20px;box-shadow:0 20px 60px rgba(0,0,0,.8);width:90%;max-width:310px;padding:20px;text-align:center;opacity:0;visibility:hidden;transition:all .25s cubic-bezier(.32,.72,0,1)}
        #qrm.show{opacity:1;visibility:visible;transform:translate(-50%,-50%) scale(1)}
        .qr-nm{font-family:var(--fh);font-size:17px;font-weight:800;letter-spacing:.5px;text-transform:uppercase;color:var(--tx);margin-bottom:4px}
        .qr-hint{font-size:11px;color:var(--td);margin-bottom:14px}
        #qr-wrap{width:176px;height:176px;margin:0 auto 14px;background:#fff;border-radius:14px;padding:8px;display:flex;align-items:center;justify-content:center;box-shadow:0 4px 20px rgba(0,0,0,.25)}
        #qr-canvas{width:160px;height:160px;display:block;border-radius:6px;image-rendering:pixelated;image-rendering:-moz-crisp-edges;image-rendering:crisp-edges}
        #qr-inp{width:100%;padding:9px 12px;background:var(--bg);border:1px solid var(--bd2);border-radius:9px;color:var(--td);font-size:12px;font-family:monospace;margin-bottom:12px;outline:none}
        .qr-acts{display:flex;gap:8px}
        .qbtn{flex:1;padding:10px 8px;border-radius:10px;border:none;font-family:var(--fh);font-size:13px;font-weight:800;letter-spacing:.5px;text-transform:uppercase;cursor:pointer;transition:all .15s;display:flex;align-items:center;justify-content:center;gap:5px}
        .qbtn:active{transform:scale(.94)}
        .qbtn.cl{background:var(--s2);color:var(--td)}
        .qbtn.cp{background:var(--s3);color:var(--tx)}
        .qbtn.dl{background:var(--ac);color:var(--bg)}

        /* GPS HINT */
        #gpshint{position:fixed;right:12px;bottom:calc(env(safe-area-inset-bottom,0px) + 160px);z-index:491;background:var(--s1);border:1px solid var(--bd2);border-radius:var(--r);padding:12px 14px 10px;max-width:220px;box-shadow:0 8px 24px rgba(0,0,0,.55);font-size:12px;color:var(--td);line-height:1.4;opacity:0;visibility:hidden;transition:all .3s;transform:translateX(10px)}
        #gpshint.show{opacity:1;visibility:visible;transform:translateX(0)}
        #gpshint strong{color:var(--tx);display:block;margin-bottom:4px;font-family:var(--fh);font-size:13px;font-weight:700}
        #gpshint-x{position:absolute;top:8px;right:10px;cursor:pointer;color:var(--tm);font-size:16px;line-height:1;background:none;border:none}

        /* TOAST */
        #toast{position:fixed;bottom:calc(env(safe-area-inset-bottom,0px) + 110px);left:50%;transform:translateX(-50%) translateY(16px);background:var(--s2);border:1px solid var(--bd2);border-radius:30px;padding:9px 18px;font-family:var(--fh);font-size:13px;font-weight:700;letter-spacing:.5px;color:var(--tx);z-index:2000;opacity:0;pointer-events:none;transition:all .28s;white-space:nowrap;box-shadow:0 8px 24px rgba(0,0,0,.55)}
        #toast.show{opacity:1;transform:translateX(-50%) translateY(0)}

        /* PIN */
        .pm{display:flex;flex-direction:column;align-items:center}
        .pm-h{width:30px;height:30px;border-radius:50% 50% 50% 4px;transform:rotate(-45deg);display:flex;align-items:center;justify-content:center;border:1.5px solid rgba(255,255,255,.25);box-shadow:0 3px 10px rgba(0,0,0,.55)}
        .pm-i{transform:rotate(45deg);font-size:13px;line-height:1}
        .pm-d{width:4px;height:4px;border-radius:50%;margin-top:2px;opacity:.6}
        .pm.lg .pm-h{width:36px;height:36px}
        .pm.lg .pm-i{font-size:16px}


        /* ═══ ELEVATION PROFILE ═══ */
        #elev-panel{margin:0 16px 14px;background:var(--s2);border:1px solid var(--bd2);border-radius:var(--r);padding:10px 12px;display:none}
        #elev-title{font-family:var(--fh);font-size:10px;font-weight:700;letter-spacing:2px;text-transform:uppercase;color:var(--tm);margin-bottom:6px}
        #elev-canvas{width:100%;height:80px;border-radius:6px;display:block;image-rendering:auto}
        #elev-stats{display:flex;gap:8px;margin-top:6px}
        .elev-stat{flex:1;text-align:center;background:var(--s1);border-radius:7px;padding:5px 3px}
        .elev-stat-v{font-family:var(--fh);font-size:16px;font-weight:800;color:var(--tx);line-height:1.1}
        .elev-stat-l{font-family:var(--fh);font-size:9px;font-weight:700;letter-spacing:1px;text-transform:uppercase;color:var(--tm)}
        /* ═══ THEME FAB ═══ */
        #theme-fab svg{transition:opacity .2s}
        /* ═══ PERSIST BADGE ═══ */
        .persist-badge{display:inline-flex;align-items:center;gap:4px;font-size:10px;color:var(--ac);font-family:var(--fh);font-weight:700;letter-spacing:.5px;margin-left:6px;opacity:.7}
        /* ═══════════════════════════════════════════════════
           GPX PANEL
        ═══════════════════════════════════════════════════ */
        #gpx-panel{position:fixed;bottom:0;left:0;right:0;z-index:901;background:var(--s1);border-top:1px solid var(--bd2);border-radius:20px 20px 0 0;max-height:85vh;transform:translateY(100%);transition:transform .4s cubic-bezier(.32,.72,0,1);display:flex;flex-direction:column;padding-bottom:env(safe-area-inset-bottom,0px)}
        #gpx-panel.open{transform:translateY(0)}
        .gpx-tabs{display:flex;gap:0;flex-shrink:0;border-bottom:1px solid var(--bd);margin:0 16px}
        .gpx-tab{flex:1;padding:10px 8px;background:none;border:none;border-bottom:2px solid transparent;font-family:var(--fh);font-size:13px;font-weight:700;letter-spacing:.8px;text-transform:uppercase;color:var(--td);cursor:pointer;transition:all .2s;margin-bottom:-1px}
        .gpx-tab.on{color:var(--ac);border-bottom-color:var(--ac)}
        .gpx-content{display:none;flex:1;overflow-y:auto;-webkit-overflow-scrolling:touch}
        .gpx-content.on{display:flex;flex-direction:column}
        .gpx-section{padding:14px 16px;border-bottom:1px solid var(--bd)}
        .gpx-section:last-child{border-bottom:none}
        .gpx-label{font-family:var(--fh);font-size:10px;font-weight:700;letter-spacing:2px;text-transform:uppercase;color:var(--tm);margin-bottom:8px;display:block}
        .gpx-row{display:flex;gap:8px;align-items:stretch}
        .gpx-select{flex:1;background:var(--s2);border:1px solid var(--bd2);border-radius:9px;color:var(--tx);font-family:var(--fh);font-size:13px;font-weight:700;padding:8px 12px;cursor:pointer;outline:none;-webkit-appearance:none;appearance:none}
        .gpx-select:focus{border-color:var(--ac)}
        .gpx-input{flex:1;background:var(--s2);border:1px solid var(--bd2);border-radius:9px;color:var(--tx);font-family:var(--fb);font-size:13px;padding:9px 12px;outline:none}
        .gpx-input::placeholder{color:var(--tm)}
        .gpx-input:focus{border-color:var(--ac)}
        .gpx-btn{padding:9px 14px;border-radius:9px;border:1px solid var(--bd2);font-family:var(--fh);font-size:12px;font-weight:800;letter-spacing:.8px;text-transform:uppercase;cursor:pointer;display:flex;align-items:center;justify-content:center;gap:6px;transition:all .15s;white-space:nowrap}
        .gpx-btn:active{transform:scale(.93)}
        .gpx-btn.prim{background:var(--ac);border-color:var(--ac);color:var(--bg)}
        .gpx-btn.prim:active{background:var(--acd)}
        .gpx-btn.sec{background:var(--s2);color:var(--tx)}
        .gpx-btn.danger{background:rgba(239,68,68,.15);border-color:rgba(239,68,68,.4);color:#ef4444}
        /* File-Input versteckt, styled Button darüber */
        #gpx-file-input{display:none}
        .gpx-file-label{display:flex;align-items:center;justify-content:center;gap:8px;padding:14px;border:1.5px dashed var(--bd2);border-radius:12px;color:var(--td);font-family:var(--fh);font-size:13px;font-weight:700;letter-spacing:.5px;text-transform:uppercase;cursor:pointer;transition:all .2s;text-align:center}
        .gpx-file-label:hover,.gpx-file-label:active{border-color:var(--ac);color:var(--ac);background:rgba(200,255,0,.05)}
        /* Track Liste */
        .trk-row{display:flex;align-items:center;gap:10px;padding:10px 16px;border-bottom:1px solid var(--bd);transition:background .12s}
        .trk-row:last-child{border-bottom:none}
        .trk-dot{width:12px;height:12px;border-radius:3px;flex-shrink:0}
        .trk-inf{flex:1;min-width:0}
        .trk-nm{font-family:var(--fh);font-size:14px;font-weight:700;color:var(--tx);white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
        .trk-meta{font-size:10px;color:var(--td);margin-top:1px}
        .trk-btns{display:flex;gap:5px;flex-shrink:0}
        .trk-btn{width:32px;height:32px;border-radius:8px;background:var(--s2);border:1px solid var(--bd);color:var(--td);cursor:pointer;display:flex;align-items:center;justify-content:center;transition:all .15s}
        .trk-btn:active{transform:scale(.86)}
        .trk-btn.on{background:var(--ac);border-color:var(--ac);color:var(--bg)}
        /* Aufnahme / Recording */
        .rec-timer{font-family:var(--fh);font-size:42px;font-weight:800;letter-spacing:2px;color:var(--tx);text-align:center;padding:16px 0 8px;line-height:1}
        .rec-status{font-family:var(--fh);font-size:11px;font-weight:700;letter-spacing:2px;text-transform:uppercase;text-align:center;margin-bottom:14px}
        .rec-stats{display:flex;gap:12px;padding:0 16px 14px}
        .rec-stat{flex:1;background:var(--s2);border-radius:10px;padding:10px;text-align:center}
        .rec-stat-val{font-family:var(--fh);font-size:20px;font-weight:800;color:var(--tx);line-height:1.1}
        .rec-stat-lbl{font-family:var(--fh);font-size:9px;font-weight:700;letter-spacing:1.5px;text-transform:uppercase;color:var(--tm);margin-top:2px}
        .rec-controls{display:flex;gap:8px;padding:0 16px 14px}
        #rec-bar{position:fixed;top:max(66px,calc(env(safe-area-inset-top,0px)+66px));left:50%;transform:translateX(-50%) translateY(-6px);z-index:498;display:flex;align-items:center;gap:8px;background:rgba(239,68,68,.9);border-radius:20px;padding:5px 14px 5px 10px;opacity:0;visibility:hidden;transition:all .3s;backdrop-filter:blur(8px)}
        #rec-bar.show{opacity:1;visibility:visible;transform:translateX(-50%) translateY(0)}
        .rec-dot{width:8px;height:8px;border-radius:50%;background:#fff;animation:pulse-rec 1.4s ease-in-out infinite}
        @keyframes pulse-rec{0%,100%{opacity:1;transform:scale(1)}50%{opacity:.5;transform:scale(.75)}}
        .rec-bar-txt{font-family:var(--fh);font-size:12px;font-weight:700;letter-spacing:.5px;color:#fff}
        /* Kategorie-Filter im GPX-Panel */
        .cat-filter-row{display:flex;gap:6px;flex-wrap:wrap;padding:10px 16px 14px}
        .cat-fbtn{padding:6px 12px;border-radius:20px;border:1px solid var(--bd2);font-family:var(--fh);font-size:11px;font-weight:700;letter-spacing:.8px;text-transform:uppercase;background:var(--s2);color:var(--td);cursor:pointer;transition:all .2s}
        .cat-fbtn:active{transform:scale(.93)}
        .cat-fbtn.on{border-color:transparent;color:#000}
        .cat-fbtn[data-c=beginner].on{background:#27AE60}
        .cat-fbtn[data-c=mittel].on{background:#D4A017}
        .cat-fbtn[data-c=expert].on{background:#ef4444}
        .cat-fbtn[data-c=all].on{background:var(--tx)}
        /* Fab Nummer-Badge */
        .fab-badge{position:absolute;top:-4px;right:-4px;background:var(--ac);color:var(--bg);border-radius:8px;font-family:var(--fh);font-size:10px;font-weight:800;padding:1px 5px;line-height:1.4;pointer-events:none}
        #gpx-fab{position:relative}
        /* CORS Hint */
        .cors-hint{font-size:11px;color:var(--td);margin-top:6px;line-height:1.5}
        .cors-hint a{color:var(--ac)}

        /* ── NAVIGATION HUD ─────────────────────────────────── */
        @keyframes navPulse{0%,100%{transform:translateX(-50%) scale(1)}50%{transform:translateX(-50%) scale(1.025)}}
        @keyframes navArrowBounce{0%,100%{transform:none}50%{transform:translateY(-3px)}}
        @keyframes navWrongWay{0%,100%{background:var(--s1)}50%{background:rgba(239,68,68,.12)}}
        #nav-hud{
          position:fixed;top:max(118px,calc(env(safe-area-inset-top,0px)+118px));
          left:50%;transform:translateX(-50%) translateY(-6px);
          z-index:600;background:var(--s1);
          border:1.5px solid var(--bd2);border-radius:18px;
          padding:12px 14px 10px;
          display:flex;align-items:center;gap:12px;
          box-shadow:0 8px 32px rgba(0,0,0,.65);
          min-width:280px;max-width:340px;
          transition:opacity .35s,visibility .35s,transform .35s cubic-bezier(.32,.72,0,1);
          opacity:0;visibility:hidden;pointer-events:none;will-change:transform;
        }
        #nav-hud.show{opacity:1;visibility:visible;pointer-events:all;transform:translateX(-50%) translateY(0)}
        #nav-hud.nav-close{animation:navPulse .6s ease-in-out}
        #nav-hud.nav-offroute{animation:navWrongWay 1s ease-in-out infinite;border-color:#ef4444}
        /* Arrow container — big, round, animated */
        #nav-hud .nh-arrow-wrap{
          width:52px;height:52px;border-radius:14px;
          background:var(--ac);display:flex;align-items:center;justify-content:center;
          flex-shrink:0;transition:background .3s;
        }
        #nav-hud.nav-offroute .nh-arrow-wrap{background:#ef4444}
        #nav-hud.nav-ontrack .nh-arrow-wrap{background:#22c55e}
        #nav-hud .nh-arrow{
          font-size:28px;line-height:1;
          display:block;color:#000;
          transition:transform .4s cubic-bezier(.34,1.56,.64,1);
        }
        #nav-hud.nav-offroute .nh-arrow{color:#fff}
        #nav-hud.nav-ontrack .nh-arrow{color:#000}
        #nav-hud.nav-close .nh-arrow{animation:navArrowBounce .5s ease-in-out infinite}
        #nav-hud .nh-txt{flex:1;min-width:0}
        #nav-hud .nh-mode{font-family:var(--fh);font-size:9px;font-weight:700;letter-spacing:1px;text-transform:uppercase;color:var(--td);margin-bottom:1px;display:flex;align-items:center;gap:4px}
        #nav-hud .nh-mode .nh-dot{width:6px;height:6px;border-radius:50%;background:var(--ac);display:inline-block;animation:navArrowBounce 1s ease-in-out infinite}
        #nav-hud.nav-offroute .nh-mode .nh-dot{background:#ef4444}
        #nav-hud .nh-title{font-family:var(--fh);font-size:13px;font-weight:800;color:var(--tx);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;line-height:1.2}
        #nav-hud .nh-dist{font-family:var(--fh);font-size:22px;font-weight:900;color:var(--ac);line-height:1.1;font-variant-numeric:tabular-nums;letter-spacing:-.5px}
        #nav-hud.nav-offroute .nh-dist{color:#ef4444}
        #nav-hud .nh-sub{font-size:10px;color:var(--td);margin-top:2px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
        #nav-hud .nh-offroute-warn{font-size:11px;font-weight:700;color:#ef4444;margin-top:3px;display:none}
        #nav-hud.nav-offroute .nh-offroute-warn{display:block}
        #nav-hud .nh-gmaps{display:inline-flex;align-items:center;gap:4px;font-size:10px;color:var(--log);text-decoration:none;margin-top:3px}
        #nav-hud .nh-close{
          background:var(--s3);border:1px solid var(--bd2);border-radius:10px;
          color:var(--td);width:30px;height:30px;
          cursor:pointer;padding:0;line-height:1;
          display:flex;align-items:center;justify-content:center;
          flex-shrink:0;font-size:16px;align-self:flex-start;transition:all .15s;
        }
        #nav-hud .nh-close:active{background:var(--s2);transform:scale(.9)}

        /* ── RACE OVERLAY ────────────────────────────────────── */
        #race-overlay{position:fixed;inset:0;z-index:2000;display:flex;flex-direction:column;align-items:center;justify-content:center;background:var(--bg);transition:background .3s;opacity:0;visibility:hidden;pointer-events:none}
        #race-overlay.show{opacity:1;visibility:visible;pointer-events:all}
        #race-overlay.flash-red{background:#c0392b !important}
        @keyframes race-flash{0%,100%{background:#c0392b}50%{background:#e74c3c}}
        #race-overlay.flash-anim{animation:race-flash .3s ease-in-out 3}
        .race-overlay-x{position:absolute;top:max(14px,env(safe-area-inset-top,14px));right:14px;background:rgba(255,255,255,.1);border:1px solid rgba(255,255,255,.15);color:rgba(255,255,255,.7);font-size:18px;width:34px;height:34px;border-radius:50%;cursor:pointer;display:none;align-items:center;justify-content:center;z-index:1;line-height:1;padding:0}
        #race-overlay.show .race-overlay-x{display:flex}

        /* Approaching page */
        .race-approaching{text-align:center;padding:24px 20px;width:100%;max-width:360px}
        .race-approaching .ra-icon{font-size:44px;margin-bottom:10px}
        .race-approaching .ra-title{font-family:var(--fh);font-size:16px;font-weight:800;letter-spacing:1px;text-transform:uppercase;color:var(--tx);margin-bottom:4px}
        .race-approaching .ra-track{font-size:12px;color:var(--td);margin-bottom:18px;max-width:260px;margin-inline:auto}
        .race-approaching .ra-num{font-family:var(--fh);font-size:80px;font-weight:800;line-height:1;color:var(--ac);margin-bottom:2px;font-variant-numeric:tabular-nums}
        .race-approaching .ra-unit{font-family:var(--fh);font-size:14px;color:var(--td);text-transform:uppercase;letter-spacing:.8px;margin-bottom:16px}
        .race-approaching .ra-acc{font-size:11px;color:var(--tm)}
        .race-approaching .ra-hint{font-size:12px;color:var(--td);margin-top:8px;padding:8px 12px;background:var(--s2);border-radius:8px}

        /* Start line page (<= 5m) */
        .race-startline{text-align:center;padding:20px;width:100%;max-width:360px}
        .race-startline .rsl-label{font-family:var(--fh);font-size:11px;font-weight:700;letter-spacing:1px;text-transform:uppercase;color:var(--td);margin-bottom:10px}
        .rsl-vis{display:flex;align-items:center;justify-content:center;width:min(300px,88vw);height:56px;margin:0 auto 16px;background:repeating-linear-gradient(90deg,rgba(196,255,0,.05),rgba(196,255,0,.05) 16px,transparent 16px,transparent 17px);border-top:3px solid var(--ac);border-bottom:3px solid var(--ac);position:relative;box-shadow:0 0 20px rgba(196,255,0,.2)}
        .rsl-vis-text{font-family:var(--fh);font-size:18px;font-weight:900;letter-spacing:4px;color:var(--ac);text-shadow:0 0 12px rgba(196,255,0,.6)}
        .race-startline .rsl-dist{font-family:var(--fh);font-size:68px;font-weight:800;line-height:1;color:#fff;margin-bottom:4px;transition:color .2s;font-variant-numeric:tabular-nums}
        .race-startline .rsl-dist.green{color:#4ade80}
        .race-startline .rsl-unit{font-family:var(--fh);font-size:13px;color:var(--td);text-transform:uppercase;letter-spacing:.8px;margin-bottom:12px}
        .race-startline .rsl-hint{font-family:var(--fh);font-size:13px;font-weight:700;letter-spacing:.8px;text-transform:uppercase;color:var(--td);margin-bottom:6px}
        .race-startline .rsl-acc{font-size:10px;color:var(--tm)}
        @keyframes pulse-green{0%,100%{box-shadow:0 0 0 rgba(74,222,128,.4)}50%{box-shadow:0 0 24px rgba(74,222,128,.5)}}
        .rsl-vis.ready{border-color:#4ade80;animation:pulse-green 1s ease-in-out infinite}
        .rsl-vis.ready .rsl-vis-text{color:#4ade80;text-shadow:0 0 12px rgba(74,222,128,.7)}

        /* GO! page */
        .race-go-page{text-align:center;padding:20px;width:100%}
        .race-go-page .rg-go{font-family:var(--fh);font-size:100px;font-weight:900;letter-spacing:6px;color:var(--beg);line-height:1;animation:go-pop .45s cubic-bezier(.36,.07,.19,.97)}
        @keyframes go-pop{0%{transform:scale(.3);opacity:0}80%{transform:scale(1.15)}100%{transform:scale(1);opacity:1}}
        .race-go-page .rg-sub{font-family:var(--fh);font-size:14px;font-weight:700;letter-spacing:1px;text-transform:uppercase;color:var(--td);margin-top:12px}

        /* Running page */
        .race-running{text-align:center;padding:16px;width:100%;max-width:420px}
        .race-running .rr-name{font-family:var(--fh);font-size:11px;font-weight:700;letter-spacing:1px;text-transform:uppercase;color:var(--td);margin-bottom:8px}
        .race-running .rr-timer{font-family:var(--fh);font-size:58px;font-weight:800;letter-spacing:2px;color:var(--ac);line-height:1;margin-bottom:4px;font-variant-numeric:tabular-nums}
        .race-running .rr-timer.paused{color:var(--td)}
        @keyframes blink-td{50%{opacity:.25}}
        .race-running .rr-timer.paused{animation:blink-td 1s step-start infinite}
        .race-running .rr-pause-lbl{font-family:var(--fh);font-size:10px;font-weight:700;letter-spacing:.8px;text-transform:uppercase;color:var(--exp);min-height:14px;margin-bottom:8px}
        .rr-splits-grid{display:grid;grid-template-columns:repeat(4,1fr);gap:5px;margin:8px 0 12px}
        .rr-split-box{background:var(--s2);border-radius:8px;padding:7px 3px;text-align:center;border:1px solid transparent}
        .rr-split-box.active{background:rgba(56,189,248,.1);border-color:rgba(56,189,248,.3);animation:pulse-blue .9s ease-in-out infinite alternate}
        @keyframes pulse-blue{from{box-shadow:0 0 2px rgba(56,189,248,.1)}to{box-shadow:0 0 10px rgba(56,189,248,.4)}}
        .rr-split-box.done{background:rgba(196,255,0,.07);border-color:rgba(196,255,0,.18)}
        .rr-split-lbl{font-family:var(--fh);font-size:9px;font-weight:700;letter-spacing:.5px;text-transform:uppercase;color:var(--td)}
        .rr-split-val{font-family:var(--fh);font-size:15px;font-weight:800;color:var(--ac);margin-top:2px;font-variant-numeric:tabular-nums}
        .rr-split-val.empty{color:var(--tm);font-size:12px}
        .rr-speed-lbl{font-size:11px;color:var(--td);margin-bottom:12px}
        .rr-abort-btn{background:var(--s2);border:1px solid var(--bd2);color:var(--td);font-family:var(--fh);font-size:11px;font-weight:700;letter-spacing:.8px;text-transform:uppercase;padding:8px 18px;border-radius:8px;cursor:pointer;margin-top:4px}
        .rr-confirm-box{display:none;background:var(--s2);border-radius:10px;padding:12px;margin-top:8px;border:1px solid var(--bd2)}
        .rr-confirm-box.show{display:block}
        .rr-confirm-q{font-size:13px;color:var(--tx);text-align:center;margin-bottom:10px}
        .rr-confirm-btns{display:flex;gap:8px}
        .rr-confirm-btns button{flex:1;padding:8px;border-radius:8px;border:none;font-family:var(--fh);font-size:12px;font-weight:700;letter-spacing:.6px;cursor:pointer}

        /* Results page */
        .race-results{text-align:center;padding:16px;width:100%;max-width:400px;overflow-y:auto;max-height:90svh}
        .race-results .rres-crown{font-size:36px;margin-bottom:6px}
        .race-results .rres-title{font-family:var(--fh);font-size:20px;font-weight:800;letter-spacing:1px;text-transform:uppercase;color:var(--ac);margin-bottom:2px}
        .race-results .rres-track{font-size:12px;color:var(--td);margin-bottom:14px}
        .race-results .rres-total-time{font-family:var(--fh);font-size:52px;font-weight:800;color:var(--ac);line-height:1;font-variant-numeric:tabular-nums}
        .race-results .rres-total-lbl{font-size:11px;color:var(--td);text-transform:uppercase;letter-spacing:.6px;margin-bottom:16px}
        .rres-splits-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin-bottom:16px}
        .rres-split-card{background:var(--s2);border-radius:8px;padding:9px 8px;text-align:center}
        .rres-split-lbl{font-family:var(--fh);font-size:9px;font-weight:700;letter-spacing:.6px;text-transform:uppercase;color:var(--td);margin-bottom:3px}
        .rres-split-val{font-family:var(--fh);font-size:20px;font-weight:800;color:var(--tx);font-variant-numeric:tabular-nums}
        .rres-lb-head{font-family:var(--fh);font-size:11px;font-weight:700;letter-spacing:.8px;text-transform:uppercase;color:var(--td);margin:14px 0 8px;text-align:left}
        .rres-lb-row{display:flex;align-items:center;gap:8px;padding:7px 9px;border-radius:8px;background:var(--s2);margin-bottom:5px}
        .rres-lb-row.gold-row{background:rgba(245,158,11,.08);border:1px solid rgba(245,158,11,.2)}
        .rres-lb-row.cur-row{border:1px solid var(--log)}
        .rres-lb-rank{font-family:var(--fh);font-size:14px;font-weight:800;color:var(--td);width:22px;text-align:center;flex-shrink:0}
        .rres-lb-rank.gold{color:#f59e0b}
        .rres-lb-date{font-size:10px;color:var(--tm);flex:1;text-align:left}
        .rres-lb-time{font-family:var(--fh);font-size:18px;font-weight:800;color:var(--ac);font-variant-numeric:tabular-nums}
        .rres-actions{display:flex;gap:8px;margin-top:14px}
        .rres-btn{flex:1;padding:11px;border-radius:10px;border:none;font-family:var(--fh);font-size:12px;font-weight:700;letter-spacing:.7px;text-transform:uppercase;cursor:pointer}
        .rres-btn.prim{background:var(--ac);color:#0b0e14}
        .rres-btn.sec{background:var(--s2);color:var(--td)}

        /* ── TRACK DETAIL PANEL ─────────────────────────────── */
        .trk-detail{background:var(--s2);border-radius:10px;padding:12px 14px;margin:0 12px 8px;border:1px solid var(--bd2)}
        .trk-detail .tdd-head{display:flex;align-items:center;gap:8px;margin-bottom:10px}
        .trk-detail .tdd-dot{width:9px;height:9px;border-radius:50%;flex-shrink:0}
        .trk-detail .tdd-name{font-family:var(--fh);font-size:14px;font-weight:800;letter-spacing:.4px;color:var(--tx);flex:1;min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
        .trk-detail .tdd-close{background:none;border:none;color:var(--td);font-size:18px;cursor:pointer;padding:0;line-height:1}
        .tdd-stats{display:flex;gap:5px;margin-bottom:10px}
        .tdd-stat{flex:1;background:var(--s3);border-radius:6px;padding:6px 4px;text-align:center}
        .tdd-stat-val{font-family:var(--fh);font-size:15px;font-weight:800;color:var(--tx)}
        .tdd-stat-lbl{font-size:9px;text-transform:uppercase;letter-spacing:.5px;color:var(--td);margin-top:1px}
        .tdd-btns{display:flex;flex-direction:column;gap:6px}
        .tdd-btn{width:100%;padding:10px;border-radius:8px;border:none;font-family:var(--fh);font-size:12px;font-weight:700;letter-spacing:.8px;text-transform:uppercase;cursor:pointer;display:flex;align-items:center;justify-content:center;gap:7px;text-decoration:none}
        .tdd-btn.race{background:var(--ac);color:#0b0e14}
        .tdd-btn.navi{background:transparent;color:var(--log);border:1px solid rgba(56,189,248,.4)}
        .tdd-btn.gmaps{background:transparent;color:var(--td);border:1px solid var(--bd2)}
        .tdd-lb{margin-top:10px}
        .tdd-lb-head{font-family:var(--fh);font-size:10px;font-weight:700;letter-spacing:.8px;text-transform:uppercase;color:var(--td);margin-bottom:7px}
        .tdd-lb-empty{font-size:11px;color:var(--tm);text-align:center;padding:6px}
        .tdd-lb-row{display:flex;align-items:center;gap:7px;padding:5px 8px;border-radius:6px;background:var(--s3);margin-bottom:3px}
        .tdd-lb-row.gold-lb{background:rgba(245,158,11,.07)}
        .tdd-lb-rank{font-family:var(--fh);font-size:12px;font-weight:800;color:var(--td);width:18px;text-align:center;flex-shrink:0}
        .tdd-lb-rank.gold{color:#f59e0b}
        .tdd-lb-time{font-family:var(--fh);font-size:17px;font-weight:800;color:var(--ac);margin-left:auto;font-variant-numeric:tabular-nums}
        .tdd-lb-date{font-size:10px;color:var(--tm);flex:1}
        .tdd-lb-export{margin-top:7px;width:100%;padding:7px;border-radius:6px;background:var(--s3);border:1px solid var(--bd);color:var(--td);font-family:var(--fh);font-size:10px;font-weight:700;letter-spacing:.6px;text-transform:uppercase;cursor:pointer}

        /* Checkpoint markers on map */
        /* Checkpoint-Größe wird per inline style aus JS gesetzt (skalierbar) */
        .chk-div{border-radius:50%;background:rgba(196,255,0,.3);border:2.5px solid var(--ac);box-shadow:0 0 6px rgba(196,255,0,.4)}
        .chk-div.finish{background:rgba(239,68,68,.3);border-color:var(--exp);box-shadow:0 0 6px rgba(239,68,68,.4)}

        /* ── START MARKER ────────────────────────────────────────── */
        /* Breite/Höhe werden dynamisch per JS (inline style) gesetzt */
        .start-pin{display:flex;align-items:center;justify-content:center;border-radius:50% 50% 50% 0;transform:rotate(-45deg);border:2.5px solid rgba(255,255,255,.9);box-shadow:0 2px 12px rgba(0,0,0,.65);cursor:pointer;transition:transform .15s,box-shadow .15s}
        .start-pin:hover,.start-pin:active{transform:rotate(-45deg) scale(1.15);box-shadow:0 4px 18px rgba(0,0,0,.8)}
        .start-pin-flag{transform:rotate(45deg);line-height:1;user-select:none;pointer-events:none}

        /* ── FINISH MARKER ───────────────────────────────────────── */
        /* Breite/Höhe werden dynamisch per JS (inline style) gesetzt */
        .finish-pin{display:flex;align-items:center;justify-content:center;border-radius:50% 50% 50% 0;transform:rotate(-45deg);border:2.5px solid rgba(255,255,255,.9);box-shadow:0 2px 12px rgba(0,0,0,.65);cursor:pointer;background:#1a1a2e;transition:transform .15s,box-shadow .15s}
        .finish-pin:hover,.finish-pin:active{transform:rotate(-45deg) scale(1.15);box-shadow:0 4px 18px rgba(0,0,0,.8)}
        .finish-pin-flag{transform:rotate(45deg);line-height:1;user-select:none;pointer-events:none}

        /* ── TRACK POPUP (Start / Finish Leaflet popup) ──────────── */
        .trk-popup-wrap .leaflet-popup-content-wrapper{background:var(--s1,#141620);border:1px solid var(--bd2,#2a2d3a);border-radius:14px;padding:0;box-shadow:0 8px 32px rgba(0,0,0,.7);min-width:230px;max-width:272px}
        .trk-popup-wrap .leaflet-popup-tip-container{margin-top:-1px}
        .trk-popup-wrap .leaflet-popup-tip{background:var(--s1,#141620)}
        .trk-popup-wrap .leaflet-popup-content{margin:0;padding:0}
        .trk-popup-wrap .leaflet-popup-close-button{color:var(--td,#666);font-size:18px;top:8px;right:10px}
        .tpop{padding:14px 14px 10px}
        .tpop-badge{display:inline-block;font-family:var(--fh,'Barlow Condensed');font-size:10px;font-weight:800;letter-spacing:.8px;text-transform:uppercase;padding:3px 8px;border-radius:20px;color:#000;margin-bottom:6px}
        .tpop-name{font-family:var(--fh,'Barlow Condensed');font-size:18px;font-weight:800;letter-spacing:.3px;color:var(--tx,#eee);line-height:1.15;margin-bottom:3px}
        .tpop-meta{font-size:11px;color:var(--td,#888);margin-bottom:5px}
        .tpop-gps{font-family:monospace;font-size:10px;color:var(--td,#888);background:var(--s2,#1c1f2e);border-radius:6px;padding:4px 7px;margin-bottom:10px;cursor:pointer;user-select:all}
        .tpop-gps:hover{color:var(--ac,#c8ff00)}
        .tpop-acts{display:grid;grid-template-columns:1fr 1fr;gap:6px;padding:8px 14px 12px}
        .tpop-btn{display:flex;align-items:center;justify-content:center;gap:5px;font-family:var(--fh,'Barlow Condensed');font-size:12px;font-weight:700;letter-spacing:.4px;text-transform:uppercase;border:none;border-radius:9px;padding:9px 6px;cursor:pointer;transition:opacity .12s,transform .1s;text-decoration:none}
        .tpop-btn:active{transform:scale(.94)}
        .tpop-btn.navi{background:var(--ac,#c8ff00);color:#000}
        .tpop-btn.race{background:#c8ff00;color:#000}
        .tpop-btn.sec{background:var(--s3,#22263a);color:var(--tx,#eee);border:1px solid var(--bd2,#2a2d3a)}
        .tpop-sep{border:none;border-top:1px solid var(--bd2,#2a2d3a);margin:0}

        /* ── CANVAS APPROACH PAGE ─────────────────────────────────── */
        #rp-approach{position:absolute;inset:0;overflow:hidden;background:#0b0e14;display:none}
        #approach-canvas{display:block;position:absolute;inset:0;width:100%;height:100%}
        #approach-confirm{position:absolute;bottom:0;left:0;right:0;display:none;flex-direction:column;align-items:center;gap:14px;padding:24px 24px 48px;background:linear-gradient(transparent,rgba(11,14,20,.95) 35%);z-index:3}
        #approach-confirm.show{display:flex}
        .approach-confirm-q{font-family:var(--fh);font-size:16px;font-weight:800;color:#fff;letter-spacing:.8px;text-transform:uppercase;text-align:center;line-height:1.4}
        .approach-confirm-btns{display:flex;gap:12px;width:100%;max-width:300px}
        .approach-confirm-btns button{flex:1;font-family:var(--fh);font-size:14px;font-weight:800;letter-spacing:1px;text-transform:uppercase;border:none;border-radius:12px;padding:16px 14px;cursor:pointer;transition:transform .12s}
        .approach-confirm-btns button:active{transform:scale(.95)}
        .approach-btn-yes{background:#c8ff00;color:#0b0e14}
        .approach-btn-no{background:rgba(255,255,255,.1);color:rgba(255,255,255,.8);border:1px solid rgba(255,255,255,.2)!important}

        /* ── TRACK DETAIL SLOT ───────────────────────────────────── */
        .trk-detail-loading{background:var(--s2);border-radius:10px;padding:14px;margin:0 12px 8px;border:1px solid var(--bd2);text-align:center;color:var(--td);font-size:11px;font-style:italic}

        /* ── RACE RESULTS QR ─────────────────────────────────────── */
        .rres-qr-wrap{background:#fff;border-radius:10px;padding:8px;width:136px;height:136px;margin:12px auto;display:flex;align-items:center;justify-content:center}
        .rres-qr-wrap canvas{border-radius:4px;image-rendering:pixelated;image-rendering:crisp-edges}

        /* ── PROFIL TAB ──────────────────────────────────────────── */
        .profile-avatar{width:56px;height:56px;border-radius:50%;background:var(--ac);display:flex;align-items:center;justify-content:center;font-size:26px;flex-shrink:0;box-shadow:0 0 16px rgba(200,255,0,.3);transition:background .2s,box-shadow .2s}
        /* Avatar picker */
        .pf-av-emoji-row{display:flex;flex-wrap:wrap;gap:5px;margin-bottom:8px}
        .pf-av-em{width:36px;height:36px;border-radius:9px;border:2px solid var(--bd2);background:var(--s2);font-size:20px;cursor:pointer;display:flex;align-items:center;justify-content:center;transition:all .12s;flex-shrink:0}
        .pf-av-em.sel{border-color:var(--ac);background:var(--s3);box-shadow:0 0 0 2px var(--ac)}
        .pf-av-em:active{transform:scale(.88)}
        .pf-av-color-row{display:flex;gap:7px;flex-wrap:wrap;margin-top:2px}
        .pf-av-col{width:26px;height:26px;border-radius:50%;border:2.5px solid transparent;cursor:pointer;transition:all .15s;box-shadow:0 2px 5px rgba(0,0,0,.4);flex-shrink:0}
        .pf-av-col.sel{border-color:#fff;box-shadow:0 0 0 3px var(--ac),0 2px 5px rgba(0,0,0,.4);transform:scale(1.18)}
        .pf-av-col:active{transform:scale(.9)}
        .profile-name-display{font-family:var(--fh);font-size:18px;font-weight:900;letter-spacing:.4px;color:var(--tx)}
        .profile-muni-display{font-family:var(--fh);font-size:13px;font-weight:700;color:var(--ac);margin-top:1px}
        .profile-muni-card{background:linear-gradient(135deg,var(--s2),var(--s3));border-radius:12px;padding:14px;border:1px solid var(--bd2);margin-bottom:10px}
        .profile-detail-row{display:flex;gap:6px;margin-top:8px;flex-wrap:wrap}
        .profile-detail-chip{flex:1;min-width:calc(50% - 3px);background:var(--s3);border-radius:8px;padding:7px 9px;box-sizing:border-box}
        .profile-detail-chip-lbl{font-family:var(--fh);font-size:9px;font-weight:700;letter-spacing:.5px;text-transform:uppercase;color:var(--td);margin-bottom:2px}
        .profile-detail-chip-val{font-family:var(--fh);font-size:13px;font-weight:800;color:var(--tx);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
        .profile-quick-btns{display:flex;gap:5px;flex-wrap:wrap;margin-top:6px}
        .profile-quick-btn{padding:5px 10px;border-radius:6px;background:var(--s3);border:1px solid var(--bd2);color:var(--td);font-family:var(--fh);font-size:10px;font-weight:700;letter-spacing:.4px;cursor:pointer;transition:background .12s,color .12s}
        .profile-quick-btn:hover{background:rgba(200,255,0,.12);color:var(--ac);border-color:rgba(200,255,0,.3)}
        /* ── RUN DETAIL MODAL ─────────────────────────────────────── */
        #run-detail-modal{position:fixed;inset:0;z-index:3000;background:var(--bg);display:flex;flex-direction:column;transform:translateY(100%);transition:transform .32s cubic-bezier(.4,0,.2,1);overflow:hidden}
        #run-detail-modal.show{transform:translateY(0)}
        .rdm-header{display:flex;align-items:center;gap:10px;padding:max(14px,env(safe-area-inset-top,14px)) 16px 12px;border-bottom:1px solid var(--bd2);flex-shrink:0}
        .rdm-header-title{font-family:var(--fh);font-size:15px;font-weight:800;letter-spacing:.5px;text-transform:uppercase;color:var(--tx);flex:1}
        .rdm-body{flex:1;overflow-y:auto;padding:16px;-webkit-overflow-scrolling:touch}
        .rdm-rider-card{background:var(--s2);border-radius:12px;padding:13px 14px;border:1px solid var(--bd2);margin-bottom:12px;display:flex;align-items:center;gap:12px}
        .rdm-rider-info{flex:1;min-width:0}
        .rdm-rider-name{font-family:var(--fh);font-size:19px;font-weight:900;letter-spacing:.4px;color:var(--tx);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
        .rdm-muni-name{font-family:var(--fh);font-size:13px;font-weight:700;color:var(--ac);margin-top:1px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
        .rdm-muni-chips{display:flex;gap:4px;flex-wrap:wrap;margin-top:5px}
        .rdm-chip{font-family:var(--fh);font-size:9px;font-weight:700;letter-spacing:.4px;text-transform:uppercase;padding:2px 7px;border-radius:20px;background:var(--s3);color:var(--td);border:1px solid var(--bd2);white-space:nowrap}
        .rdm-chip.accent{color:var(--ac);border-color:rgba(200,255,0,.3);background:rgba(200,255,0,.07)}
        .rdm-time-section{text-align:center;margin:12px 0 4px}
        .rdm-time-big{font-family:var(--fh);font-size:62px;font-weight:900;color:var(--ac);line-height:1;font-variant-numeric:tabular-nums}
        .rdm-time-lbl{font-size:11px;color:var(--td);text-transform:uppercase;letter-spacing:.6px;margin-bottom:4px}
        .rdm-track-meta{font-size:12px;color:var(--td);text-align:center;margin-bottom:14px}
        .rdm-section-lbl{font-family:var(--fh);font-size:10px;font-weight:700;letter-spacing:.6px;text-transform:uppercase;color:var(--td);margin:12px 0 7px}
        .rdm-splits-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin-bottom:2px}
        .rdm-split-card{background:var(--s2);border-radius:9px;padding:9px 10px;text-align:center;border:1px solid var(--bd2)}
        .rdm-split-lbl{font-family:var(--fh);font-size:9px;font-weight:700;letter-spacing:.6px;text-transform:uppercase;color:var(--td);margin-bottom:3px}
        .rdm-split-val{font-family:var(--fh);font-size:21px;font-weight:800;color:var(--tx);font-variant-numeric:tabular-nums}
        .rdm-falls-row{display:flex;gap:5px;flex-wrap:wrap;margin:6px 0}
        .rdm-fall-badge{font-family:var(--fh);font-size:10px;font-weight:700;padding:3px 8px;border-radius:20px;background:rgba(239,68,68,.12);color:#f87171;border:1px solid rgba(239,68,68,.25)}
        .rdm-sig-box{background:var(--s2);border-radius:8px;padding:9px 11px;margin-top:10px;border:1px solid rgba(200,255,0,.18)}
        .rdm-sig-lbl{font-family:var(--fh);font-size:9px;font-weight:700;letter-spacing:.5px;text-transform:uppercase;color:var(--td);margin-bottom:3px}
        .rdm-sig-val{font-family:monospace;font-size:10px;color:var(--ac);word-break:break-all;line-height:1.5}
        .rdm-actions{display:flex;gap:8px;margin-top:16px;padding-bottom:max(16px,env(safe-area-inset-bottom,16px))}
        .rdm-btn{flex:1;padding:12px;border-radius:10px;border:none;font-family:var(--fh);font-size:12px;font-weight:700;letter-spacing:.7px;text-transform:uppercase;cursor:pointer;transition:opacity .12s}
        .rdm-btn:active{opacity:.75}
        .rdm-btn.prim{background:var(--ac);color:#0b0e14}
        .rdm-btn.sec{background:var(--s2);color:var(--td);border:1px solid var(--bd2)}
        /* Clickable leaderboard row helpers */
        .cursor-ptr{cursor:pointer}
        .tdd-lb-name{font-family:var(--fh);font-size:12px;font-weight:800;color:var(--tx);flex:1;text-align:left;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
        .rres-lb-name{font-family:var(--fh);font-size:11px;font-weight:800;color:var(--tx);flex:1;text-align:left;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
        /* ── RACE SENSOR BADGES ──────────────────────────────────── */
        .ra-sensors-row{display:flex;gap:6px;justify-content:center;flex-wrap:wrap;margin-top:10px}
        .ra-sensor-badge{display:inline-flex;align-items:center;gap:4px;font-family:var(--fh);font-size:10px;font-weight:700;letter-spacing:.4px;padding:3px 8px;border-radius:20px;background:var(--s3);color:var(--td);border:1px solid var(--bd2)}
        .ra-sensor-badge.ok{color:#4ade80;border-color:rgba(74,222,128,.3);background:rgba(74,222,128,.08)}
        .ra-sensor-badge.warn{color:#f59e0b;border-color:rgba(245,158,11,.3);background:rgba(245,158,11,.08)}
        .ra-bt-btn{margin-top:10px;padding:8px;width:100%;background:rgba(56,189,248,.08);color:var(--log);border:1px solid rgba(56,189,248,.25);border-radius:8px;font-family:var(--fh);font-size:10px;font-weight:700;letter-spacing:.5px;cursor:pointer;text-align:center}
        /* Fall badge in running page */
        .rr-fall-row{min-height:18px;margin-bottom:4px;display:flex;gap:5px;flex-wrap:wrap;justify-content:center}
        .rr-fall-badge{font-family:var(--fh);font-size:10px;font-weight:700;padding:2px 8px;border-radius:20px;background:rgba(239,68,68,.15);color:#f87171;border:1px solid rgba(239,68,68,.3)}
        /* Signature box in results */
        .rres-sig-box{background:var(--s2);border-radius:8px;padding:8px 10px;margin:8px 0;border:1px solid rgba(196,255,0,.2);text-align:left}
        .rres-sig-lbl{font-family:var(--fh);font-size:9px;font-weight:700;letter-spacing:.5px;text-transform:uppercase;color:var(--td);margin-bottom:3px}
        .rres-sig-val{font-family:monospace;font-size:10px;color:var(--ac);word-break:break-all;line-height:1.5}


        /* ── SETTINGS PANEL ─────────────────────────────────────── */
        #settings-panel{position:fixed;inset:0;z-index:1200;display:flex;flex-direction:column;background:var(--s1);transform:translateY(100%);transition:transform .35s cubic-bezier(.32,.72,0,1);will-change:transform}
        #settings-panel.open{transform:translateY(0)}
        .sp-head{display:flex;align-items:center;justify-content:space-between;padding:14px 18px 10px;border-bottom:1px solid var(--bd2);flex-shrink:0}
        .sp-title{font-family:var(--fh);font-size:16px;font-weight:800;letter-spacing:.5px;text-transform:uppercase;color:var(--tx)}
        .sp-close{background:var(--s2);border:none;border-radius:50%;width:32px;height:32px;display:flex;align-items:center;justify-content:center;cursor:pointer;color:var(--tx);font-size:16px;line-height:1}
        .sp-tabs{display:flex;gap:2px;padding:10px 14px 0;border-bottom:1px solid var(--bd2);flex-shrink:0;overflow-x:auto}
        .sp-tab{font-family:var(--fh);font-size:12px;font-weight:700;letter-spacing:.8px;text-transform:uppercase;padding:7px 14px;border:none;background:transparent;color:var(--td);border-bottom:2px solid transparent;cursor:pointer;white-space:nowrap;border-radius:6px 6px 0 0;transition:all .18s}
        .sp-tab.active{color:var(--ac);border-bottom-color:var(--ac);background:rgba(200,255,0,.07)}
        .sp-body{flex:1;overflow-y:auto;padding:16px;display:flex;flex-direction:column;gap:14px}
        .sp-section{background:var(--s2);border:1px solid var(--bd2);border-radius:14px;padding:14px;display:flex;flex-direction:column;gap:10px}
        .sp-section-title{font-family:var(--fh);font-size:10px;font-weight:800;letter-spacing:1.2px;text-transform:uppercase;color:var(--td);margin-bottom:2px}
        .sp-label{font-size:13px;font-weight:600;color:var(--tx);display:flex;align-items:center;gap:8px}
        .sp-hint{font-size:11px;color:var(--td);margin-top:2px;line-height:1.4}
        .sp-input{background:var(--s3);border:1px solid var(--bd2);border-radius:8px;color:var(--tx);font-size:13px;padding:8px 10px;width:100%;box-sizing:border-box;outline:none;font-family:inherit}
        .sp-input:focus{border-color:var(--ac)}
        .sp-btn{display:flex;align-items:center;justify-content:center;gap:6px;padding:10px 16px;border-radius:10px;border:none;cursor:pointer;font-family:var(--fh);font-size:12px;font-weight:800;letter-spacing:.8px;text-transform:uppercase;width:100%;transition:opacity .15s}
        .sp-btn:active{opacity:.7}
        .sp-btn.prim{background:var(--ac);color:#0b0e14}
        .sp-btn.sec{background:var(--s3);color:var(--tx);border:1px solid var(--bd2)}
        .sp-btn.danger{background:rgba(239,68,68,.15);color:#ef4444;border:1px solid rgba(239,68,68,.3)}
        .sp-row{display:flex;gap:8px}
        .sp-row .sp-btn{flex:1}
        /* Emoji Picker */
        .emoji-grid{display:grid;grid-template-columns:repeat(6,1fr);gap:6px}
        .emoji-opt{background:var(--s3);border:2px solid transparent;border-radius:10px;font-size:22px;height:44px;display:flex;align-items:center;justify-content:center;cursor:pointer;transition:border-color .15s,background .15s}
        .emoji-opt:hover{background:var(--s1)}
        .emoji-opt.selected{border-color:var(--ac);background:rgba(200,255,0,.1)}

        /* ── CUSTOM MARKER DIALOG ───────────────────────────────── */
        #marker-dialog{position:fixed;inset:0;z-index:1300;display:flex;align-items:flex-end;background:rgba(0,0,0,.6);opacity:0;visibility:hidden;transition:opacity .25s,visibility .25s}
        #marker-dialog.open{opacity:1;visibility:visible}
        .md-sheet{background:var(--s1);border-radius:20px 20px 0 0;padding:20px;width:100%;max-width:520px;margin:0 auto;transform:translateY(30px);transition:transform .3s cubic-bezier(.32,.72,0,1);max-height:90vh;overflow-y:auto;box-sizing:border-box}
        #marker-dialog.open .md-sheet{transform:translateY(0)}
        .md-title{font-family:var(--fh);font-size:15px;font-weight:800;letter-spacing:.5px;text-transform:uppercase;color:var(--tx);margin-bottom:14px;display:flex;align-items:center;gap:8px}
        .md-field{display:flex;flex-direction:column;gap:4px;margin-bottom:10px}
        .md-field label{font-size:11px;font-weight:700;color:var(--td);text-transform:uppercase;letter-spacing:.8px}
        .md-field input,.md-field textarea,.md-field select{background:var(--s2);border:1px solid var(--bd2);border-radius:8px;color:var(--tx);font-size:13px;padding:8px 10px;width:100%;box-sizing:border-box;outline:none;font-family:inherit;resize:vertical}
        .md-field input:focus,.md-field textarea:focus,.md-field select:focus{border-color:var(--ac)}
        .md-actions{display:flex;gap:8px;margin-top:14px}
        .md-btn{flex:1;padding:11px;border:none;border-radius:10px;cursor:pointer;font-family:var(--fh);font-size:12px;font-weight:800;letter-spacing:.8px;text-transform:uppercase;transition:opacity .15s}
        .md-btn:active{opacity:.7}
        .md-btn.prim{background:var(--ac);color:#0b0e14}
        .md-btn.sec{background:var(--s3);color:var(--tx);border:1px solid var(--bd2)}
        .md-btn.del{background:rgba(239,68,68,.15);color:#ef4444;border:1px solid rgba(239,68,68,.3)}
        /* Cat color pills */
        .cat-pills{display:flex;gap:6px;flex-wrap:wrap}
        .cat-pill{padding:5px 12px;border-radius:20px;font-family:var(--fh);font-size:11px;font-weight:800;letter-spacing:.5px;cursor:pointer;border:2px solid transparent;transition:all .15s}
        .cat-pill.active{border-color:currentColor}

        /* ── CUSTOM MARKER PINS ─────────────────────────────────── */
        .cust-pin{width:32px;height:40px;position:relative;display:flex;align-items:flex-start;justify-content:center;cursor:pointer}
        .cust-pin-bg{width:30px;height:36px;border-radius:50% 50% 50% 0;transform:rotate(-45deg);display:flex;align-items:center;justify-content:center;box-shadow:0 4px 12px rgba(0,0,0,.5);position:relative}
        .cust-pin-emoji{transform:rotate(45deg);font-size:15px;line-height:1;position:relative;z-index:1}
        .cust-pin-tip{position:absolute;bottom:-4px;left:50%;transform:translateX(-50%);width:0;height:0;border-left:4px solid transparent;border-right:4px solid transparent}

        /* ── PWA INSTALL PROMPT ─────────────────────────────────── */
        #pwa-install{position:fixed;bottom:0;left:0;right:0;z-index:1400;background:var(--s1);border-top:2px solid var(--ac);border-radius:22px 22px 0 0;padding:20px 18px 22px;box-shadow:0 -16px 60px rgba(0,0,0,.75);transform:translateY(115%);transition:transform .45s cubic-bezier(.32,.72,0,1);max-width:500px;margin:0 auto}
        #pwa-install.show{transform:translateY(0)}
        .pi-head{display:flex;align-items:center;gap:14px;margin-bottom:6px}
        .pi-icon{width:56px;height:56px;border-radius:16px;background:var(--ac);display:flex;align-items:center;justify-content:center;flex-shrink:0;font-size:30px}
        .pi-title{font-family:var(--fh);font-size:17px;font-weight:800;letter-spacing:.3px;text-transform:uppercase;color:var(--tx)}
        .pi-sub{font-size:12px;color:var(--td);margin-top:3px;line-height:1.4}
        .pi-badge{display:inline-flex;align-items:center;gap:4px;background:var(--s3);border:1px solid var(--bd2);border-radius:6px;padding:2px 8px;font-size:10px;font-weight:700;color:var(--td);letter-spacing:.4px;text-transform:uppercase;margin-top:6px}
        .pi-steps{font-size:12.5px;color:var(--tx);background:var(--s2);border:1px solid var(--bd2);border-radius:12px;padding:13px 14px;line-height:2;margin:12px 0}
        .pi-steps strong{color:var(--ac)}
        .pi-acts{display:flex;gap:8px;margin-top:4px}
        .pi-btn{flex:1;padding:13px;border:none;border-radius:12px;cursor:pointer;font-family:var(--fh);font-size:12px;font-weight:800;letter-spacing:.8px;text-transform:uppercase;transition:opacity .15s}
        .pi-btn.inst{background:var(--ac);color:#0b0e14}
        .pi-btn.inst:active{opacity:.8}
        .pi-btn.later{background:var(--s3);color:var(--td);border:1px solid var(--bd2)}
        .pi-dismiss{text-align:center;margin-top:8px}
        .pi-dismiss button{background:none;border:none;color:var(--td);font-size:11px;cursor:pointer;padding:6px;opacity:.7}
        /* ── APP INSTALL SETTINGS TAB ───────────────────────────── */
        #sp-tab-app .sp-section{background:var(--s2);border-radius:12px;padding:14px;border:1px solid var(--bd2);margin-bottom:6px}
        .ai-status-card{display:flex;align-items:center;gap:12px;padding:12px 14px;border-radius:12px;border:1px solid var(--bd2);margin-bottom:6px}
        .ai-status-card.installed{background:rgba(200,255,0,.08);border-color:rgba(200,255,0,.3)}
        .ai-status-card.not-installed{background:var(--s2);border-color:var(--bd2)}
        .ai-status-icon{width:44px;height:44px;border-radius:12px;display:flex;align-items:center;justify-content:center;font-size:24px;flex-shrink:0;background:var(--s3)}
        .ai-status-card.installed .ai-status-icon{background:rgba(200,255,0,.15)}
        .ai-status-label{font-family:var(--fh);font-size:13px;font-weight:800;letter-spacing:.4px;text-transform:uppercase;color:var(--tx)}
        .ai-status-sub{font-size:11px;color:var(--td);margin-top:2px;line-height:1.4}
        .ai-device-info{background:var(--s3);border-radius:10px;padding:10px 12px;font-size:11px;color:var(--td);line-height:1.9;border:1px solid var(--bd2);margin-bottom:6px}
        .ai-device-info strong{color:var(--tx)}
        .ai-cache-row{display:flex;justify-content:space-between;align-items:center;font-size:12px;color:var(--td);margin:3px 0}
        .ai-cache-row strong{color:var(--tx);font-weight:700}
        .ai-bar-wrap{background:var(--s3);border-radius:6px;height:5px;overflow:hidden;margin:6px 0 2px}
        .ai-bar-fill{background:var(--ac);height:100%;border-radius:6px;transition:width .5s ease;width:0%}
        .ai-steps-box{font-size:12.5px;color:var(--tx);background:var(--s3);border:1px solid var(--bd2);border-radius:10px;padding:12px 13px;line-height:2;margin-top:6px}
        .ai-steps-box strong{color:var(--ac)}

        /* ── SETTINGS PANEL CONTENT ────────────────────────────── */
        .sp-content{display:none;flex:1;overflow-y:auto;padding:14px 16px;flex-direction:column;gap:14px}
        .sp-content.on{display:flex}
        /* sp-col: tab mit eigenem Scroll-Layout (kein padding, kein gap — z.B. Marker-Tab) */
        .sp-col{padding:0!important;gap:0!important;overflow:hidden!important}
        .sp-col.on{display:flex;flex-direction:column}
        /* override section to not have its own background (use inside sp-content) */
        #sp-tab-general .sp-section,#sp-tab-backup .sp-section{background:var(--s2);border-radius:12px;padding:14px;border-bottom:1px solid var(--bd2);border:1px solid var(--bd2);margin-bottom:4px}

        /* ── LEAFLET TILE RENDERING: flüssig & kein Flicker ──────── */
        /* Tiles beim Laden sanft einblenden (verhindert weißes Aufblitzen) */
        .leaflet-tile{
          will-change:opacity;
          /* GPU-Layer promotion für ruckelfreies Einblenden */
        }
        .leaflet-tile-loaded{
          /* Leaflet setzt opacity=1 direkt — wir überschreiben mit CSS-Transition */
          transition:opacity 180ms ease-in!important;
        }
        /* Kartenpane: GPU-Compositing aktivieren */
        .leaflet-map-pane,.leaflet-tile-pane{
          transform:translateZ(0);
          backface-visibility:hidden;
        }
        /* Tiles scharf rendern — verhindert Browser-Weichzeichnung */
        .leaflet-tile-container img{
          image-rendering:-webkit-optimize-contrast;
          image-rendering:crisp-edges;
          border:0!important;
        }
        /* Zoom-Animation: flüssiger Übergang beim Pinch-Zoom */
        .leaflet-zoom-anim .leaflet-zoom-animated{
          transition:transform 220ms cubic-bezier(.25,.46,.45,.94)!important;
        }

        /* ── CUSTOM MARKER MODAL (md-overlay) ──────────────────── */
        #md-overlay.show{display:flex!important}
        #md-overlay.show .md-sheet{transform:translateY(0)}
        .md-label{font-size:11px;font-weight:700;color:var(--td);text-transform:uppercase;letter-spacing:.8px;margin-bottom:3px}
        .md-input{background:var(--s2);border:1px solid var(--bd2);border-radius:8px;color:var(--tx);font-size:13px;padding:8px 10px;width:100%;box-sizing:border-box;outline:none;font-family:inherit}
        .md-input:focus{border-color:var(--ac)}
        .md-acts{display:flex;gap:8px;margin-top:14px}
        /* Emoji-Picker im Marker-Modal */
        .md-emoji-btn{background:var(--s2);border:1px solid var(--bd2);border-radius:8px;width:34px;height:34px;font-size:17px;display:flex;align-items:center;justify-content:center;cursor:pointer;transition:border-color .15s,background .15s;padding:0;flex-shrink:0}
        .md-emoji-btn.selected{border-color:var(--ac);background:var(--ac)22}
        .md-emoji-btn:active{opacity:.7}

        /* ── CUSTOM MARKERS LIST ────────────────────────────────── */
        .cm-item{display:flex;align-items:center;gap:10px;padding:10px 0;border-bottom:1px solid var(--bd2)}
        .cm-item:last-child{border-bottom:none}
        .cm-emoji{font-size:22px;flex-shrink:0;width:36px;height:36px;display:flex;align-items:center;justify-content:center}
        .cm-info{flex:1;min-width:0}
        .cm-name{font-size:13px;font-weight:700;color:var(--tx);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
        .cm-cat{font-size:11px;color:var(--td);margin-top:2px}
        .cm-desc{font-size:11px;color:var(--td);margin-top:1px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-style:italic}
        .cm-actions{display:flex;gap:4px;flex-shrink:0}
        .cm-act-btn{background:var(--s3);border:1px solid var(--bd2);border-radius:7px;padding:5px 8px;cursor:pointer;font-size:12px;color:var(--tx);line-height:1}
        .cm-act-btn.del{color:#ef4444;border-color:rgba(239,68,68,.3);background:rgba(239,68,68,.08)}
        .cm-empty{text-align:center;padding:24px 12px;color:var(--td);font-size:13px;line-height:1.6}
        /* ── MARKER-LIST SECTION HEADERS ───────────────────────── */
        .cm-section-hdr{display:flex;align-items:center;justify-content:space-between;padding:8px 0 4px;margin-top:4px;border-bottom:2px solid var(--bd2);position:sticky;top:0;background:var(--bg);z-index:1}
        .cm-section-title{font-family:var(--fh);font-size:11px;font-weight:700;letter-spacing:.8px;text-transform:uppercase;color:var(--td)}
        .cm-section-count{font-size:11px;color:var(--td);background:var(--s3);border-radius:10px;padding:1px 7px}
        .cm-act-btn.reset{color:#f59e0b;border-color:rgba(245,158,11,.3);background:rgba(245,158,11,.08)}
        /* ── MARKER SIZE SLIDER ──────────────────────────────────── */
        .mk-slider-row{display:flex;align-items:center;gap:10px;padding:10px 16px;background:var(--s2);border-radius:10px;margin:10px 16px 0;flex-shrink:0}
        .mk-slider-row input[type=range]{flex:1;accent-color:var(--ac);height:4px}
        .mk-slider-val{font-size:12px;font-weight:700;color:var(--ac);min-width:36px;text-align:right;font-family:var(--fh)}

        /* ── ACCESSIBILITY ──────────────────────────────────── */
        /* Screen-reader-only: visually hidden but announced */
        .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}
        /* High-contrast focus ring (active in hc mode or always for keyboard nav) */
        [data-a11y-hc] *:focus-visible{outline:4px solid #ff0 !important;outline-offset:3px !important}
        /* ── TTS CONTROL BAR — kompakt, unten-links, sichtbar wenn [data-a11y-on] ── */
        #tts-ctrl-bar{
          position:fixed;bottom:calc(env(safe-area-inset-bottom, 0px) + 45px);
          left:12px;width:auto;max-width:300px;z-index:492;
          background:var(--s1);border:1.5px solid var(--bd2);border-radius:16px;
          padding:6px 10px;display:none;align-items:center;gap:4px;
          box-shadow:0 4px 20px rgba(0,0,0,.6);pointer-events:none;
        }
        html[data-a11y-on] #tts-ctrl-bar{display:flex !important;pointer-events:all}
        /* Floating 🔊 FAB — sichtbar wenn TTS aktiv, in der .fabs Gruppe */
        #a11y-speak-fab{
          width:42px;height:42px;background:var(--ac);color:var(--bg);
          border-radius:50%;border:none;font-size:20px;cursor:pointer;
          box-shadow:0 4px 16px rgba(0,0,0,.5);display:none;
          align-items:center;justify-content:center;transition:transform .12s;
          margin:0 auto;
        }
        html[data-a11y-on] #a11y-speak-fab{display:flex}
        #a11y-speak-fab:active{transform:scale(.88)}
        /* TTS-Toggle-Button im Sheet-Header */
        #sheet-tts-btn{
          width:32px;height:32px;border-radius:8px;border:1.5px solid var(--bd2);
          background:var(--s2);color:var(--tx);font-size:16px;cursor:pointer;
          display:flex;align-items:center;justify-content:center;flex-shrink:0;
          transition:all .15s;
        }
        #sheet-tts-btn.active{background:var(--ac);color:var(--bg);border-color:var(--ac)}
        /* Primary speak button — kompakt, accent */
        #tts-speak-btn{
          width:44px;height:44px;border-radius:12px;border:none;
          background:var(--ac);color:var(--bg);font-size:20px;
          cursor:pointer;display:flex;align-items:center;justify-content:center;
          flex-shrink:0;box-shadow:0 2px 8px rgba(0,0,0,.4);transition:transform .12s;
          touch-action:manipulation;
        }
        #tts-speak-btn:active{transform:scale(.85)}
        /* Secondary control buttons */
        .tts-ctrl-btn{
          width:44px;height:44px;border-radius:10px;
          border:1.5px solid var(--bd2);background:var(--s2);
          color:var(--tx);font-size:15px;cursor:pointer;
          display:flex;align-items:center;justify-content:center;
          flex-shrink:0;transition:all .12s;touch-action:manipulation;
        }
        .tts-ctrl-btn:active{transform:scale(.85);background:var(--s3)}
        /* Status text */
        #tts-status-txt{
          flex:1;font-size:10px;color:var(--td);
          font-family:var(--fh);font-weight:600;
          overflow:hidden;text-overflow:ellipsis;white-space:nowrap;
          min-width:0;
        }
        /* ── PROJEKT DROPDOWN ───────────────────────────────────── */
        #proj-bar{position:relative;display:inline-flex;align-items:center;flex-shrink:0}
        #proj-toggle-btn{
          background:var(--s2);border:1.5px solid var(--bd2);border-radius:10px;
          padding:5px 10px 5px 12px;display:flex;align-items:center;gap:6px;
          cursor:pointer;font-family:var(--fh);font-size:12px;font-weight:700;
          color:var(--tx);white-space:nowrap;max-width:140px;overflow:hidden;text-overflow:ellipsis;
          touch-action:manipulation;
        }
        #proj-toggle-btn svg{flex-shrink:0;transition:transform .15s}
        #proj-toggle-btn[aria-expanded="true"] svg{transform:rotate(180deg)}
        #proj-dropdown{
          position:absolute;top:calc(100% + 6px);left:0;min-width:220px;max-height:340px;
          background:var(--s1);border:1.5px solid var(--bd2);border-radius:14px;
          box-shadow:0 8px 32px rgba(0,0,0,.55);z-index:600;overflow:hidden;
          display:flex;flex-direction:column;
        }
        #proj-dropdown[hidden]{display:none!important}
        #proj-search-inp{
          width:100%;box-sizing:border-box;padding:9px 12px;border:none;
          border-bottom:1px solid var(--bd2);background:var(--s2);
          color:var(--tx);font-size:14px;outline:none;
        }
        #proj-list-inner{overflow-y:auto;flex:1;overscroll-behavior:contain}
        .proj-item{
          padding:10px 14px;cursor:pointer;display:flex;align-items:center;
          gap:8px;font-size:14px;color:var(--tx);touch-action:manipulation;
        }
        .proj-item:hover,.proj-item:active{background:var(--s2)}
        .proj-item.active{color:var(--ac);font-weight:700}
        .proj-item.active::before{content:'✓ ';font-weight:900}
        .proj-new-btn{
          width:100%;padding:10px 14px;background:transparent;border:none;
          border-top:1px solid var(--bd2);color:var(--ac);font-weight:700;
          font-size:13px;cursor:pointer;text-align:left;touch-action:manipulation;
        }
        /* ── PROJEKT KARTEN (Settings Übersicht) ──────────────── */
        .proj-card{background:var(--s2);border:1.5px solid var(--bd2);border-radius:12px;overflow:hidden;transition:border-color .15s,box-shadow .15s}
        .proj-card.is-focus{border-color:var(--ac);box-shadow:0 0 0 2px rgba(200,255,0,.15)}
        .proj-card-header{display:flex;align-items:center;gap:10px;padding:10px 12px}
        .proj-card-info{flex:1;min-width:0;cursor:pointer}
        .proj-card-name{font-size:14px;font-weight:700;color:var(--tx);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;transition:color .15s}
        .proj-card-name.is-focus{color:var(--ac)}
        .proj-card-stats{font-size:11px;color:var(--td);margin-top:2px}
        .proj-card-actions{display:flex;gap:4px;flex-shrink:0}
        .proj-card-act{width:32px;height:32px;border-radius:8px;border:1.5px solid var(--bd2);background:var(--s3);color:var(--tx);font-size:15px;cursor:pointer;display:flex;align-items:center;justify-content:center;touch-action:manipulation;transition:background .1s,border-color .1s}
        .proj-card-act.focus-btn.is-focus{background:rgba(200,255,0,.15);border-color:var(--ac);color:var(--ac)}
        .proj-card-act.del-btn{color:#ef4444;border-color:rgba(239,68,68,.25)}
        /* Projekt-Toggle-Switch */
        .proj-sw{position:relative;width:44px;height:24px;flex-shrink:0;cursor:pointer}
        .proj-sw input{opacity:0;width:0;height:0;position:absolute}
        .proj-sw-track{position:absolute;inset:0;background:var(--bd2);border-radius:12px;transition:background .2s;cursor:pointer}
        .proj-sw-track::after{content:'';position:absolute;top:3px;left:3px;width:18px;height:18px;background:#fff;border-radius:50%;transition:transform .2s}
        .proj-sw input:checked+.proj-sw-track{background:var(--ac)}
        .proj-sw input:checked+.proj-sw-track::after{transform:translateX(20px)}
        /* Karten-Erstellmodus Cursor */
        body.proj-create-mode,body.proj-create-mode .leaflet-container{cursor:crosshair!important}
        /* Hint-Banner beim Karten-Doppelklick-Modus */
        #proj-create-hint{
          position:fixed;top:62px;left:50%;transform:translateX(-50%);
          background:var(--s1);border:2px solid var(--ac);border-radius:14px;
          padding:10px 14px;z-index:650;font-size:13px;color:var(--tx);
          box-shadow:0 4px 20px rgba(0,0,0,.45);display:none;
          align-items:center;gap:10px;max-width:calc(100vw - 32px);
        }
        #proj-create-hint.show{display:flex}
        /* Schritt-2 Modal: Neues Projekt nach Doppelklick */
        #proj-step2-modal{position:fixed;inset:0;background:rgba(0,0,0,.72);z-index:710;display:none;align-items:flex-end;justify-content:center}
        #proj-step2-modal.show{display:flex}
        #proj-step2-sheet{background:var(--s1);border-radius:20px 20px 0 0;width:100%;max-width:480px;padding-bottom:env(safe-area-inset-bottom,16px);animation:slideUp .22s ease;max-height:90vh;overflow-y:auto}
        .proj-s2-opt{display:flex;align-items:center;gap:12px;padding:14px 16px;cursor:pointer;border-top:1px solid var(--bd2);touch-action:manipulation;font-size:14px;color:var(--tx);transition:background .1s}
        .proj-s2-opt:active{background:var(--s2)}
        .proj-s2-icon{width:40px;height:40px;border-radius:10px;background:var(--s2);display:flex;align-items:center;justify-content:center;font-size:20px;flex-shrink:0}
        /* VERALTET – compat */
        #proj-create-modal{display:none!important}
        /* ── FEATURE LOCATION PICKER MODAL ─────────────────────── */
        #feat-pos-modal{
          position:fixed;inset:0;z-index:9000;display:none;
          flex-direction:column;background:var(--bg);
        }
        #feat-pos-modal.open{display:flex}
        #feat-pos-header{
          display:flex;align-items:center;gap:10px;
          padding:10px 12px;background:var(--s1);
          border-bottom:1px solid var(--bd2);flex-shrink:0;
        }
        #feat-pos-title{flex:1;font-weight:700;font-size:14px;color:var(--tx);font-family:var(--fh)}
        #feat-pos-gps-btn{
          padding:6px 11px;border-radius:8px;border:1.5px solid var(--bd2);
          background:var(--s2);color:var(--tx);font-size:12px;cursor:pointer;
          font-family:var(--fh);font-weight:600;transition:all .15s;white-space:nowrap;
        }
        #feat-pos-gps-btn.active{background:var(--ac);color:var(--bg);border-color:var(--ac)}
        #feat-pos-map-wrap{
          position:relative;flex:1;overflow:hidden;min-height:0;
        }
        #feat-pos-map{width:100%;height:100%}
        .feat-pos-crosshair{
          position:absolute;top:50%;left:50%;
          transform:translate(-50%,-50%);
          pointer-events:none;z-index:1000;
        }
        .feat-pos-crosshair-dot{
          width:10px;height:10px;border-radius:50%;
          background:var(--ac);border:2px solid #000;
          position:absolute;top:50%;left:50%;
          transform:translate(-50%,-50%);
        }
        #feat-pos-coords{
          position:absolute;bottom:8px;left:50%;transform:translateX(-50%);
          background:rgba(0,0,0,.72);color:#fff;font-size:10px;
          padding:3px 10px;border-radius:20px;font-family:var(--fh);
          pointer-events:none;z-index:1001;white-space:nowrap;
        }
        #feat-pos-sheet{
          background:var(--s1);border-top:1px solid var(--bd2);
          padding:12px;flex-shrink:0;overflow-y:auto;max-height:46vh;
        }
        #feat-pos-type-grid{
          display:grid;grid-template-columns:repeat(4,1fr);gap:6px;margin-bottom:10px;
        }
        .feat-pos-type-btn{
          display:flex;flex-direction:column;align-items:center;gap:3px;
          padding:7px 4px;border-radius:10px;border:1.5px solid var(--bd2);
          background:var(--s2);cursor:pointer;font-size:10px;color:var(--td);
          font-family:var(--fh);font-weight:600;transition:all .15s;
        }
        .feat-pos-type-btn .type-icon{font-size:20px;line-height:1}
        .feat-pos-type-btn.selected{border-color:var(--ac);background:rgba(200,255,0,.12);color:var(--tx)}
        .feat-pos-stars{display:flex;gap:4px;margin:6px 0 10px}
        .feat-pos-star{font-size:22px;cursor:pointer;opacity:.35;transition:opacity .1s}
        .feat-pos-star.on{opacity:1}

        /* Big A11Y toggle button */
        .a11y-big-toggle{
          width:100%;padding:15px 18px;border-radius:15px;
          border:2px solid var(--bd2);background:var(--s2);
          display:flex;align-items:center;gap:14px;cursor:pointer;
          transition:all .15s;text-align:left;margin-top:10px;
        }
        .a11y-big-toggle.on{
          background:var(--ac);border-color:var(--ac);color:var(--bg);
        }
        .a11y-big-toggle-icon{font-size:32px;flex-shrink:0;line-height:1}
        .a11y-big-toggle-text{flex:1}
        .a11y-big-toggle-label{
          font-size:15px;font-weight:800;font-family:var(--fh);
          letter-spacing:.5px;display:block;
        }
        .a11y-big-toggle.on .a11y-big-toggle-label{color:var(--bg)}
        .a11y-big-toggle-state{
          font-size:12px;font-weight:700;letter-spacing:1px;
          text-transform:uppercase;opacity:.75;display:block;margin-top:2px;
        }
        .a11y-big-toggle-switch{
          width:44px;height:26px;border-radius:13px;background:var(--bd2);
          position:relative;flex-shrink:0;transition:background .2s;
        }
        .a11y-big-toggle-switch::after{
          content:'';position:absolute;top:3px;left:3px;
          width:20px;height:20px;border-radius:50%;background:#fff;
          box-shadow:0 2px 6px rgba(0,0,0,.4);transition:left .2s;
        }
        .a11y-big-toggle.on .a11y-big-toggle-switch{background:rgba(0,0,0,.25)}
        .a11y-big-toggle.on .a11y-big-toggle-switch::after{left:21px}
        /* Tracks sub-tab active style */
        .trk-sub-tab.active{color:var(--tx)!important;border-bottom-color:var(--ac)!important;font-weight:800!important}
        /* Language selector */
        .lang-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:10px}
        .lang-btn{
          padding:10px 8px;border-radius:11px;border:2px solid var(--bd2);
          background:var(--s2);color:var(--tx);font-size:13px;font-weight:700;
          cursor:pointer;transition:all .15s;display:flex;align-items:center;
          justify-content:center;gap:6px;font-family:var(--fh);
        }
        .lang-btn.active{background:var(--ac);border-color:var(--ac);color:var(--bg)}
        .lang-btn:active{transform:scale(.93)}
    </style>
</head>
<body>
<div id="map"></div>

<!-- TOP BAR -->
<div id="topbar">
  <div id="tbrow">
    <button class="ibtn" onclick="toggleSheet()" aria-label="Menü">
      <svg width="18" height="14" viewBox="0 0 18 14" fill="none"><path d="M0 1H18M0 7H12M0 13H18" stroke="currentColor" stroke-width="1.8" stroke-linecap="round"/></svg>
    </button>
    <div id="titlepill">
      <div class="logobadge">MUNI</div>
      <div><div class="ttl">GMTW Trail Map</div><div class="tsub">Hohensyburg · Herdecke</div></div>
    </div>
    <button class="ibtn" id="layer-btn" onclick="toggleLayer()" aria-label="Karte wechseln">
      <svg width="18" height="18" viewBox="0 0 18 18" fill="none"><path d="M9 1L17 5.5L9 10L1 5.5L9 1Z" stroke="currentColor" stroke-width="1.5" stroke-linejoin="round"/><path d="M1 9.5L9 14L17 9.5" stroke="currentColor" stroke-width="1.5" stroke-linejoin="round"/></svg>
    </button>
  </div>
</div>

<!-- FILTER + PROJEKT-AUSWAHL -->
<div id="fbar">
  <button class="chip on" data-f="all"      onclick="setFilter('all',this)">Alle</button>
  <button class="chip"    data-f="beginner" aria-label="Beginner Filter" onclick="setFilter('beginner',this)">🟢 Beginner</button>
  <button class="chip"    data-f="mittel"   onclick="setFilter('mittel',this)">🟡 Mittel</button>
  <button class="chip"    data-f="expert"   onclick="setFilter('expert',this)">🔴 Expert</button>
  <button class="chip"    data-f="logistik" aria-label="Logistik Filter" onclick="setFilter('logistik',this)">🔵 Logistik</button>
  <!-- Projekt-Dropdown -->
  <div id="proj-bar">
    <button id="proj-toggle-btn" onclick="toggleProjDropdown()"
      aria-haspopup="listbox" aria-expanded="false" aria-label="Aktives Projekt wechseln">
      <span id="proj-curr-name">Standard</span>
      <svg width="10" height="6" viewBox="0 0 10 6" fill="none">
        <path d="M1 1l4 4 4-4" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    </button>
    <div id="proj-dropdown" role="listbox" hidden aria-label="Projekte">
      <input id="proj-search-inp" type="search" placeholder="Projekt suchen…"
        oninput="_filterProjList(this.value)" autocomplete="off" aria-label="Projekte filtern">
      <div id="proj-list-inner" role="group"></div>
      <button class="proj-new-btn" onclick="startNewProjMode()">➕ Neues Projekt</button>
    </div>
  </div>
</div>

<!-- Projekt Erstellen: Hinweisbanner (zeigt sich während Map-Doppelklick-Modus) -->
<div id="proj-create-hint" role="status" aria-live="polite">
  <span style="font-size:18px">🗺️</span>
  <span style="font-weight:700;font-size:14px">Doppelklick auf die Karte, um den Fokuspunkt des neuen Projekts zu setzen</span>
  <button onclick="_cancelProjCreateMode()" style="background:rgba(255,255,255,.15);border:none;color:#fff;padding:6px 14px;border-radius:8px;font-size:13px;font-weight:700;cursor:pointer;touch-action:manipulation;white-space:nowrap">Abbrechen</button>
</div>

<!-- Projekt Erstellen: Schritt 2 — Optionen-Sheet (nach Doppelklick) -->
<div id="proj-step2-modal" role="dialog" aria-modal="true" aria-labelledby="proj-s2-ttl">
  <div id="proj-step2-sheet">
    <!-- Header -->
    <div style="display:flex;align-items:center;justify-content:space-between;padding:16px 16px 12px">
      <div>
        <div id="proj-s2-ttl" style="font-family:var(--fh);font-size:17px;font-weight:900;color:var(--tx)">Neues Projekt</div>
        <div id="proj-s2-sub" style="font-size:12px;color:var(--td);margin-top:2px">Fokuspunkt gesetzt · Was möchtest du tun?</div>
      </div>
      <button onclick="closeProjStep2()" style="width:32px;height:32px;border-radius:8px;border:none;background:var(--s2);color:var(--tx);font-size:18px;cursor:pointer;display:flex;align-items:center;justify-content:center;touch-action:manipulation" aria-label="Schließen">✕</button>
    </div>
    <!-- Name-Eingabe -->
    <div style="padding:0 16px 12px">
      <label style="font-size:12px;color:var(--td);font-weight:700;display:block;margin-bottom:4px">Projektname</label>
      <input id="proj-s2-name" type="text" placeholder="z.B. Sauerland 2026" maxlength="40"
        class="sp-inp" style="width:100%;box-sizing:border-box"
        onkeydown="if(event.key==='Enter')saveProjStep2('only')">
    </div>
    <!-- Aktions-Optionen -->
    <div style="border-top:1px solid var(--bd2)">
      <button class="proj-s2-opt" onclick="saveProjStep2('marker')" style="width:100%;background:none;border:none;text-align:left">
        <div class="proj-s2-icon">📍</div>
        <div>
          <div style="font-weight:700">Marker setzen</div>
          <div style="font-size:12px;color:var(--td);margin-top:2px">Erstelle das Projekt und setze direkt einen Marker</div>
        </div>
      </button>
      <button class="proj-s2-opt" onclick="saveProjStep2('gpx')" style="width:100%;background:none;border:none;text-align:left">
        <div class="proj-s2-icon">🗺️</div>
        <div>
          <div style="font-weight:700">GPX-Strecke laden</div>
          <div style="font-size:12px;color:var(--td);margin-top:2px">Erstelle das Projekt und importiere eine GPX-Datei</div>
        </div>
      </button>
      <button class="proj-s2-opt" onclick="saveProjStep2('import')" style="width:100%;background:none;border:none;text-align:left">
        <div class="proj-s2-icon">📥</div>
        <div>
          <div style="font-weight:700">Projekt importieren</div>
          <div style="font-size:12px;color:var(--td);margin-top:2px">Lade ein vorhandenes Projekt-JSON (Strecken, Marker, Daten)</div>
        </div>
      </button>
      <button class="proj-s2-opt" onclick="saveProjStep2('only')" style="width:100%;background:none;border:none;text-align:left">
        <div class="proj-s2-icon">✅</div>
        <div>
          <div style="font-weight:700">Nur Projekt erstellen</div>
          <div style="font-size:12px;color:var(--td);margin-top:2px">Leeres Projekt anlegen, Inhalte später hinzufügen</div>
        </div>
      </button>
    </div>
    <!-- Versteckter File-Picker für GPX / Projekt-Import -->
    <input id="proj-s2-gpx-inp"    type="file" accept=".gpx"  style="display:none" onchange="_onProjS2GpxPick(this)">
    <input id="proj-s2-import-inp" type="file" accept=".json" style="display:none" onchange="_onProjS2ImportPick(this);this.value=''">
  </div>
</div>

<!-- TTS Control Bar — persistent, sichtbar wenn Vorlesefunktion aktiv -->
<div id="tts-ctrl-bar" role="toolbar" aria-label="Sprachsteuerung">
  <button id="tts-speak-btn" onclick="speakCurrentContext()" aria-label="Vorlesen" title="Aktuelle Ansicht vorlesen [V]">🔊</button>
  <button class="tts-ctrl-btn" id="tts-prev-btn"  onclick="ttsRepeat()"        aria-label="Wiederholen" title="Letzten Text wiederholen">⏮</button>
  <button class="tts-ctrl-btn" id="tts-pause-btn" onclick="ttsTogglePause()"   aria-label="Pause / Weiter" title="Pause / Weiter">⏸</button>
  <button class="tts-ctrl-btn" id="tts-skip-btn"  onclick="ttsSkipForward()"   aria-label="Weiter / Überspringen" title="Aktuellen Text überspringen">⏭</button>
  <button class="tts-ctrl-btn" id="tts-stop-btn"  onclick="speakStop()"        aria-label="Stopp" title="Sprachausgabe stoppen">⏹</button>
  <span id="tts-status-txt" style="flex:1;min-width:0;font-size:11px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis" aria-live="polite">Bereit</span>
</div>

<!-- FEATURE LOCATION PICKER MODAL -->
<div id="feat-pos-modal" role="dialog" aria-modal="true" aria-label="Schlüsselstelle positionieren">
  <div id="feat-pos-header">
    <button onclick="closeFeatPosPicker()" style="width:32px;height:32px;border-radius:8px;border:none;background:var(--s2);color:var(--tx);font-size:18px;cursor:pointer;display:flex;align-items:center;justify-content:center" aria-label="Schließen">✕</button>
    <span id="feat-pos-title">📍 Schlüsselstelle setzen</span>
    <button id="feat-pos-gps-btn" onclick="featPosGpsMode()" aria-label="GPS-Modus">📡 Live GPS</button>
  </div>
  <div id="feat-pos-map-wrap">
    <div id="feat-pos-map"></div>
    <!-- Fixed crosshair — user pans map under it -->
    <div class="feat-pos-crosshair">
      <svg width="40" height="40" viewBox="0 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg">
        <line x1="20" y1="4" x2="20" y2="16" stroke="#c8ff00" stroke-width="2.5" stroke-linecap="round"/>
        <line x1="20" y1="24" x2="20" y2="36" stroke="#c8ff00" stroke-width="2.5" stroke-linecap="round"/>
        <line x1="4" y1="20" x2="16" y2="20" stroke="#c8ff00" stroke-width="2.5" stroke-linecap="round"/>
        <line x1="24" y1="20" x2="36" y2="20" stroke="#c8ff00" stroke-width="2.5" stroke-linecap="round"/>
      </svg>
      <div class="feat-pos-crosshair-dot"></div>
    </div>
    <div id="feat-pos-coords">—</div>
  </div>
  <div id="feat-pos-sheet">
    <div style="font-size:11px;color:var(--td);font-family:var(--fh);font-weight:700;margin-bottom:6px">ART DER SCHLÜSSELSTELLE</div>
    <div id="feat-pos-type-grid"></div>
    <div style="font-size:11px;color:var(--td);font-family:var(--fh);font-weight:700;margin-bottom:4px">SCHWIERIGKEIT</div>
    <div class="feat-pos-stars" id="feat-pos-stars"></div>
    <input id="feat-pos-name" class="sp-input" placeholder="Bezeichnung (optional)" maxlength="60"
      style="width:100%;box-sizing:border-box;margin-bottom:10px"/>
    <div style="display:flex;gap:8px">
      <button class="sp-btn sec" style="flex:1;justify-content:center" onclick="closeFeatPosPicker()">Abbrechen</button>
      <button class="sp-btn prim" style="flex:2;justify-content:center" onclick="saveFeatFromPicker()">📍 Hier hinzufügen</button>
    </div>
  </div>
</div>

<!-- FABS -->
<div class="fabs">
  <!-- Floating 🔊 Speak-FAB (sitzt jetzt sauber oben in der Gruppe) -->
  <button id="a11y-speak-fab" onclick="speakCurrentContext()" aria-label="Vorlesen" title="Aktuelle Ansicht vorlesen [V]">🔊</button>

  <button class="fab" id="gps-fab" onclick="locateUser()" aria-label="GPS">
    <svg id="gps-icon" width="20" height="20" viewBox="0 0 20 20" fill="none"><circle cx="10" cy="10" r="3" fill="currentColor"/><path d="M10 2V5M10 15V18M18 10H15M5 10H2" stroke="currentColor" stroke-width="1.8" stroke-linecap="round"/><circle cx="10" cy="10" r="7" stroke="currentColor" stroke-width="1.2" opacity=".35"/></svg>
  </button>
  <button class="fab" id="gpx-fab" onclick="openGpxPanel('load')" aria-label="GPX Tracks" style="position:relative">
    <svg width="20" height="20" viewBox="0 0 20 20" fill="none"><path d="M3 15L7 9L11 12L15 6L18 9" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/><circle cx="3" cy="15" r="1.8" fill="currentColor"/><circle cx="18" cy="9" r="1.8" fill="currentColor"/></svg>
    <span class="fab-badge" id="gpx-cnt" style="display:none">0</span>
  </button>
  <button class="fab" id="rec-fab" onclick="openGpxPanel('rec')" aria-label="Aufnahme starten">
    <svg width="18" height="18" viewBox="0 0 18 18" fill="none"><circle cx="9" cy="9" r="6" stroke="currentColor" stroke-width="1.6"/><circle cx="9" cy="9" r="3" fill="currentColor"/></svg>
  </button>
  <button class="fab" id="theme-fab" onclick="toggleTheme()" aria-label="Hell/Dunkel Modus" title="Hell/Dunkel wechseln">
    <svg id="ti-moon" width="18" height="18" viewBox="0 0 18 18" fill="none"><path d="M15.5 11A6.5 6.5 0 017 3.5a.5.5 0 00-.6-.57A7 7 0 1015.07 12a.5.5 0 00-.57-.6 6.5 6.5 0 01-.98.07L15.5 11z" fill="currentColor" opacity=".9"/></svg>
    <svg id="ti-sun" width="18" height="18" viewBox="0 0 18 18" fill="none" style="display:none"><circle cx="9" cy="9" r="3.5" stroke="currentColor" stroke-width="1.7"/><path d="M9 1.5v2M9 14.5v2M1.5 9h2M14.5 9h2M3.6 3.6l1.4 1.4M13 13l1.4 1.4M3.6 14.4l1.4-1.4M13 5l1.4-1.4" stroke="currentColor" stroke-width="1.7" stroke-linecap="round"/></svg>
  </button>
  <button class="fab" onclick="fitAll()" aria-label="Übersicht">
    <svg width="18" height="18" viewBox="0 0 18 18" fill="none"><rect x="1" y="1" width="5" height="5" rx="1.5" stroke="currentColor" stroke-width="1.6"/><rect x="12" y="1" width="5" height="5" rx="1.5" stroke="currentColor" stroke-width="1.6"/><rect x="1" y="12" width="5" height="5" rx="1.5" stroke="currentColor" stroke-width="1.6"/><rect x="12" y="12" width="5" height="5" rx="1.5" stroke="currentColor" stroke-width="1.6"/></svg>
  </button>
  <button class="fab" id="settings-fab" onclick="openSettings()" aria-label="Einstellungen" title="Einstellungen">
    <svg width="18" height="18" viewBox="0 0 20 20" fill="none"><path d="M10 13a3 3 0 100-6 3 3 0 000 6z" stroke="currentColor" stroke-width="1.7"/><path d="M10 2v1.5M10 16.5V18M18 10h-1.5M3.5 10H2M15.36 4.64l-1.06 1.06M5.7 14.3l-1.06 1.06M15.36 15.36l-1.06-1.06M5.7 5.7L4.64 4.64" stroke="currentColor" stroke-width="1.7" stroke-linecap="round"/></svg>
  </button>
</div>


<!-- Marker-Creation-Mode-Bar -->
<div id="marker-mode-bar" style="display:none;position:fixed;top:0;left:0;right:0;z-index:950;background:rgba(200,255,0,.92);color:#0b0e14;font-family:var(--fh);font-size:13px;font-weight:800;letter-spacing:.8px;text-transform:uppercase;text-align:center;padding:10px 48px;box-shadow:0 2px 12px rgba(0,0,0,.4)">
  📍 Marker-Modus — Doppelklick auf Karte setzen
  <button onclick="toggleMarkerMode(false)" style="position:absolute;right:12px;top:50%;transform:translateY(-50%);background:rgba(0,0,0,.2);border:none;border-radius:8px;padding:4px 10px;cursor:pointer;font-family:var(--fh);font-size:12px;font-weight:700;color:#0b0e14">✕ Ende</button>
</div>

<!-- LEGEND -->
<div id="legend">
  <div class="lgnd-t">Legende</div>
  <div class="lgnd-r"><div class="lgnd-d" style="background:var(--beg)"></div><span class="lgnd-l">Beginner</span></div>
  <div class="lgnd-r"><div class="lgnd-d" style="background:var(--mit)"></div><span class="lgnd-l">Mittel</span></div>
  <div class="lgnd-r"><div class="lgnd-d" style="background:var(--exp)"></div><span class="lgnd-l">Expert</span></div>
  <div class="lgnd-r"><div class="lgnd-d" style="background:var(--log)"></div><span class="lgnd-l">Logistik</span></div>
</div>

<div id="backdrop" onclick="closeAll()"></div>

<!-- SHEET -->
<div id="sheet" role="dialog" aria-modal="true" aria-labelledby="sheet-title">
  <div class="s-handle"></div>
  <div class="s-head">
    <div style="display:flex;align-items:center;gap:10px">
      <span class="s-title" id="sheet-title">Trail Punkte</span>
      <span class="s-cnt" id="s-cnt">0</span>
    </div>
    <div style="display:flex;align-items:center;gap:8px">
      <button id="sheet-tts-btn" onclick="onA11yToggle(!_a11y.enabled)"
        title="Vorlesen ein/aus" aria-label="Vorlesen ein/aus">🔊</button>
      <button class="s-close" onclick="closeAll()">×</button>
    </div>
  </div>
  <div class="s-scroll" id="s-list"></div>
</div>

<!-- QR MODAL -->
<div id="qrm" role="dialog" aria-modal="true" aria-labelledby="qr-nm">
  <div class="qr-nm" id="qr-nm">Standort</div>
  <div class="qr-hint" id="qr-hint">QR scannen → startet Navigation in Google Maps</div>
  <div id="qr-wrap"><canvas id="qr-canvas" width="160" height="160" aria-label="QR Code"></canvas></div>
  <input id="qr-inp" type="text" readonly onclick="this.select()">
  <div class="qr-acts">
    <button class="qbtn cl" onclick="closeAll()">← Zurück</button>
    <button class="qbtn cp" onclick="copyQR()">📋 Kopieren</button>
    <button class="qbtn dl" onclick="downloadQR()">⬇ QR</button>
  </div>
</div>

<!-- GPS HINT -->
<div id="gpshint">
  <button id="gpshint-x" onclick="hideGpsHint()">×</button>
  <strong id="gpshint-t">GPS Problem</strong>
  <span id="gpshint-m">Standortzugriff verweigert.</span>
</div>

<!-- AUFNAHME STATUS BAR -->
<div id="rec-bar">
  <div class="rec-dot"></div>
  <span class="rec-bar-txt" id="rec-bar-txt">00:00:00</span>
</div>

<!-- GPX PANEL -->
<div id="gpx-panel" role="dialog" aria-modal="true" aria-labelledby="gpx-panel-title">
  <div class="s-handle"></div>
  <div class="s-head">
    <div style="display:flex;align-items:center;gap:10px">
      <span class="s-title" id="gpx-panel-title">GPX & Tracks</span>
      <span class="s-cnt" id="gpx-track-cnt">0 Tracks</span>
    </div>
    <button class="s-close" onclick="closeGpxPanel()">×</button>
  </div>
  <!-- TABS -->
  <div class="gpx-tabs">
    <button class="gpx-tab on" data-tab="load" onclick="switchGpxTab('load',this)">Laden</button>
    <button class="gpx-tab" data-tab="tracks" onclick="switchGpxTab('tracks',this)">Tracks</button>
    <button class="gpx-tab" data-tab="rec" onclick="switchGpxTab('rec',this)">Aufnahme</button>
  </div>

  <!-- TAB: LADEN -->
  <div class="gpx-content on" id="gpx-tab-load">
    <!-- Kategorie Auswahl -->
    <div class="gpx-section">
      <span class="gpx-label">Kategorie für neuen Track</span>
      <select class="gpx-select" id="gpx-cat">
        <option value="beginner">🟢 Beginner</option>
        <option value="mittel" selected>🟡 Mittel</option>
        <option value="expert">🔴 Expert</option>
      </select>
    </div>
    <!-- Datei Upload -->
    <div class="gpx-section">
      <span class="gpx-label">GPX vom Gerät laden</span>
      <label class="gpx-file-label" for="gpx-file-input">
        <svg width="20" height="20" viewBox="0 0 20 20" fill="none"><path d="M10 13V4M6 8L10 4L14 8" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/><path d="M3 16H17" stroke="currentColor" stroke-width="1.8" stroke-linecap="round"/></svg>
        .gpx Datei(en) auswählen oder hierher ziehen
      </label>
      <input type="file" id="gpx-file-input" accept=".gpx,application/gpx+xml,application/xml,text/xml" multiple onchange="handleGpxFiles(this)">
    </div>
    <!-- URL laden -->
    <div class="gpx-section">
      <span class="gpx-label">GPX per URL laden</span>
      <div class="gpx-row" style="margin-bottom:6px">
        <input class="gpx-input" id="gpx-url-inp" type="url" placeholder="https://raw.githubusercontent.com/…/track.gpx">
        <button class="gpx-btn prim" onclick="loadGpxFromUrl()">
          <svg width="14" height="14" viewBox="0 0 14 14" fill="none"><path d="M2 7H12M8 3L12 7L8 11" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/></svg>
          Laden
        </button>
      </div>
      <div class="cors-hint">
        <b style="color:var(--ac)">GitHub:</b> <code style="font-size:10px;background:var(--s3);padding:1px 4px;border-radius:3px;font-family:monospace">/blob/</code> → <code style="font-size:10px;background:var(--s3);padding:1px 4px;border-radius:3px;font-family:monospace">raw.githubusercontent.com</code> (wird automatisch umgewandelt) &nbsp;·&nbsp;
        CORS-Fehler: <a href="#" onclick="useCorsProxy();return false">Proxy aktivieren</a> <span style="color:var(--tm)">(Datenschutz beachten)</span>
      </div>
    </div>
  </div>

  <!-- TAB: TRACKS -->
  <div class="gpx-content" id="gpx-tab-tracks">
    <!-- Kategorie-Filter -->
    <div class="cat-filter-row">
      <button class="cat-fbtn on" data-c="all" onclick="filterTracks('all',this)">Alle</button>
      <button class="cat-fbtn" data-c="beginner" onclick="filterTracks('beginner',this)">🟢 Beginner</button>
      <button class="cat-fbtn" data-c="mittel" onclick="filterTracks('mittel',this)">🟡 Mittel</button>
      <button class="cat-fbtn" data-c="expert" onclick="filterTracks('expert',this)">🔴 Expert</button>
    </div>
    <div id="trk-list"><div style="padding:20px 16px;text-align:center;color:var(--td);font-family:var(--fh);font-size:13px;font-weight:700;text-transform:uppercase;letter-spacing:1px">Noch keine Tracks geladen</div></div>
    <!-- Elevation Profile -->
    <div id="elev-panel" aria-label="Höhenprofil">
      <div id="elev-title">Höhenprofil</div>
      <canvas id="elev-canvas"></canvas>
      <div id="elev-stats">
        <div class="elev-stat"><div class="elev-stat-v" id="elev-min">–</div><div class="elev-stat-l">Min m</div></div>
        <div class="elev-stat"><div class="elev-stat-v" id="elev-max">–</div><div class="elev-stat-l">Max m</div></div>
        <div class="elev-stat"><div class="elev-stat-v" id="elev-gain">–</div><div class="elev-stat-l">↑ Aufst.</div></div>
        <div class="elev-stat"><div class="elev-stat-v" id="elev-dist">–</div><div class="elev-stat-l">km</div></div>
      </div>
    </div>
  </div>

  <!-- TAB: AUFNAHME -->
  <div class="gpx-content" id="gpx-tab-rec">
    <!-- Fahrerprofil (geladen beim Starten) -->
    <div id="rec-rider-bar" style="display:none;align-items:center;gap:8px;padding:7px 12px;background:var(--s3);border-radius:10px;margin:0 0 4px;font-size:12px;color:var(--td)">
      <span style="font-size:18px">🚴</span>
      <span id="rec-rider-info" style="flex:1;font-weight:700;color:var(--tx)">–</span>
      <span style="font-size:10px;opacity:.6">aus Profil</span>
    </div>
    <div class="gpx-section" style="text-align:center;padding-bottom:0;border-bottom:none">
      <div class="rec-timer" id="rec-timer">00:00:00</div>
      <div class="rec-status" id="rec-status-txt" style="color:var(--tm)">Bereit</div>
    </div>
    <div class="rec-stats">
      <div class="rec-stat"><div class="rec-stat-val" id="rec-dist">0.0</div><div class="rec-stat-lbl">km</div></div>
      <div class="rec-stat"><div class="rec-stat-val" id="rec-pts">0</div><div class="rec-stat-lbl">Punkte</div></div>
      <div class="rec-stat"><div class="rec-stat-val" id="rec-speed">0.0</div><div class="rec-stat-lbl">km/h</div></div>
    </div>
    <div class="rec-controls">
      <button class="gpx-btn prim" id="rec-start-btn" onclick="recStart()" style="flex:2">
        <svg width="14" height="14" viewBox="0 0 14 14" fill="none"><circle cx="7" cy="7" r="5.5" stroke="currentColor" stroke-width="1.5"/><circle cx="7" cy="7" r="3" fill="currentColor"/></svg>
        Aufnahme starten
      </button>
      <button class="gpx-btn sec" id="rec-pause-btn" onclick="recPause()" style="display:none;flex:1">Pause</button>
      <button class="gpx-btn danger" id="rec-stop-btn" onclick="recStop()" style="display:none">Stop</button>
    </div>
    <!-- Speichern-Bereich (nach Stop sichtbar) -->
    <div class="gpx-section" id="rec-save-section" style="display:none">
      <span class="gpx-label">Strecke speichern &amp; laden</span>
      <!-- Zusammenfassung der Aufnahme -->
      <div id="rec-summary" style="display:flex;gap:6px;flex-wrap:wrap;margin-bottom:8px;font-size:11px;color:var(--td);background:var(--s3);padding:8px 10px;border-radius:8px;line-height:1.7"></div>
      <div style="display:flex;flex-direction:column;gap:8px">
        <!-- Name -->
        <div class="gpx-row">
          <input class="gpx-input" id="rec-name-inp" type="text" placeholder="Streckenname…">
        </div>
        <!-- Kategorie -->
        <select class="gpx-select" id="rec-save-cat">
          <option value="beginner">🟢 Beginner</option>
          <option value="mittel" selected>🟡 Mittel</option>
          <option value="expert">🔴 Expert</option>
        </select>
        <!-- Beschreibung / Notizen -->
        <textarea class="gpx-input" id="rec-notes-inp" placeholder="Notizen zur Strecke (optional)…"
          style="min-height:60px;resize:vertical;font-family:inherit;font-size:13px;line-height:1.4"></textarea>
        <!-- Aktionen -->
        <button class="gpx-btn prim" onclick="recAddToMap()" style="width:100%;justify-content:center">
          ＋ In Karte laden &amp; anzeigen
        </button>
        <div class="gpx-row">
          <button class="gpx-btn sec" onclick="recExportGpx()" style="flex:1">⬇ GPX</button>
          <button class="gpx-btn sec" onclick="recExportJson()" style="flex:1">⬇ JSON</button>
        </div>
        <!-- Web Share API — GPX direkt teilen (Android/iOS) -->
        <button id="rec-share-btn" class="gpx-btn prim" onclick="recShareGpx()" style="width:100%;display:none">
          📤 Strecke teilen (Android / iOS)
        </button>
        <button class="gpx-btn danger" onclick="recReset()" style="width:100%">🗑 Aufnahme verwerfen</button>
      </div>
    </div>
  </div>
</div>


<!-- DRAG & DROP Overlay für GPX -->
<div id="gpx-drop-overlay" style="display:none;position:fixed;inset:0;z-index:1500;background:rgba(200,255,0,.12);border:3px dashed var(--ac);pointer-events:none;align-items:center;justify-content:center;font-family:var(--fh);font-size:18px;font-weight:800;letter-spacing:1px;color:var(--ac);text-transform:uppercase">
  GPX Datei hier ablegen
</div>
<!-- TRACK QR MODAL -->
<div id="trk-qrm" style="position:fixed;top:50%;left:50%;z-index:1100;transform:translate(-50%,-50%) scale(.88);background:var(--s1);border:1px solid var(--bd2);border-radius:20px;box-shadow:0 20px 60px rgba(0,0,0,.8);width:92%;max-width:360px;padding:20px;text-align:center;opacity:0;visibility:hidden;transition:all .25s cubic-bezier(.32,.72,0,1)">
  <div style="font-family:var(--fh);font-size:17px;font-weight:800;letter-spacing:.5px;text-transform:uppercase;color:var(--tx);margin-bottom:2px" id="trk-qr-nm">Track</div>
  <div style="font-size:11px;color:var(--td);margin-bottom:12px" id="trk-qr-hint">GPX laden oder QR scannen</div>
  <div style="width:228px;height:228px;margin:0 auto 10px;background:#fff;border-radius:12px;padding:8px;display:flex;align-items:center;justify-content:center">
    <canvas id="trk-qr-canvas" width="212" height="212" style="display:block;border-radius:6px;image-rendering:pixelated;image-rendering:crisp-edges" aria-label="Track QR Code"></canvas>
  </div>
  <!-- Chunk-Navigation (nur bei Multi-QR sichtbar) -->
  <div id="trk-qr-chunk-nav" style="display:none;margin-bottom:10px">
    <div style="display:flex;align-items:center;gap:8px;justify-content:center;margin-bottom:6px">
      <button id="trk-qr-prev" onclick="trkQrPrevChunk()"
        style="flex:1;padding:8px 4px;border-radius:8px;border:1px solid var(--bd2);background:var(--s2);color:var(--td);font-family:var(--fh);font-weight:700;font-size:12px;cursor:pointer">← Zurück</button>
      <div style="text-align:center;min-width:64px">
        <div style="font-family:var(--fh);font-weight:800;font-size:16px;color:var(--tx)" id="trk-qr-chunk-counter">1 / 1</div>
        <div style="font-size:9px;color:var(--td);text-transform:uppercase;letter-spacing:.5px">QR-Code</div>
      </div>
      <button id="trk-qr-next" onclick="trkQrNextChunk()"
        style="flex:1;padding:8px 4px;border-radius:8px;border:none;background:var(--ac);color:#000;font-family:var(--fh);font-weight:800;font-size:12px;cursor:pointer">Weiter →</button>
    </div>
    <!-- Fortschrittsbalken der Chunks -->
    <div id="trk-qr-chunk-bar" style="display:flex;gap:3px;justify-content:center"></div>
    <div style="font-size:10px;color:var(--td);margin-top:4px">Alle QR-Codes nacheinander scannen</div>
  </div>
  <div style="font-size:10px;color:var(--td);margin-bottom:12px;padding:8px;background:var(--s2);border-radius:8px;text-align:left;line-height:1.5" id="trk-qr-info"></div>
  <div style="display:flex;gap:8px;margin-bottom:8px">
    <button class="qbtn sec" onclick="closeAll()" style="flex:1;background:var(--s2);color:var(--td)">← Zurück</button>
    <button class="qbtn dl" onclick="trkQrDownloadGpx()" style="flex:2" id="trk-qr-dl-btn">⬇ GPX laden</button>
  </div>
  <!-- Web Share API: GPX-Datei teilen (Android/iOS/Chrome) -->
  <button id="trk-qr-share-btn" class="qbtn dl" onclick="trkQrShareGpx()"
    style="width:100%;margin-bottom:8px;background:var(--ac);color:#000;display:none">
    📤 GPX teilen (Android / iOS)
  </button>
  <div style="display:flex;gap:8px">
    <button class="qbtn cp" onclick="trkQrDownloadImg()" style="flex:1;background:var(--s3);color:var(--tx)">⬇ QR Bild</button>
    <button class="qbtn cp" onclick="trkQrCopyUrl()" style="flex:1;background:var(--s3);color:var(--tx)">📋 Link</button>
  </div>
</div>
<div id="toast"></div>
<!-- Accessibility: ARIA live regions for screen reader announcements -->
<div id="a11y-live-polite"    aria-live="polite"    aria-atomic="true" role="status"  class="sr-only"></div>
<div id="a11y-live-assertive" aria-live="assertive" aria-atomic="true" role="alert"   class="sr-only"></div>

<script>
// ═══════════════════════════════════════════════════════════════
// GMTW TRAIL MAP — vollständiges JS
// Fixes: XSS, QR lokal, localStorage, Theme, Elevation, Deep Link
// ═══════════════════════════════════════════════════════════════

// ── SICHERHEIT: Universelle HTML-Escape-Funktion ──────────────
function escHtml(s){
  if(s==null)return '';
  return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;');
}
// Alias für Legacy-Code & onclick-Strings
function esc(s){ return String(s||'').replace(/'/g,"\\'"); }
function escXml(s){ return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

// ── LOKALSTORAGE: sicheres Lesen/Schreiben ─────────────────────
const LS = {
  K: { TRACKS:'gmtw_tracks_v2', RUNS:'gmtw_runs_v1', REC:'gmtw_rec_v2', VIEW:'gmtw_view_v1', THEME:'gmtw_theme',
       GPS_EMOJI:'gmtw_gps_emoji', HOME_REGION:'gmtw_home_region', INSTALL_DECLINE:'gmtw_install_decline',
       CUSTOM_MARKERS:'gmtw_custom_markers_v1', PROFILE:'gmtw_profile_v1', A11Y:'gmtw_a11y_v1',
       PROJECTS:'gmtw_projects_v1', ACTIVE_PROJECT:'gmtw_active_project_v1' },
  _ok: null,

  // Prüft ob localStorage verfügbar ist (Private Mode, iOS-Restrictions etc.)
  ok() {
    if (this._ok !== null) return this._ok;
    try {
      localStorage.setItem('__gmtw_probe__','1');
      localStorage.removeItem('__gmtw_probe__');
      this._ok = true;
    } catch(e) { this._ok = false; }
    return this._ok;
  },

  set(key, val) {
    if (!this.ok()) return false;
    try {
      localStorage.setItem(key, JSON.stringify(val));
      return true;
    } catch(e) {
      const isQuota = e.name==='QuotaExceededError'
        || e.name==='NS_ERROR_DOM_QUOTA_REACHED'
        || e.code===22;
      if (isQuota) {
        // Key löschen, nochmal versuchen
        try {
          localStorage.removeItem(key);
          localStorage.setItem(key, JSON.stringify(val));
          return true;
        } catch(e2) {
          console.warn('localStorage quota exceeded:', key);
          return false;
        }
      }
      console.warn('localStorage.set error:', key, e);
      return false;
    }
  },

  get(key, fb=null) {
    if (!this.ok()) return fb;
    try {
      const raw = localStorage.getItem(key);
      return raw !== null ? JSON.parse(raw) : fb;
    } catch(e) { return fb; }
  },

  del(key) {
    if (!this.ok()) return;
    try { localStorage.removeItem(key); } catch(e) {}
  },

  // Belegten Speicher (nur gmtw_* Keys) in Bytes schätzen
  usedBytes() {
    if (!this.ok()) return 0;
    try {
      let n = 0;
      for (let i = 0; i < localStorage.length; i++) {
        const k = localStorage.key(i);
        if (k && k.startsWith('gmtw_')) {
          const v = localStorage.getItem(k) || '';
          n += (k.length + v.length) * 2;
        }
      }
      return n;
    } catch(e) { return 0; }
  }
};

// ── DATEN ──────────────────────────────────────────────────────
const LOCS = [
  // BEGINNER
  { id:"muni",     name:"Muni Start Beginner/Mittel", lat:51.421812, lng:7.492612, color:"#22c55e", emoji:"🚩", cat:"beginner", desc:"Startpunkt für Muni-Fahrer aller Levels" },
  // MITTEL — Koordinaten korrekt: sam-mit=Sammelpunkt(51.423371), ziel-mit=Ziel(51.419329)
  { id:"ein-mit",  name:"Einstieg Mittel",            lat:51.423421, lng:7.480829, color:"#f59e0b", emoji:"🟡", cat:"mittel",   desc:"Einstieg in die mittlere Strecke" },
  { id:"ziel-mit", name:"Ziel Mittel",                lat:51.419329, lng:7.511120, color:"#f59e0b", emoji:"🏆", cat:"mittel",   desc:"Ziel der mittleren Strecke — an der Ruhr" },
  // EXPERT
  { id:"exp-zone", name:"Expert Zone",                lat:51.418692, lng:7.475410, color:"#ef4444", emoji:"⚠️", cat:"expert",   desc:"Hochanspruchsvolles Gelände" },
  { id:"exp-kurs", name:"Zerstörer",                  lat:51.416403, lng:7.453939, color:"#ef4444", emoji:"🎇", cat:"expert",   desc:"Links sehr schwer, rechts schwer" },
  // LOGISTIK
  { id:"camp",      name:"GMTW Camp",            lat:51.417704, lng:7.494867, color:"#38bdf8", emoji:"⛺", cat:"logistik", desc:"Hauptcamp des Events — Basisstation", large:true },
  { id:"camp-tor",  name:"Camp Tor",             lat:51.417482, lng:7.490904, color:"#38bdf8", emoji:"🚧", cat:"logistik", desc:"Haupteingang zum GMTW Camp" },
  { id:"zeltplatz", name:"Zeltplatz Eingang",    lat:51.420130, lng:7.495086, color:"#38bdf8", emoji:"🏕️",cat:"logistik", desc:"Eingang Campingplatz Hohensyburg · Syburger Dorfstr. 69" },
  { id:"sam-beg",   name:"Sammelpunkt Beginner", lat:51.419799, lng:7.484685, color:"#38bdf8", emoji:"👥", cat:"logistik", desc:"Treffpunkt nach dem Aufstieg vom Camp" },
  { id:"sam-mit",  name:"Sammelpunkt Mittel",         lat:51.423371, lng:7.513606, color:"#f59e0b", emoji:"👥", cat:"logistik", desc:"Sammelpunkt — Auf dem Spielplatz" },
  { id:"sam-camp",  name:"Sammelpunkt → Camp",   lat:51.418164, lng:7.478552, color:"#38bdf8", emoji:"🔁", cat:"logistik", desc:"Treffpunkt für den Rückweg ins Camp" },
  { id:"wc",        name:"Dusche / WC",          lat:51.418808, lng:7.493754, color:"#a78bfa", emoji:"🚿", cat:"logistik", desc:"Sanitäreinrichtungen am Camp" },
  // Rückweg ins Camp (Polyline + Mittelpunkt-Marker; standardmäßig ausgeblendet)
  { id:"weg-camp",  name:"Weg zurück ins Camp",  lat:51.417784, lng:7.484588, color:"#f59e0b", emoji:"↩️", cat:"logistik", desc:"Rückweg vom Kurs zum Camp — ca. 1 km", line:true },
];

const CATS = {
  beginner: { label:"Beginner",                color:"var(--beg)" },
  mittel:   { label:"Mittel",                  color:"var(--mit)" },
  expert:   { label:"Expert",                  color:"var(--exp)" },
  logistik: { label:"Logistik & Einrichtungen",color:"var(--log)" },
};
const WEG = [[51.418146,7.478490],[51.417422,7.490686]];

// GPX Farben (spec-konform)
const GPX_COLORS = { beginner:'#27AE60', mittel:'#D4A017', expert:'#ef4444' };

// ── KARTE ──────────────────────────────────────────────────────
// Start-Koordinaten: Priorität: 1) gespeicherte View, 2) Home-Fokus, 3) Standard
const _DEFAULT_CENTER = [51.4192, 7.4855];
const _DEFAULT_ZOOM   = 16;

function _resolveStartView() {
  // 1) Zuletzt gespeicherte Kamera-Position (höchste Priorität)
  const v = LS.get(LS.K.VIEW);
  if (v && typeof v.lat === 'number' && typeof v.lng === 'number' && typeof v.zoom === 'number') {
    return { center: [v.lat, v.lng], zoom: v.zoom };
  }
  // 2) Home-Fokus aus den Einstellungen
  const hr = LS.get(LS.K.HOME_REGION);
  if (hr) {
    const lat = parseFloat(hr.lat), lng = parseFloat(hr.lng);
    // Validierung: lat ∈ [-90, 90], lng ∈ [-180, 180]
    if (!isNaN(lat) && !isNaN(lng) && lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180) {
      return { center: [lat, lng], zoom: _DEFAULT_ZOOM };
    }
  }
  // 3) Fallback
  return { center: _DEFAULT_CENTER, zoom: _DEFAULT_ZOOM };
}

const _sv = _resolveStartView();
const map = L.map('map',{zoomControl:false,tap:false,zoomSnap:0.1,zoomDelta:0.5,wheelPxPerZoomLevel:120})
              .setView(_sv.center, _sv.zoom);
L.control.zoom({position:'bottomright'}).addTo(map);

const TOPO = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',{
  maxNativeZoom:17,maxZoom:26,
  keepBuffer:4,updateWhenIdle:false,updateWhenZooming:false,
  attribution:'<a href="https://opentopomap.org">© OpenTopoMap</a> (CC-BY-SA) · <a href="https://www.openstreetmap.org/copyright">© OSM</a>'
}).addTo(map);
const SAT = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',{
  maxNativeZoom:19,maxZoom:26,
  keepBuffer:4,updateWhenIdle:false,updateWhenZooming:false,
  attribution:'© Esri'
});
let isSat=false;
function toggleLayer(){
  if(isSat){map.removeLayer(SAT);map.addLayer(TOPO);isSat=false;toast('🌲 Topo Ansicht')}
  else{map.removeLayer(TOPO);map.addLayer(SAT);isSat=true;toast('🛰 Satellit Ansicht')}
}

// Kartenposition speichern bei Bewegung
map.on('moveend zoomend',()=>{
  const c=map.getCenter();
  LS.set(LS.K.VIEW,{lat:c.lat,lng:c.lng,zoom:map.getZoom()});
});

// ══════════════════════════════════════════════════════════════
// PROFESSIONELLES TILE-PRE-CACHING
// Prinzip: Wenn die Karte ruhig ist, alle Tiles des sichtbaren
// Bereichs + Puffer in allen relevanten Zoomstufen vorab cachen.
// Nutzt requestIdleCallback → blockiert NICHT den Hauptthread.
// Der SW verwaltet ein Konkurrenz-Limit, kein Browser-Hang.
// ══════════════════════════════════════════════════════════════
const _TPC = {
  _tid:   null,  // debounce timer
  _idle:  null,  // idle callback handle
  DEBOUNCE:  1400, // ms nach letztem move/zoom
  PAD:       0.5,  // Viewport-Puffer (50 % pro Seite)
  ZOOM_BELOW: 2,   // Zoomstufen unter aktuellem Zoom cachen
  ZOOM_ABOVE: 1,   // Zoomstufen über aktuellem Zoom cachen
  MAX_TILES:  600, // Limit pro Prefetch-Batch (verhindert Speicher-Overflow)

  // Geographische Koordinate → OSM-Tile-Index (Leaflet-Kachelsystem)
  _ll2tile(lat, lng, z) {
    const n   = 1 << z; // 2^z
    const latR = lat * Math.PI / 180;
    return {
      x: Math.floor((lng + 180) / 360 * n),
      y: Math.floor((1 - Math.log(Math.tan(latR) + 1 / Math.cos(latR)) / Math.PI) / 2 * n)
    };
  },

  // Tile-URLs für ein Bounds-Rechteck bei gegebenem Zoom berechnen.
  // Sortiert nach Manhattan-Distanz vom Mittelpunkt → wichtigste Tiles zuerst.
  _urlsForBounds(bounds, z, tplFn) {
    const nw = this._ll2tile(bounds.getNorth(), bounds.getWest(), z);
    const se = this._ll2tile(bounds.getSouth(), bounds.getEast(), z);
    const cx = (nw.x + se.x) / 2, cy = (nw.y + se.y) / 2;
    const cells = [];
    for (let x = nw.x; x <= se.x; x++)
      for (let y = nw.y; y <= se.y; y++)
        cells.push({ x, y, d: Math.abs(x - cx) + Math.abs(y - cy) });
    cells.sort((a, b) => a.d - b.d);
    return cells.map(c => tplFn(c.x, c.y, z));
  },

  // Tile-URL-Template-Funktion für OpenTopoMap (aktive Schicht)
  _topoUrl(x, y, z) {
    return `https://${'abc'[(x + y) % 3]}.tile.opentopomap.org/${z}/${x}/${y}.png`;
  },
  // Tile-URL-Template-Funktion für Esri Satellite
  _satUrl(x, y, z) {
    return `https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/${z}/${y}/${x}`;
  },

  // Prefetch-Lauf: Tiles berechnen und per SW-Message cachen
  _run() {
    if (!map || !navigator.serviceWorker?.controller) return;
    const zoom = Math.round(map.getZoom());
    if (zoom < 7 || zoom > 19) return; // Sinnlose Zoom-Extrema überspringen

    const padded   = map.getBounds().pad(this.PAD);
    const zMin     = Math.max(7,  zoom - this.ZOOM_BELOW);
    const zMax     = Math.min(19, zoom + this.ZOOM_ABOVE);
    const tplFn    = isSat ? this._satUrl : this._topoUrl;
    const allUrls  = [];

    for (let z = zMin; z <= zMax; z++)
      allUrls.push(...this._urlsForBounds(padded, z, tplFn));

    // Hard-Limit: verhindert absurde Requests bei zu großem Viewport
    const urls = allUrls.slice(0, this.MAX_TILES);
    if (!urls.length) return;

    const send = () => {
      if (!navigator.serviceWorker?.controller) return;
      const ch = new MessageChannel();
      ch.port1.onmessage = e => {
        const d = e.data;
        if (d?.fetched > 0) console.log(`[TPC] ${d.fetched} neue Tiles gecacht (${d.already} bereits vorhanden)`);
      };
      navigator.serviceWorker.controller.postMessage({ type: 'PREFETCH_TILES', urls }, [ch.port2]);
    };

    // requestIdleCallback: warte auf Browser-Idle → kein Haupt-Thread-Block
    if (this._idle) { try { cancelIdleCallback(this._idle); } catch {} this._idle = null; }
    if ('requestIdleCallback' in window) {
      this._idle = requestIdleCallback(send, { timeout: 6000 });
    } else {
      setTimeout(send, 600);
    }
  },

  // Debounced schedule: nur nach Ruhe auslösen, nicht bei jeder Tile-Bewegung
  schedule() {
    clearTimeout(this._tid);
    this._tid = setTimeout(() => this._run(), this.DEBOUNCE);
  }
};

// Tile-Prefetch nach jeder Karten-Bewegung (debounced)
map.on('moveend zoomend', () => _TPC.schedule());
// Einmalig 2,5 s nach App-Start (wenn Karte sich stabilisiert hat)
setTimeout(() => _TPC.schedule(), 2500);

// Weg zurück ins Camp — standardmäßig NICHT auf der Karte, nur bei Logistik-Filter oder manuellem Toggle
const _wegLayer = L.polyline(WEG,{color:'#f59e0b',weight:3.5,dashArray:'8 10',lineCap:'round',opacity:.85})
  .bindTooltip('↩️ Weg zurück ins Camp',{permanent:false,direction:'center',className:'path-lbl'});

// ── MARKER ─────────────────────────────────────────────────────
const MKR={};
let curFilter='all';

// Globale Marker-Größen-Skalierung (1.0 = Standard, 0.7–2.0)
let _markerScale = Math.max(0.5, Math.min(2.0, parseFloat(LS.get('gmtw_marker_scale','1.0')) || 1.0));

// ── MULTI-PROJEKT ────────────────────────────────────────────
let _projects        = [];   // Array von {id, name, centerLat, centerLng, zoom, createdAt}
let _activeProjectId = '';   // ID des aktiven Projekts

// LOCS-Sichtbarkeit und Überschreibungen (pro Marker)
let _locsHidden   = new Set();
let _locsOverrides= {};
(function _initLocsState(){
  const rawHidden = localStorage.getItem('gmtw_locs_hidden');
  try { const h = JSON.parse(rawHidden || '[]'); if(Array.isArray(h)) _locsHidden = new Set(h); } catch(e) {}
  try { _locsOverrides = JSON.parse(localStorage.getItem('gmtw_locs_overrides') || '{}'); } catch(e) {}
  // 'weg-camp' standardmäßig ausgeblendet (neuer Marker — nur bei Logistik-Filter aktiv)
  if (!rawHidden) _locsHidden.add('weg-camp');
})();

function _saveLocsState() {
  localStorage.setItem('gmtw_locs_hidden',    JSON.stringify([..._locsHidden]));
  localStorage.setItem('gmtw_locs_overrides', JSON.stringify(_locsOverrides));
}

function toggleLocsVisibility(id) {
  if (_locsHidden.has(id)) {
    _locsHidden.delete(id);
    if (MKR[id]) MKR[id].m.addTo(map);
    toast('👁 Marker wieder eingeblendet');
  } else {
    _locsHidden.add(id);
    if (MKR[id]) map.removeLayer(MKR[id].m);
    toast('🙈 Marker ausgeblendet');
  }
  // Weg-zurück-Layer mit weg-camp synchronisieren
  if (id === 'weg-camp') {
    const show = !_locsHidden.has('weg-camp');
    if (show) { if (!map.hasLayer(_wegLayer)) _wegLayer.addTo(map); }
    else      { if (map.hasLayer(_wegLayer))  map.removeLayer(_wegLayer); }
  }
  _saveLocsState();
  renderAllMarkersList();
}

// LOCS-Marker bearbeiten (Name/Emoji/Beschreibung überschreiben)
function editLocsMarker(id) {
  const base = LOCS.find(l => l.id === id);
  if (!base) return;
  const ov = _locsOverrides[id] || {};
  // Temporär eigenes Modal-Objekt als LOCS-Edit öffnen
  _pendingLocsEditId = id;
  openMdModal(null, base.lat, base.lng);
  // Felder mit aktuellen Werten befüllen (override > base)
  setTimeout(() => {
    document.getElementById('md-name').value  = ov.name  || base.name;
    document.getElementById('md-cat').value   = base.cat;
    document.getElementById('md-desc').value  = ov.desc  || base.desc || '';
    document.getElementById('md-emoji').value = ov.emoji || base.emoji;
    document.getElementById('md-gmaps').value = ov.gmapsUrl || _buildMapsLink(base.lat, base.lng);
    document.getElementById('md-lat').value   = base.lat;
    document.getElementById('md-lng').value   = base.lng;
    document.getElementById('md-lat-disp').textContent = base.lat.toFixed(6);
    document.getElementById('md-lng-disp').textContent = base.lng.toFixed(6);
    document.getElementById('md-title').textContent = 'Marker bearbeiten';
    document.getElementById('md-edit-id').value = ''; // kein custom-id
    _buildMdEmojiPicker(ov.emoji || base.emoji);
    _updateMdShareQr(base.lat, base.lng, ov.name || base.name);
  }, 30);
}

let _pendingLocsEditId = null; // gesetzt wenn LOCS-Marker im Modal bearbeitet wird

// saveMdMarker Override: erkennt LOCS-Bearbeitung
const _origSaveMdMarker = null; // wird nach Definition gepatcht

function mkIcon(loc){
  const sc   = _markerScale;
  const base = loc.large ? 36 : 30;
  const s    = Math.round(base * sc);                          // Pin-Kopf Breite = Höhe
  const is   = Math.round((loc.large ? 16 : 13) * sc);        // Emoji-Größe
  const dot  = Math.max(3, Math.round(4 * sc));               // Nadelpunkt-Durchmesser
  const mt   = Math.max(1, Math.round(2 * sc));               // margin-top Nadelpunkt
  const brd  = Math.max(1, +(1.5 * sc).toFixed(1));          // Border-Breite
  const totalH = s + mt + dot;
  const html = `<div class="pm">` +
    `<div class="pm-h" style="width:${s}px;height:${s}px;background:${loc.color};border-width:${brd}px">` +
      `<span class="pm-i" style="font-size:${is}px">${loc.emoji}</span>` +
    `</div>` +
    `<div class="pm-d" style="background:${loc.color};width:${dot}px;height:${dot}px;margin-top:${mt}px"></div>` +
  `</div>`;
  return L.divIcon({
    className:   '',
    html,
    iconSize:    [s, totalH],
    iconAnchor:  [s / 2, totalH],
    popupAnchor: [0, -(totalH + 4)]
  });
}

function mkPopup(loc){
  const c=CATS[loc.cat];
  const nm=escHtml(loc.name), ds=escHtml(loc.desc||''), badge=escHtml(c.label);
  return `<div style="background:var(--s1)">
    <div class="p-top">
      <div class="p-badge" style="background:${loc.color}">${badge}</div>
      <div class="p-name">${nm}</div>
      <div class="p-crds">${loc.lat.toFixed(5)}, ${loc.lng.toFixed(5)}</div>
      ${ds?`<div class="p-desc">${ds}</div>`:''}
    </div>
    <div class="p-acts">
      <button class="pbtn nav" onclick="navTo(${loc.lat},${loc.lng},'${esc(loc.name)}')" aria-label="Navigation starten">
        <svg width="13" height="13" viewBox="0 0 13 13" fill="none"><path d="M6.5 1L12 6.5L6.5 12M1 6.5H11.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
        Navigation
      </button>
      <button class="pbtn shr" onclick="openQR('${esc(loc.id)}')" aria-label="QR-Code anzeigen">
        <svg width="15" height="15" viewBox="0 0 14 14" fill="none"><rect x="1" y="1" width="4" height="4" rx=".5" stroke="currentColor" stroke-width="1.3"/><rect x="9" y="1" width="4" height="4" rx=".5" stroke="currentColor" stroke-width="1.3"/><rect x="1" y="9" width="4" height="4" rx=".5" stroke="currentColor" stroke-width="1.3"/><path d="M9 9h1v1M11 9h1M9 11v1M11 12h1M12 11v-1" stroke="currentColor" stroke-width="1.3" stroke-linecap="round"/></svg>
        Nav-QR
      </button>
      <button class="pbtn spk" onclick="speakPopupContent('${esc(loc.name)}','${esc(loc.desc||'')}','${esc(badge)}')" aria-label="Vorlesen" title="Vorlesen [🔊]">🔊</button>
    </div>
  </div>`;
}

LOCS.forEach(loc=>{
  // Überschreibungen aus localStorage anwenden
  const ov  = _locsOverrides[loc.id] || {};
  const eff = { ...loc, name: ov.name||loc.name, emoji: ov.emoji||loc.emoji, desc: ov.desc||loc.desc };
  const m   = L.marker([loc.lat,loc.lng],{icon:mkIcon(eff)});
  if (!_locsHidden.has(loc.id)) m.addTo(map);
  m.bindTooltip(eff.name,{permanent:true,direction:'bottom',offset:[0,4],className:'map-label'});
  m.bindPopup(mkPopup(eff),{maxWidth:292,minWidth:250});
  MKR[loc.id]={m, loc:eff, _base:loc};
});

// Alle LOCS-Marker mit aktuellen Überschreibungen neu rendern (nach Einstellungsänderung)
function reloadLocsMarkers() {
  LOCS.forEach(loc => {
    const entry = MKR[loc.id];
    if (!entry) return;
    const ov  = _locsOverrides[loc.id] || {};
    const eff = { ...loc, name: ov.name||loc.name, emoji: ov.emoji||loc.emoji, desc: ov.desc||loc.desc };
    entry.loc = eff;
    entry.m.setIcon(mkIcon(eff));
    entry.m.setTooltipContent(eff.name);
    entry.m.setPopupContent(mkPopup(eff));
    if (_locsHidden.has(loc.id)) { if (map.hasLayer(entry.m)) map.removeLayer(entry.m); }
    else { if (!map.hasLayer(entry.m)) entry.m.addTo(map); }
  });
}

// ── MARKER-GRÖSSE SLIDER ───────────────────────────────────────
// Live-Vorschau während Slider gezogen wird (nur Label aktualisieren)
function onMkScaleInput(val) {
  const sliderVal = document.getElementById('mk-scale-val');
  if (sliderVal) sliderVal.textContent = val + '%';
}
// Beim Loslassen: Skalierung speichern + ALLE Marker neu rendern
function onMkScaleChange(val) {
  const pct = parseInt(val, 10);
  _markerScale = Math.max(0.5, Math.min(2.0, pct / 100));
  localStorage.setItem('gmtw_marker_scale', _markerScale.toString());
  // LOCS-Marker neu rendern
  reloadLocsMarkers();
  // Custom-Marker neu rendern
  _cmMarkers.forEach(cm => _renderOneCmMarker(cm));
  // Start/Ziel-Marker aller Tracks skalieren
  _updateAllStartFinishMarkerIcons();
  // GPS-Positions-Marker skalieren (zoom-basiert, aber jetzt mit _markerScale)
  if (userMkr && gpsOn) {
    const emoji = LS.get(LS.K.GPS_EMOJI, '🦄');
    userMkr.setIcon(_buildGpsEmojiIcon(emoji, map.getZoom()));
  }
  // Rennen-Checkpoint-Marker skalieren (falls Rennen aktiv)
  _updateCpMarkerIcons();
  toast('📐 Marker-Größe: ' + pct + '%');
}

// ── SHEET / POI-LISTE ──────────────────────────────────────────
function buildList(){
  const c=document.getElementById('s-list'); c.innerHTML='';
  let n=0;
  const _navSvg = `<svg width="13" height="13" viewBox="0 0 13 13" fill="none"><path d="M6.5 1L12 6.5L6.5 12M1 6.5H11" stroke="currentColor" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
  const _qrSvg  = `<svg width="13" height="13" viewBox="0 0 14 14" fill="none"><rect x="1" y="1" width="4" height="4" rx=".5" stroke="currentColor" stroke-width="1.3"/><rect x="9" y="1" width="4" height="4" rx=".5" stroke="currentColor" stroke-width="1.3"/><rect x="1" y="9" width="4" height="4" rx=".5" stroke="currentColor" stroke-width="1.3"/><path d="M9 9h1v1M11 9h1M9 11v1" stroke="currentColor" stroke-width="1.3" stroke-linecap="round"/></svg>`;

  // ── 1. LOCS (feste Kartenpunkte) ───────────────────────────────────────
  ['beginner','mittel','expert','logistik'].forEach(cat=>{
    const items=LOCS.filter(l=>l.cat===cat&&(curFilter==='all'||curFilter===cat)&&!_locsHidden.has(l.id));
    if(!items.length)return;
    const hd=document.createElement('div'); hd.className='cat-head'; hd.textContent=CATS[cat].label; c.appendChild(hd);
    items.forEach(loc=>{
      if(loc.line)return; // Nur Linien-Marker überspringen (weg-camp etc.)
      n++;
      const ov=_locsOverrides[loc.id]||{};
      const effName=ov.name||loc.name; const effEmoji=ov.emoji||loc.emoji;
      const r=document.createElement('div'); r.className='lrow';
      r.setAttribute('role','listitem');
      r.innerHTML=`<div class="l-ico" style="background:${loc.color}22"><span role="img" aria-label="${escHtml(CATS[loc.cat].label)}">${effEmoji}</span></div>
        <div class="l-inf"><div class="l-nm">${escHtml(effName)}</div><div class="l-co">${loc.lat.toFixed(5)}, ${loc.lng.toFixed(5)}</div></div>
        <div class="l-btns">
          <button class="lbtn nav" aria-label="Navigation zu ${escHtml(effName)}" onclick="event.stopPropagation();navTo(${loc.lat},${loc.lng},'${esc(effName)}')">${_navSvg}</button>
          <button class="lbtn" aria-label="QR-Code für ${escHtml(effName)}" onclick="event.stopPropagation();openQR('${esc(loc.id)}')">${_qrSvg}</button>
        </div>`;
      r.addEventListener('click',()=>{ if(_a11y.enabled) speak(effEmoji+' '+effName,true); closeAll(); focusMarker(loc.id); });
      c.appendChild(r);
    });
  });

  // ── 2. Strecken-Marker (Start / Ziel der geladenen GPX-Tracks) ─────────
  const trkRows=[];
  trackStore.tracks.forEach(t=>{
    if(_activeProjectId&&t.projectId!==_activeProjectId) return;
    if(curFilter!=='all'&&curFilter!==t.cat) return;
    if(t._startMkr){
      const p=t._startMkr.getLatLng();
      trkRows.push({label:'Start',track:t,lat:p.lat,lng:p.lng,emoji:'▶',type:'start'});
    }
    if(t._finishMkr){
      const p=t._finishMkr.getLatLng();
      trkRows.push({label:'Ziel',track:t,lat:p.lat,lng:p.lng,emoji:'🏁',type:'finish'});
    }
  });
  if(trkRows.length>0){
    const hd=document.createElement('div'); hd.className='cat-head';
    hd.innerHTML=`<span>Strecken-Pins</span> <span style="font-size:10px;opacity:.7;font-weight:600">(Start &amp; Ziel)</span>`;
    c.appendChild(hd);
    trkRows.forEach(({label,track,lat,lng,emoji,type})=>{
      n++;
      const r=document.createElement('div'); r.className='lrow';
      r.setAttribute('role','listitem');
      const catColor=track.color||'#888';
      r.innerHTML=`<div class="l-ico" style="background:${catColor}22"><span role="img">${emoji}</span></div>
        <div class="l-inf">
          <div class="l-nm">${escHtml(label+': '+track.name)}</div>
          <div class="l-co" style="display:flex;align-items:center;gap:4px">
            <span style="width:7px;height:7px;border-radius:50%;background:${catColor};display:inline-block;flex-shrink:0"></span>
            ${lat.toFixed(5)}, ${lng.toFixed(5)}
          </div>
        </div>
        <div class="l-btns">
          <button class="lbtn nav" aria-label="Navigation zu ${escHtml(track.name)}" onclick="event.stopPropagation();navTo(${lat},${lng},'${esc(label+': '+track.name)}')">${_navSvg}</button>
          <button class="lbtn" aria-label="QR-Code für ${escHtml(track.name)}" onclick="event.stopPropagation();openTrackQR('${track.id}')">${_qrSvg}</button>
        </div>`;
      r.addEventListener('click',()=>{
        if(_a11y.enabled) speak(emoji+' '+label+': '+track.name,true);
        closeAll();
        map.setView([lat,lng],17);
        setTimeout(()=>{
          const mk=type==='start'?track._startMkr:track._finishMkr;
          if(mk) mk.openPopup();
        },350);
      });
      c.appendChild(r);
    });
  }

  // ── 3. Eigene Marker ────────────────────────────────────────────────────
  // Marker aller aktivierten Projekte in der Liste anzeigen
  const _enabledProjIds=new Set(_projects.filter(p=>p.enabled!==false).map(p=>p.id));
  if(_activeProjectId) _enabledProjIds.add(_activeProjectId);
  const visCm=_cmMarkers.filter(m=>_enabledProjIds.has(m.projectId)||!m.projectId);
  if(visCm.length>0){
    const hd=document.createElement('div'); hd.className='cat-head'; hd.textContent='Eigene Marker'; c.appendChild(hd);
    visCm.forEach(cm=>{
      n++;
      const color=CM_CAT_COLORS[cm.cat]||'#888';
      const emoji=cm.emoji||'📍';
      const r=document.createElement('div'); r.className='lrow';
      r.setAttribute('role','listitem');
      r.innerHTML=`<div class="l-ico" style="background:${color}22"><span role="img">${emoji}</span></div>
        <div class="l-inf"><div class="l-nm">${escHtml(cm.name)}</div><div class="l-co">${cm.lat.toFixed(5)}, ${cm.lng.toFixed(5)}</div></div>
        <div class="l-btns">
          <button class="lbtn nav" onclick="event.stopPropagation();navTo(${cm.lat},${cm.lng},'${esc(cm.name)}')">${_navSvg}</button>
          <button class="lbtn" onclick="event.stopPropagation();openCmShareQr('${cm.id}')">${_qrSvg}</button>
        </div>`;
      r.addEventListener('click',()=>{ if(_a11y.enabled) speak((cm.emoji||'📍')+' '+cm.name,true); closeAll(); map.setView([cm.lat,cm.lng],17); setTimeout(()=>{ if(_cmLeafletLayers[cm.id]) _cmLeafletLayers[cm.id].openPopup(); },350); });
      c.appendChild(r);
    });
  }

  document.getElementById('s-cnt').textContent=n;
}

function toggleSheet(){
  const s=document.getElementById('sheet'),b=document.getElementById('backdrop');
  if(s.classList.contains('open')){s.classList.remove('open');b.classList.remove('show')}
  else{
    buildList();s.classList.add('open');b.classList.add('show');s.focus();
    setTimeout(()=>{ if(map) map.invalidateSize(); },300);
    if(_a11y.enabled){
      const cats=[];
      ['beginner','mittel','expert','logistik'].forEach(cat=>{
        const n=LOCS.filter(l=>l.cat===cat&&!l.line&&!_locsHidden.has(l.id)&&(curFilter==='all'||curFilter===cat)).length;
        if(n) cats.push(CATS[cat].label+': '+n);
      });
      const cmN=(_cmMarkers||[]).filter(m=>!_activeProjectId||m.projectId===_activeProjectId).length;
      if(cmN) cats.push('Eigene Marker: '+cmN);
      speak('Menü geöffnet. '+(cats.length?cats.join(', '):'Keine Einträge')+'.',true);
    }
  }
}

function closeAll(){
  document.getElementById('sheet').classList.remove('open');
  document.getElementById('qrm').classList.remove('show');
  document.getElementById('backdrop').classList.remove('show');
  const gp=document.getElementById('gpx-panel'); if(gp) gp.classList.remove('open');
  const tq=document.getElementById('trk-qrm');
  if(tq){ tq.style.opacity='0'; tq.style.visibility='hidden'; tq.style.transform='translate(-50%,-50%) scale(.88)'; }
}

// ── FILTER ─────────────────────────────────────────────────────
// Globaler Kategorie-Filter: synchronisiert LOCS-Marker, GPX-Tracks, Eigene Marker
function setFilter(f,el){
  curFilter=f;
  // Map-Chip-Buttons aktualisieren
  document.querySelectorAll('.chip').forEach(c=>c.classList.remove('on'));
  if(el) el.classList.add('on');

  // 1. LOCS-Marker: nach Kategorie zeigen/verstecken (beachte _locsHidden)
  LOCS.forEach(loc=>{
    if(!MKR[loc.id]) return;
    const lm=MKR[loc.id].m;
    const catMatch = (f==='all'||loc.cat===f);
    const userHidden = _locsHidden.has(loc.id);
    if(catMatch && !userHidden) { if(!map.hasLayer(lm)) map.addLayer(lm); }
    else { if(map.hasLayer(lm)) map.removeLayer(lm); }
  });

  // 2. GPX-Tracks: nach Kategorie zeigen/verstecken (beachte t.visible)
  gpxFilter = f;
  // GPX-Filter-Buttons im Track-Panel synchronisieren (data-c Attribut)
  document.querySelectorAll('.cat-fbtn').forEach(b => {
    b.classList.toggle('on', b.dataset.c === f);
  });
  trackStore.tracks.forEach(t => {
    const shouldShow = (f === 'all' || t.cat === f) && t.visible;
    if (shouldShow) {
      if (!map.hasLayer(t.gpxLayer)) t.gpxLayer.addTo(map);
      if (t._startMkr  && !map.hasLayer(t._startMkr))  t._startMkr.addTo(map);
      if (t._finishMkr && !map.hasLayer(t._finishMkr)) t._finishMkr.addTo(map);
    } else {
      if (map.hasLayer(t.gpxLayer)) map.removeLayer(t.gpxLayer);
      if (t._startMkr  && map.hasLayer(t._startMkr))  map.removeLayer(t._startMkr);
      if (t._finishMkr && map.hasLayer(t._finishMkr)) map.removeLayer(t._finishMkr);
    }
  });

  // 3. Eigene Marker: nach Kategorie zeigen/verstecken
  _cmMarkers.forEach(cm => {
    const layer = _cmLeafletLayers[cm.id];
    if (!layer) return;
    const show = (f === 'all' || cm.cat === f);
    if (show) { if (!map.hasLayer(layer)) map.addLayer(layer); }
    else       { if (map.hasLayer(layer))  map.removeLayer(layer); }
  });

  // 4. POI-Liste aktualisieren
  buildList();

  // 5. "Weg zurück ins Camp"-Layer: sichtbar wenn weg-camp LOCS-Marker sichtbar ist
  const _showWeg = (f==='all'||f==='logistik') && !_locsHidden.has('weg-camp');
  if (_showWeg) { if (!map.hasLayer(_wegLayer)) _wegLayer.addTo(map); }
  else          { if (map.hasLayer(_wegLayer))  map.removeLayer(_wegLayer); }
}

function focusMarker(id){
  closeAll();
  const{m,loc}=MKR[id];
  map.flyTo([loc.lat,loc.lng],18,{animate:true,duration:1.2});
  setTimeout(()=>m.openPopup(),1250);
}
function fitAll(){
  if(!map) return;
  const lb = L.latLngBounds([]);

  // Aktive Projekt-IDs ermitteln (enabled oder Fokus-Projekt)
  const enabledIds = new Set(_projects.filter(p => p.enabled !== false).map(p => p.id));
  if (_activeProjectId) enabledIds.add(_activeProjectId); // Fokus-Projekt immer einbeziehen

  // 1. Alle aktivierten Projekte – Strecken (mit Bounds)
  trackStore.tracks
    .filter(t => enabledIds.has(t.projectId) && t.bounds)
    .forEach(t => lb.extend(L.latLngBounds(t.bounds)));

  // 2. Alle aktivierten Projekte – Custom Marker
  (_cmMarkers || [])
    .filter(m => enabledIds.has(m.projectId))
    .forEach(m => lb.extend([m.lat, m.lng]));

  // 3. LOCS-Marker IMMER einbeziehen (sichtbar + zu aktuellem Filter passend)
  //    → so zeigt "Übersicht" IMMER die gesamte Trail-Region
  LOCS
    .filter(l => !_locsHidden.has(l.id) && (curFilter === 'all' || l.cat === curFilter) && !l.line)
    .forEach(l => lb.extend([l.lat, l.lng]));

  if (lb.isValid()) {
    map.flyToBounds(lb, { padding:[52,52], maxZoom:16, animate:true, duration:1.3 });
    return;
  }

  // Fallback: Projekt-Zentrum
  const proj = _projects.find(p => p.id === _activeProjectId);
  if (proj && proj.centerLat != null) {
    map.flyTo([proj.centerLat, proj.centerLng], proj.zoom || 15, { animate:true, duration:1.2 });
  }
}

// ── NAVIGATION ─────────────────────────────────────────────────
function navTo(lat,lng,name){
  const ua=navigator.userAgent||'';
  const isIOS=/iPad|iPhone|iPod/.test(ua)&&!window.MSStream;
  const isAndroid=/Android/i.test(ua);
  const gmapsUrl=`https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}&travelmode=bicycling`;
  if(isIOS){
    let opened=false;
    window.addEventListener('blur',()=>{opened=true},{once:true});
    window.location.href=`maps://maps.apple.com/?daddr=${lat},${lng}&dirflg=d`;
    setTimeout(()=>{ if(!opened) window.open(`https://maps.apple.com/?daddr=${lat},${lng}&dirflg=d`,'_blank'); },700);
  } else if(isAndroid){
    let opened=false;
    window.addEventListener('blur',()=>{opened=true},{once:true});
    window.location.href=`geo:${lat},${lng}?q=${lat},${lng}`;
    setTimeout(()=>{ if(!opened) window.open(gmapsUrl,'_blank'); },1000);
  } else {
    window.open(gmapsUrl,'_blank');
  }
}

// ── LOKALE QR-CODE GENERIERUNG ──────────────────────────────────
/**
 * Zeichnet QR-Code lokal auf Canvas (qrcode-generator, kein CDN nötig)
 * @param {HTMLCanvasElement} canvas
 * @param {string} data - zu kodierender Inhalt
 * @param {number} size - Canvas-Größe px
 * @param {string} fgColor - Vordergrundfarbe
 * @param {string} bgColor - Hintergrundfarbe
 */
function drawQR(canvas, data, size=160, fgColor='#0b0e14', bgColor='#ffffff'){
  if(!window.qrcode){ toast('❌ QR-Lib nicht geladen'); return false; }
  try{
    const qr=window.qrcode(0,'M');
    qr.addData(data);
    qr.make();
    const n=qr.getModuleCount();
    const cell=size/n;
    canvas.width=size; canvas.height=size;
    const ctx=canvas.getContext('2d');
    ctx.fillStyle=bgColor; ctx.fillRect(0,0,size,size);
    ctx.fillStyle=fgColor;
    for(let r=0;r<n;r++) for(let c=0;c<n;c++){
      if(qr.isDark(r,c)){
        const x=Math.floor(c*cell), y=Math.floor(r*cell);
        ctx.fillRect(x,y,Math.ceil((c+1)*cell)-x,Math.ceil((r+1)*cell)-y);
      }
    }
    return true;
  }catch(e){
    console.warn('QR error:',e);
    const ctx=canvas.getContext('2d');
    ctx.fillStyle='#fff'; ctx.fillRect(0,0,size,size);
    ctx.fillStyle='#ef4444'; ctx.font=`bold 11px sans-serif`;
    ctx.textAlign='center'; ctx.fillText('QR Fehler',size/2,size/2);
    return false;
  }
}

function downloadCanvas(canvas, filename){
  try{
    canvas.toBlob(blob=>{
      const u=URL.createObjectURL(blob);
      const a=document.createElement('a'); a.href=u; a.download=filename;
      document.body.appendChild(a); a.click(); document.body.removeChild(a);
      URL.revokeObjectURL(u); toast('⬇ QR-Bild gespeichert!');
    },'image/png');
  }catch(e){
    const a=document.createElement('a'); a.href=canvas.toDataURL('image/png'); a.download=filename; a.click();
    toast('⬇ QR-Bild gespeichert!');
  }
}

// ── QR FÜR MARKER/POIs ─────────────────────────────────────────
let curQrUrl='', curQrLocId='';

function openQR(id){
  const loc=LOCS.find(l=>l.id===id); if(!loc)return;
  curQrUrl=`https://www.google.com/maps/dir/?api=1&destination=${loc.lat},${loc.lng}&travelmode=bicycling`;
  curQrLocId=id;
  document.getElementById('qr-nm').textContent=loc.name;
  document.getElementById('qr-hint').textContent='QR scannen → startet Navigation in Google Maps';
  document.getElementById('qr-inp').value=curQrUrl;
  const canvas=document.getElementById('qr-canvas');
  drawQR(canvas, curQrUrl, 160, '#0b0e14', '#ffffff');
  closeAll();
  document.getElementById('qrm').classList.add('show');
  document.getElementById('backdrop').classList.add('show');
}

function copyQR(){
  if(!curQrUrl)return;
  if(navigator.clipboard){
    navigator.clipboard.writeText(curQrUrl).then(()=>toast('✅ Link kopiert!')).catch(()=>{legacyCopy(curQrUrl);toast('✅ Link kopiert!');});
  } else { legacyCopy(curQrUrl); toast('✅ Link kopiert!'); }
}

function downloadQR(){
  const canvas=document.getElementById('qr-canvas');
  if(!canvas)return;
  downloadCanvas(canvas, `GMTW_${curQrLocId||'punkt'}_Navigation_QR.png`);
}

function legacyCopy(t){
  const el=document.createElement('textarea');
  el.value=t; el.style.cssText='position:fixed;top:-9999px;left:-9999px;opacity:0';
  document.body.appendChild(el); el.focus(); el.select();
  try{document.execCommand('copy')}catch(e){}
  document.body.removeChild(el);
}

// ── LIGHT/DARK MODE ────────────────────────────────────────────
let isDark=true;
function toggleTheme(){
  isDark=!isDark;
  document.documentElement.setAttribute('data-theme', isDark?'dark':'light');
  document.getElementById('ti-moon').style.display=isDark?'':'none';
  document.getElementById('ti-sun').style.display=isDark?'none':'';
  document.querySelector('meta[name=theme-color]').content=isDark?'#0b0e14':'#f0f4f8';
  LS.set(LS.K.THEME, isDark?'dark':'light');
  toast(isDark?'🌙 Dunkel Modus':'☀️ Hell Modus');
}
// ── PROJEKT INITIALISIERUNG ─────────────────────────────────────
// State für Karten-Erstellungsmodus
let _projCreateMode    = false;
let _projCreateDblHndl = null;
let _projCreateTempLL  = null; // { lat, lng, zoom }

function _initProjects() {
  _projects = LS.get(LS.K.PROJECTS, []);
  if (!_projects.length) {
    // Erster Start: Standard-Projekt erstellen, bestehende Home-Region übernehmen
    const hr = LS.get(LS.K.HOME_REGION);
    _projects = [{
      id: 'proj_' + Date.now(),
      name: 'GMTW',
      centerLat: hr ? (parseFloat(hr.lat)||null) : null,
      centerLng: hr ? (parseFloat(hr.lng)||null) : null,
      zoom: 16, enabled: true,
      createdAt: new Date().toISOString()
    }];
    LS.set(LS.K.PROJECTS, _projects);
  }
  // Migration: fehlende Felder ergänzen
  let migrated = false;
  _projects.forEach(p => { if (p.enabled === undefined) { p.enabled = true; migrated = true; } });
  if (migrated) LS.set(LS.K.PROJECTS, _projects);
  _activeProjectId = LS.get(LS.K.ACTIVE_PROJECT, '') || _projects[0].id;
  // Sicherstellen dass die gespeicherte ID noch existiert
  if (!_projects.find(p => p.id === _activeProjectId)) _activeProjectId = _projects[0].id;
  LS.set(LS.K.ACTIVE_PROJECT, _activeProjectId);
  // Dropdown-Label aktualisieren
  const proj = _projects.find(p => p.id === _activeProjectId);
  const nameEl = document.getElementById('proj-curr-name');
  if (nameEl && proj) nameEl.textContent = proj.name;
}

function _migrateToProjects() {
  const defaultId = _projects[0]?.id || '';
  if (!defaultId) return;
  let changed = false;
  trackStore.tracks.forEach(t => {
    if (!t.projectId) { t.projectId = defaultId; changed = true; }
  });
  if (changed) persistTracks();
}

// ── FOKUS-PROJEKT SETZEN (Ziel für neue Inhalte + Übersicht-Zoom) ────────────
function setFocusProject(id) {
  const proj = _projects.find(p => p.id === id);
  if (!proj) return;
  _activeProjectId = id;
  LS.set(LS.K.ACTIVE_PROJECT, id);
  const nameEl = document.getElementById('proj-curr-name');
  if (nameEl) nameEl.textContent = proj.name;
  renderTrackList();
  buildList();
  _ariaAnnounce('Fokus-Projekt: ' + proj.name);
}

// ── PROJEKT AKTIVIEREN / DEAKTIVIEREN (Layer-Sichtbarkeit) ──────────────────
function toggleProjectEnabled(id, enabled) {
  const proj = _projects.find(p => p.id === id);
  if (!proj) return;
  proj.enabled = !!enabled;
  LS.set(LS.K.PROJECTS, _projects);
  // Tracks ein-/ausblenden
  trackStore.tracks.filter(t => t.projectId === id).forEach(t => {
    const show = enabled && t.visible;
    if (t.gpxLayer) {
      if (show) { if (!map.hasLayer(t.gpxLayer)) t.gpxLayer.addTo(map); }
      else       { if  (map.hasLayer(t.gpxLayer)) map.removeLayer(t.gpxLayer); }
    }
    if (t._startMkr) {
      if (show) t._startMkr.addTo(map);
      else if (map.hasLayer(t._startMkr)) map.removeLayer(t._startMkr);
    }
    if (t._finishMkr) {
      if (show) t._finishMkr.addTo(map);
      else if (map.hasLayer(t._finishMkr)) map.removeLayer(t._finishMkr);
    }
  });
  // Custom Markers ein-/ausblenden
  (_cmMarkers||[]).filter(m => m.projectId === id).forEach(m => {
    const layer = _cmLeafletLayers?.[m.id];
    if (!layer) return;
    if (enabled) { if (!map.hasLayer(layer)) layer.addTo(map); }
    else         { if  (map.hasLayer(layer)) map.removeLayer(layer); }
  });
}

// ── PROJEKT-VERWALTUNG FUNKTIONEN ──────────────────────────────

// Dropdown öffnen / schließen
function toggleProjDropdown() {
  const dd  = document.getElementById('proj-dropdown');
  const btn = document.getElementById('proj-toggle-btn');
  if (!dd) return;
  const willOpen = dd.hidden;
  dd.hidden = !willOpen;
  btn.setAttribute('aria-expanded', String(willOpen));
  if (!willOpen) return;
  _renderProjList();
  setTimeout(() => document.getElementById('proj-search-inp')?.focus(), 50);
}
function closeProjDropdown() {
  const dd = document.getElementById('proj-dropdown');
  if (!dd || dd.hidden) return;
  dd.hidden = true;
  document.getElementById('proj-toggle-btn')?.setAttribute('aria-expanded','false');
}
// Schließen bei Klick außerhalb (capture phase)
document.addEventListener('click', e => {
  const bar = document.getElementById('proj-bar');
  if (bar && !bar.contains(e.target)) closeProjDropdown();
}, true);
// Schließen bei Escape
document.addEventListener('keydown', e => {
  if (e.key === 'Escape') { const dd = document.getElementById('proj-dropdown'); if (dd && !dd.hidden) { closeProjDropdown(); document.getElementById('proj-toggle-btn')?.focus(); } }
});

// Projektliste rendern
function _renderProjList(filter='') {
  const inner = document.getElementById('proj-list-inner');
  if (!inner) return;
  inner.innerHTML = '';
  const q = filter.toLowerCase();
  const list = _projects.filter(p => !q || p.name.toLowerCase().includes(q));
  if (!list.length) {
    inner.innerHTML = '<div style="padding:12px 14px;font-size:13px;color:var(--td)">Keine Projekte gefunden</div>';
    return;
  }
  list.forEach(p => {
    const isFocus   = p.id === _activeProjectId;
    const isEnabled = p.enabled !== false;
    const item = document.createElement('div');
    item.className = 'proj-item' + (isFocus ? ' active' : '');
    item.setAttribute('role','option');
    item.setAttribute('aria-selected', isFocus ? 'true' : 'false');
    item.style.cssText = 'display:flex;align-items:center;gap:6px';
    // Grüner/grauer Aktivitätspunkt
    const dot = document.createElement('span');
    dot.style.cssText = 'display:inline-block;width:7px;height:7px;border-radius:50%;flex-shrink:0;background:' + (isEnabled ? 'var(--ac)' : 'var(--td)');
    dot.title = isEnabled ? 'Aktiv' : 'Deaktiviert';
    item.appendChild(dot);
    item.appendChild(document.createTextNode('\u00a0' + p.name));
    item.addEventListener('click', () => { switchProject(p.id); closeProjDropdown(); });
    inner.appendChild(item);
  });
}
function _filterProjList(val) { _renderProjList(val); }

// ── PROJEKT WECHSELN (Fokus + sicherstellen aktiviert + Karte zoomen) ────────
function switchProject(id) {
  const proj = _projects.find(p => p.id === id);
  if (!proj) return;
  // Fokus-Projekt aktivieren falls deaktiviert
  if (!proj.enabled) {
    proj.enabled = true;
    LS.set(LS.K.PROJECTS, _projects);
    toggleProjectEnabled(id, true);
  }
  setFocusProject(id);
  fitAll();
  speak('Projekt: ' + proj.name + '.', true);
  toast('📁 ' + proj.name);
}

// ── NEUES PROJEKT — KARTEN-DOPPELKLICK-MODUS ────────────────────────────────
function startNewProjMode() {
  closeProjDropdown();
  closeSettings();
  _projCreateMode = true;
  document.body.classList.add('proj-create-mode');
  document.getElementById('proj-create-hint')?.classList.add('show');
  _projCreateDblHndl = function(e) {
    _cancelProjCreateMode(false); // Modus beenden ohne Abbrechen-Meldung
    _openProjStep2(e.latlng.lat, e.latlng.lng, map.getZoom());
  };
  map.once('dblclick', _projCreateDblHndl);
  speak('Doppelklick auf die Karte, um den Fokuspunkt des neuen Projekts zu setzen.', true);
}

function _cancelProjCreateMode(showMsg) {
  _projCreateMode = false;
  document.body.classList.remove('proj-create-mode');
  document.getElementById('proj-create-hint')?.classList.remove('show');
  if (_projCreateDblHndl && map) { map.off('dblclick', _projCreateDblHndl); _projCreateDblHndl = null; }
  if (showMsg !== false) speak('Abgebrochen.', true);
}

function _openProjStep2(lat, lng, zoom) {
  _projCreateTempLL = { lat, lng, zoom: zoom || (map ? map.getZoom() : 15) };
  const nameEl = document.getElementById('proj-s2-name');
  if (nameEl) nameEl.value = '';
  const sub = document.getElementById('proj-s2-sub');
  if (sub) sub.textContent = 'Fokuspunkt: ' + lat.toFixed(5) + ', ' + lng.toFixed(5) + ' · Was möchtest du tun?';
  document.getElementById('proj-step2-modal')?.classList.add('show');
  setTimeout(() => document.getElementById('proj-s2-name')?.focus(), 150);
}

function closeProjStep2() {
  document.getElementById('proj-step2-modal')?.classList.remove('show');
  _projCreateTempLL = null;
}

async function saveProjStep2(action) {
  if (action === 'import') {
    document.getElementById('proj-s2-import-inp')?.click();
    return;
  }
  const name = document.getElementById('proj-s2-name')?.value.trim();
  if (!name) { document.getElementById('proj-s2-name')?.focus(); toast('⚠️ Bitte Projektname eingeben'); return; }
  const ll = _projCreateTempLL;
  const proj = {
    id: 'proj_' + Date.now(), name,
    centerLat: ll ? ll.lat  : null,
    centerLng: ll ? ll.lng  : null,
    zoom:      ll ? ll.zoom : 15,
    enabled: true,
    createdAt: new Date().toISOString()
  };
  _projects.push(proj);
  LS.set(LS.K.PROJECTS, _projects);
  closeProjStep2();
  switchProject(proj.id);
  _renderSettingsProjList();
  speak('Neues Projekt erstellt: ' + name + '.', false);
  if (action === 'marker') {
    setTimeout(() => { if (ll) map.setView([ll.lat, ll.lng], ll.zoom || 15); toggleMarkerMode(); }, 400);
  } else if (action === 'gpx') {
    setTimeout(() => document.getElementById('proj-s2-gpx-inp')?.click(), 300);
  }
}

// File-Picker-Handler für Schritt 2
function _onProjS2GpxPick(input) {
  const file = input?.files?.[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = e => loadGpxXml(e.target.result, file.name.replace(/\.gpx$/i,''));
  reader.readAsText(file);
  input.value = '';
}
function _onProjS2ImportPick(input) {
  closeProjStep2(); // Sheet schließen bevor Import-Verarbeitung startet
  importProjectJson(input);
}

// Projekt-Fokus auf aktuelle Kartenposition setzen
function projSetCenterFromMap(id) {
  const proj = _projects.find(p => p.id === id);
  if (!proj || !map) return;
  const c = map.getCenter();
  proj.centerLat = c.lat; proj.centerLng = c.lng; proj.zoom = map.getZoom();
  LS.set(LS.K.PROJECTS, _projects);
  toast('📍 Fokus für "' + proj.name + '" gespeichert');
}

// ── PROJEKT LÖSCHEN ──────────────────────────────────────────────────────────
function deleteProject(id) {
  if (_projects.length <= 1) { toast('⚠️ Mindestens ein Projekt erforderlich'); return; }
  const proj = _projects.find(p => p.id === id);
  if (!proj) return;
  if (!confirm('Projekt "' + proj.name + '" löschen?\n\nStrecken und Marker werden dem ersten verbleibenden Projekt zugewiesen.')) return;
  const remaining  = _projects.filter(p => p.id !== id);
  const fallbackId = remaining[0].id;
  // Tracks re-zuweisen
  let tChanged = false;
  trackStore.tracks.forEach(t => { if (t.projectId === id) { t.projectId = fallbackId; tChanged = true; } });
  if (tChanged) persistTracks();
  // Custom Markers re-zuweisen
  if (Array.isArray(_cmMarkers)) {
    let mChanged = false;
    _cmMarkers.forEach(m => { if (m.projectId === id) { m.projectId = fallbackId; mChanged = true; } });
    if (mChanged) localforage.setItem(LS.K.CUSTOM_MARKERS, _cmMarkers).catch(()=>{});
  }
  _projects = remaining;
  LS.set(LS.K.PROJECTS, _projects);
  if (_activeProjectId === id) switchProject(fallbackId);
  else _renderSettingsProjList();
  speak('Projekt gelöscht: ' + proj.name + '.', true);
}

// ── EINSTELLUNGS-KARTEN-LISTE (Card-Design mit Toggle-Switch) ────────────────
function _renderSettingsProjList() {
  const c = document.getElementById('sp-proj-list');
  if (!c) return;
  c.innerHTML = '';
  if (!_projects.length) {
    c.innerHTML = '<div style="font-size:13px;color:var(--td);padding:6px 0">Keine Projekte vorhanden</div>';
    return;
  }
  _projects.forEach(p => {
    const isFocus   = p.id === _activeProjectId;
    const isEnabled = p.enabled !== false;
    const trkN = trackStore.tracks.filter(t => t.projectId === p.id).length;
    const mkrN = (_cmMarkers||[]).filter(m => m.projectId === p.id).length;
    const statsStr = [
      trkN ? trkN + ' Strecke' + (trkN !== 1 ? 'n' : '') : '',
      mkrN ? mkrN + ' Marker' : ''
    ].filter(Boolean).join(' · ') || 'Leer';

    const card = document.createElement('div');
    card.className = 'proj-card' + (isFocus ? ' is-focus' : '');
    card.innerHTML =
      '<div class="proj-card-header">'
        + '<label class="proj-sw" title="' + (isEnabled ? 'Deaktivieren' : 'Aktivieren') + '" onclick="event.stopPropagation()">'
            + '<input type="checkbox"' + (isEnabled ? ' checked' : '') + ' onchange="toggleProjectEnabled(\'' + p.id + '\',this.checked);_renderSettingsProjList()">'
            + '<span class="proj-sw-track"></span>'
          + '</label>'
        + '<div class="proj-card-info"'
            + (isFocus ? '' : ' role="button" tabindex="0" onclick="setFocusProject(\'' + p.id + '\');fitAll();_renderSettingsProjList()"')
            + ' aria-label="' + escHtml(p.name) + (isFocus ? ' (Fokus)' : '') + '">'
            + '<div class="proj-card-name' + (isFocus ? ' is-focus' : '') + '">'
                + (isFocus ? '⭐ ' : '') + escHtml(p.name)
              + '</div>'
            + '<div class="proj-card-stats">' + escHtml(statsStr)
                + (isFocus ? ' · <span style="color:var(--ac);font-weight:700">Fokus</span>' : '')
              + '</div>'
          + '</div>'
        + '<div class="proj-card-actions">'
            + '<button class="proj-card-act focus-btn' + (isFocus ? ' is-focus' : '') + '" '
                + 'onclick="setFocusProject(\'' + p.id + '\');fitAll();_renderSettingsProjList()" '
                + 'title="' + (isFocus ? 'Ist Fokus-Projekt' : 'Als Fokus setzen') + '" aria-label="Fokus">⭐</button>'
            + '<button class="proj-card-act" onclick="exportProjectJson(\'' + p.id + '\')" title="Exportieren" aria-label="Exportieren">📤</button>'
            + '<button class="proj-card-act del-btn" onclick="deleteProject(\'' + p.id + '\')" title="Löschen" aria-label="Löschen">🗑</button>'
          + '</div>'
      + '</div>';
    c.appendChild(card);
  });
}

function initTheme(){
  const saved=LS.get(LS.K.THEME,'dark');
  if(saved==='light'){
    isDark=false;
    document.documentElement.setAttribute('data-theme','light');
    document.querySelector('meta[name=theme-color]').content='#f0f4f8';
    document.getElementById('ti-moon').style.display='none';
    document.getElementById('ti-sun').style.display='';
  } else {
    document.documentElement.setAttribute('data-theme','dark');
  }
}

// ── GPS ────────────────────────────────────────────────────────
let userMkr=null, userAccCircle=null, gpsWatcher=null, gpsOn=false;
let _gpsAutoFollow = false; // Auto-follow mode (map centers on position)

// Central GPS position handler — called for every GPS update
function _onGpsPos(pos) {
  const {latitude:lat, longitude:lng, accuracy:acc, speed} = pos.coords;
  const fab = document.getElementById('gps-fab');

  // First fix
  if (!gpsOn) {
    gpsOn = true;
    fab.classList.remove('spin');
    fab.style.borderColor = 'var(--log)';
    fab.style.borderWidth = '2px';
    if (_gpsAutoFollow) map.flyTo([lat,lng],17,{animate:true,duration:1});
    toast(`✅ Standort (±${Math.round(acc)}m)`);
    speak(`GPS aktiv. Genauigkeit plus minus ${Math.round(acc)} Meter.`, false);
  }

  // Update user dot + accuracy circle
  const dotHtml = `<div style="position:relative;width:22px;height:22px;display:flex;align-items:center;justify-content:center">
    <div style="position:absolute;width:36px;height:36px;border-radius:50%;background:rgba(56,189,248,.15);border:1px solid rgba(56,189,248,.35);top:50%;left:50%;transform:translate(-50%,-50%)"></div>
    <div style="width:16px;height:16px;border-radius:50%;background:#38bdf8;border:3px solid #fff;box-shadow:0 2px 8px rgba(0,0,0,.5)"></div>
  </div>`;
  const dotIcon = L.divIcon({className:'',html:dotHtml,iconSize:[22,22],iconAnchor:[11,11]});
  if (userMkr) map.removeLayer(userMkr);
  userMkr = L.marker([lat,lng],{icon:dotIcon,zIndexOffset:1000})
    .addTo(map)
    .bindPopup(`<div class="p-top"><div class="p-name">Dein Standort</div><div class="p-crds">${lat.toFixed(5)}, ${lng.toFixed(5)}</div><div class="p-desc">Genauigkeit: ±${Math.round(acc)} m</div></div>`);

  // Accuracy circle (update or create)
  if (userAccCircle) userAccCircle.setLatLng([lat,lng]).setRadius(acc);
  else userAccCircle = L.circle([lat,lng],{radius:acc,color:'#38bdf8',fillColor:'#38bdf8',fillOpacity:.06,weight:1,opacity:.4}).addTo(map);

  // Auto-follow when navigation is active
  if (_gpsAutoFollow) map.setView([lat,lng], map.getZoom(), {animate:true, duration:.5});

  // Hook: Navigation & Race engines
  if (typeof _onNavGpsUpdate === 'function') _onNavGpsUpdate(lat, lng, acc);
  if (typeof _onRaceGpsUpdate === 'function') _onRaceGpsUpdate(lat, lng, acc, speed);
}

function _onGpsErr(err) {
  const fab = document.getElementById('gps-fab');
  fab.classList.remove('spin'); fab.style.borderColor=''; gpsOn=false;
  const msgs = {1:['Zugriff verweigert','Standortzugriff in Einstellungen erlauben.'],2:['Kein Signal','Ins Freie gehen oder WLAN aktivieren.'],3:['Zeitüberschreitung','GPS erneut versuchen.']};
  const [t,m] = msgs[err.code] || ['GPS Fehler',err.message];
  showGpsHint(t, m);
  speak(`GPS Fehler: ${t}. ${m}`, true);
}

async function locateUser(){
  const fab=document.getElementById('gps-fab');
  if(!('geolocation'in navigator)){showGpsHint('GPS nicht verfügbar','Dein Browser unterstützt keine Geolocation-API.');return}
  if(navigator.permissions){
    try{const p=await navigator.permissions.query({name:'geolocation'});if(p.state==='denied'){showGpsHint('Zugriff verweigert','Erlaube den Standort in den Browser-/App-Einstellungen.');return}}catch(e){}
  }
  if(gpsOn){
    if(gpsWatcher!==null){navigator.geolocation.clearWatch(gpsWatcher);gpsWatcher=null}
    if(userMkr){map.removeLayer(userMkr);userMkr=null}
    if(userAccCircle){map.removeLayer(userAccCircle);userAccCircle=null}
    gpsOn=false; _gpsAutoFollow=false; fab.classList.remove('spin'); fab.style.borderColor='';
    toast('📍 GPS deaktiviert');
    speak('GPS deaktiviert.', false);
    return;
  }
  _gpsAutoFollow = true;
  fab.classList.add('spin'); toast('📡 GPS wird aktiviert…');
  gpsWatcher = navigator.geolocation.watchPosition(_onGpsPos, _onGpsErr,
    {enableHighAccuracy:true, timeout:20000, maximumAge:3000});
}

// Ensure GPS is running (called by nav/race engine without user tap)
function ensureGpsActive() {
  return new Promise((resolve, reject) => {
    if (!('geolocation' in navigator)) { reject(new Error('Kein GPS')); return; }
    if (gpsOn) { resolve(); return; }
    const fab = document.getElementById('gps-fab');
    fab.classList.add('spin');
    gpsWatcher = navigator.geolocation.watchPosition(
      pos => { _onGpsPos(pos); resolve(); },
      err  => { _onGpsErr(err); reject(err); },
      {enableHighAccuracy:true, timeout:20000, maximumAge:3000}
    );
  });
}
function showGpsHint(t,m){document.getElementById('gpshint-t').textContent=t;document.getElementById('gpshint-m').textContent=m;document.getElementById('gpshint').classList.add('show');setTimeout(hideGpsHint,8000);}
function hideGpsHint(){document.getElementById('gpshint').classList.remove('show')}

// ── TOAST ──────────────────────────────────────────────────────
let toastT;
function toast(msg){
  const t=document.getElementById('toast');
  t.textContent=msg;
  t.classList.add('show');
  clearTimeout(toastT);
  toastT=setTimeout(()=>t.classList.remove('show'),2700);
  _ariaAnnounce(msg,'polite');
  speak(msg, false); // TTS (nur wenn aktiviert)
}

// ══════════════════════════════════════════════════════════════
// ── ACCESSIBILITY ENGINE (A11Y) ────────────────────────────────
// Barrierefreiheit: TTS (Web Speech API), ARIA-Live-Regionen,
// Tastaturnavigation, High-Contrast, Kartenvorlesung
// ──────────────────────────────────────────────────────────────

// Globaler A11Y-State (geladen aus localStorage via LS.K.A11Y)
let _a11y = {
  enabled:    false,  // TTS aktiv
  rate:       1.0,    // Sprechrate 0.5–2.0
  hc:         false,  // High-Contrast-Modus
  autoAnnounce: true, // Toast / Tab-Wechsel automatisch vorlesen
};

// App-Sprache für TTS und UI: 'de' | 'en' | 'fr' | 'es'
let _appLang = 'de';

/** Persistiert aktuelle A11Y-Einstellungen in localStorage */
function _saveA11ySettings() {
  LS.set(LS.K.A11Y, _a11y);
  // High-Contrast auf <html> data-Attribut setzen
  if (_a11y.hc) document.documentElement.setAttribute('data-a11y-hc','');
  else           document.documentElement.removeAttribute('data-a11y-hc');
}

/** Lädt A11Y-Einstellungen und App-Sprache beim App-Start */
function _loadA11ySettings() {
  const saved = LS.get(LS.K.A11Y, null);
  if (saved && typeof saved === 'object') {
    _a11y = { ..._a11y, ...saved };
  }
  // Sprache aus Profil laden
  const prof = LS.get(LS.K.PROFILE, null);
  if (prof && prof.lang && ['de','en','fr','es'].includes(prof.lang)) {
    _appLang = prof.lang;
  }
  // High-Contrast immer anwenden (auch ohne TTS)
  if (_a11y.hc) document.documentElement.setAttribute('data-a11y-hc','');
  // TTS-Bar sichtbar wenn TTS aktiv
  if (_a11y.enabled) document.documentElement.setAttribute('data-a11y-on','');
  // Keyboard-Shortcuts immer initialisieren
  _initKeyboardShortcuts();
  // TTS-Stimmen vorladen (vermeidet Stille beim ersten speak()-Aufruf)
  _ttsLoadVoices();
}

// ── Text-to-Speech (TTS) ────────────────────────────────────────
let _ttsQueue    = [];
let _ttsSpeaking = false;
let _ttsVoices   = [];          // Gecachte Stimmen (laden ist async in Chrome)
let _ttsKeepalive = null;       // Chrome 15s-Timeout-Fix: periodisches resume()
let _ttsLastText  = '';         // Letzter gesprochener Text (für Wiederholen-Funktion)

/** Lädt verfügbare TTS-Stimmen; registriert einmalig onvoiceschanged-Callback */
function _ttsLoadVoices() {
  if (!window.speechSynthesis) return;
  _ttsVoices = speechSynthesis.getVoices();
  if (!_ttsVoices.length) {
    speechSynthesis.onvoiceschanged = () => {
      _ttsVoices = speechSynthesis.getVoices();
      speechSynthesis.onvoiceschanged = null; // Einmalig — verhindert Überschreiben
    };
  }
}
_ttsLoadVoices(); // Sofort ausführen (falls Stimmen bereits geladen)

/** Bereinigt Text für TTS: entfernt Emojis und HTML-Tags */
function _cleanForSpeech(txt) {
  if (!txt) return '';
  return txt
    .replace(/<[^>]*>/g,'')               // HTML-Tags
    .replace(/[\u{1F300}-\u{1FFFF}]/gu,'') // Emojis (Unicode-Bereiche)
    .replace(/[✅❌⚠⏳📍📦📲🔒💾📊📂⬇⬆←→↗🗑✓·↩]/g,' ')
    .replace(/\s+/g,' ')
    .trim();
}

/**
 * Spricht Text per TTS (Web Speech API), nur wenn A11Y aktiviert.
 * @param {string} text  Zu sprechender Text
 * @param {boolean} [interrupt=false]  Aktuell laufende Sprachausgabe unterbrechen
 */
function speak(text, interrupt = false) {
  if (!_a11y.enabled) return;
  if (!window.speechSynthesis) return;
  const clean = _cleanForSpeech(text);
  if (!clean) return;
  if (interrupt) {
    // Cancel current speech, replace queue, then wait 80 ms for Chrome to
    // fully process the cancel before starting the new utterance.
    speechSynthesis.cancel();
    _ttsQueue    = [clean];
    _ttsSpeaking = false;
    clearInterval(_ttsKeepalive); _ttsKeepalive = null;
    setTimeout(_ttsFlush, 80);
    return;
  }
  _ttsQueue.push(clean);
  if (!_ttsSpeaking) _ttsFlush();
}

function _ttsFlush() {
  // Guard: prevent re-entry while already speaking
  if (_ttsSpeaking) return;
  if (_ttsQueue.length === 0) {
    _ttsSpeaking = false; // ensure clean state
    clearInterval(_ttsKeepalive); _ttsKeepalive = null;
    _updateTtsBar('Bereit');
    return;
  }
  _ttsSpeaking = true;
  _updateTtsBar('Liest vor…');
  // Chrome 15s-Timeout-Workaround: speechSynthesis jede 10s aufwecken
  if (!_ttsKeepalive) {
    _ttsKeepalive = setInterval(() => {
      if (!window.speechSynthesis) return;
      if (speechSynthesis.paused) speechSynthesis.resume();
    }, 10000);
  }
  const _nextText = _ttsQueue.shift();
  _ttsLastText = _nextText;
  const utt = new SpeechSynthesisUtterance(_nextText);
  // Sprache aus App-Einstellung
  const _langMap = { de:'de-DE', en:'en-GB', fr:'fr-FR', es:'es-ES' };
  utt.lang  = _langMap[_appLang] || 'de-DE';
  utt.rate  = _a11y.rate;
  utt.pitch = 1.0;
  // Release lock BEFORE scheduling next call so speak() can enqueue during gap
  utt.onend = () => {
    _ttsPaused   = false;
    _ttsSpeaking = false;
    setTimeout(_ttsFlush, 50);
  };
  utt.onerror = (e) => {
    _ttsSpeaking = false;
    if (e.error === 'canceled') {
      // Intentional cancel — caller (speak/ttsSkipForward) owns the next call
      return;
    }
    console.warn('[TTS] error:', e.error);
    clearInterval(_ttsKeepalive); _ttsKeepalive = null;
    _updateTtsBar('Fehler');
    setTimeout(_ttsFlush, 100); // retry on real errors
  };
  // Passende Stimme bevorzugen
  const langPrefix = (utt.lang||'de').split('-')[0];
  const voice = _ttsVoices.find(v => v.lang.startsWith(langPrefix));
  if (voice) utt.voice = voice;
  window.speechSynthesis.speak(utt);
}

/** Stoppt laufende TTS sofort */
function speakStop() {
  if (window.speechSynthesis) window.speechSynthesis.cancel();
  _ttsQueue    = [];
  _ttsSpeaking = false;
  _ttsPaused   = false;
  clearInterval(_ttsKeepalive); _ttsKeepalive = null;
  _updateTtsBar('Gestoppt');
  setTimeout(() => _updateTtsBar('Bereit'), 1500);
}

/** Liest Popup-Inhalt eines LOCS-Markers vor */
function speakPopupContent(name, desc, cat) {
  if (!_a11y.enabled) {
    toast('🔊 Vorlesefunktion in Einstellungen aktivieren');
    return;
  }
  const parts = [cat, name, desc].filter(s => s && s.trim());
  speak(parts.join('. '), true);
}

/** Liest Track-Popup vor (Start oder Ziel) */
function speakTrackPopup(trackId, isFinish) {
  const track = trackStore.tracks.find(t => t.id === trackId);
  if (!track) return;
  const lbl  = isFinish ? 'Ziel' : 'Start';
  const cat  = { beginner:'Anfänger', mittel:'Mittel', expert:'Expert' }[track.cat] || track.cat;
  const dist = track.stats?.dist ? `${track.stats.dist} Kilometer` : '';
  const dur  = track.stats?.dur  ? `Dauer: ${track.stats.dur}`      : '';
  const parts = [cat, track.name, lbl, dist, dur].filter(Boolean);
  speak(parts.join('. '), true);
}

/** Überspringt die aktuelle Sprachausgabe und geht zur nächsten */
function ttsSkipForward() {
  if (!window.speechSynthesis) return;
  if (speechSynthesis.speaking || speechSynthesis.paused) {
    _ttsSpeaking = false;
    _ttsPaused   = false;
    speechSynthesis.cancel();
    // Wait for Chrome to process cancel before starting next item
    setTimeout(_ttsFlush, 80);
  } else if (_ttsQueue.length > 0) {
    _ttsFlush();
  } else {
    speakCurrentContext();
  }
}

/** Wiederholt den zuletzt gesprochenen Text */
function ttsRepeat() {
  if (_ttsLastText) {
    speak(_ttsLastText, true);
  } else {
    speakCurrentContext();
  }
}

/** Aktualisiert die Sprach-Buttons im Profil-Tab */
function _applyLangButtons() {
  document.querySelectorAll('.lang-btn').forEach(b => {
    b.classList.toggle('active', b.dataset.lang === _appLang);
  });
}

/** Setzt die App-Sprache und speichert sie im Profil */
function setAppLang(lang) {
  if (!['de','en','fr','es'].includes(lang)) return;
  _appLang = lang;
  // In Profil speichern
  const prof = LS.get(LS.K.PROFILE, {});
  prof.lang = lang;
  LS.set(LS.K.PROFILE, prof);
  // UI-Buttons aktualisieren
  document.querySelectorAll('.lang-btn').forEach(b => {
    b.classList.toggle('active', b.dataset.lang === lang);
  });
  const names = { de:'Deutsch', en:'English', fr:'Français', es:'Español' };
  toast('🌐 Sprache: ' + (names[lang] || lang));
  speak('Sprache geändert.', true);
}

// ── ARIA Live-Regionen ──────────────────────────────────────────
let _ariaPoliteTimer = null;
/**
 * Aktualisiert ARIA Live-Region für Screen Reader.
 * @param {string} msg   Nachricht
 * @param {'polite'|'assertive'} [priority='polite']
 */
function _ariaAnnounce(msg, priority = 'polite') {
  const id = priority === 'assertive' ? 'a11y-live-assertive' : 'a11y-live-polite';
  const el = document.getElementById(id);
  if (!el) return;
  // Kurz leeren damit Screen Reader auch gleiche Nachricht erneut ankündigt
  el.textContent = '';
  clearTimeout(_ariaPoliteTimer);
  _ariaPoliteTimer = setTimeout(() => { el.textContent = _cleanForSpeech(msg); }, 80);
}

// ── Kartenüberblick vorlesen ────────────────────────────────────
/** Liest den sichtbaren Karteninhalt vor: Tracks, Marker, Zoom */
function speakMapOverview() {
  if (!map) { speak('Karte noch nicht geladen.', true); return; }
  const zoom  = map.getZoom();
  const ctr   = map.getCenter();
  const parts = [];
  parts.push(`Karte, Zoom-Stufe ${zoom}.`);

  // Sichtbare Strecken
  const visTracks = trackStore.tracks.filter(t => t.gpxLayer && map.hasLayer(t.gpxLayer));
  if (visTracks.length === 0) {
    parts.push('Keine Strecken geladen.');
  } else {
    parts.push(`${visTracks.length} Strecke${visTracks.length>1?'n':''} sichtbar: ${visTracks.map(t=>t.name).join(', ')}.`);
  }

  // Eigene Marker
  const cmCount = Object.keys(_cmLeafletLayers || {}).length;
  if (cmCount > 0) parts.push(`${cmCount} eigene Marker auf der Karte.`);

  // GPS Position
  if (window._gpsMarker && window._gpsMarker.getLatLng) {
    const gpos = window._gpsMarker.getLatLng();
    const dist = ctr.distanceTo(gpos);
    parts.push(`GPS-Position ${Math.round(dist)} Meter vom Kartenmittelpunkt entfernt.`);
  } else {
    parts.push('GPS nicht aktiv.');
  }

  speak(parts.join(' '), true);
  _ariaAnnounce(parts.join(' '));
}

/** Sucht den nächsten Streckenpunkt oder Marker und liest ihn vor */
function speakNearestPoint() {
  if (!map) return;
  const ctr = map.getCenter();
  let best = null, bestD = Infinity;

  // Streckenpunkte (Start/Ziel)
  trackStore.tracks.forEach(t => {
    if (!t.gpxLayer || !map.hasLayer(t.gpxLayer)) return;
    if (t._startMkr) {
      const d = ctr.distanceTo(t._startMkr.getLatLng());
      if (d < bestD) { bestD = d; best = { type:'Start', name: t.name, d }; }
    }
    if (t._finishMkr) {
      const d = ctr.distanceTo(t._finishMkr.getLatLng());
      if (d < bestD) { bestD = d; best = { type:'Ziel', name: t.name, d }; }
    }
  });

  // Eigene Marker
  (_cmCache || []).forEach(cm => {
    const d = ctr.distanceTo(L.latLng(cm.lat, cm.lng));
    if (d < bestD) { bestD = d; best = { type:'Marker', name: cm.name, d }; }
  });

  // LOCS-Marker
  (window.LOCS || []).forEach(loc => {
    if (!MKR[loc.id]) return;
    const d = ctr.distanceTo(MKR[loc.id].m.getLatLng());
    if (d < bestD) { bestD = d; best = { type: loc.cat||'Punkt', name: loc.name, d }; }
  });

  let msg;
  if (!best) {
    msg = 'Kein Punkt in der Nähe gefunden.';
  } else {
    const dm = Math.round(best.d);
    const unit = dm >= 1000 ? `${(dm/1000).toFixed(1)} Kilometer` : `${dm} Meter`;
    msg = `Nächster Punkt: ${best.type} "${best.name}", ${unit} entfernt.`;
  }
  speak(msg, true);
  _ariaAnnounce(msg);
  toast('📢 ' + msg);
}

// ── Tastaturnavigation ──────────────────────────────────────────
function _initKeyboardShortcuts() {
  document.removeEventListener('keydown', _handleA11yKey);
  document.addEventListener('keydown', _handleA11yKey);
}

function _handleA11yKey(e) {
  // Kein Shortcut wenn ein Input-Feld oder Textarea fokussiert ist
  const tag = document.activeElement ? document.activeElement.tagName : '';
  if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;
  if (document.activeElement && document.activeElement.isContentEditable) return;

  switch(e.key) {
    case 'v': case 'V':
      e.preventDefault();
      speakMapOverview();
      break;
    case 'n': case 'N':
      e.preventDefault();
      speakNearestPoint();
      break;
    case 's': case 'S':
      // Nur wenn Settings nicht schon offen
      if (!document.getElementById('settings-panel').classList.contains('open')) {
        e.preventDefault();
        openSettings();
      }
      break;
    case 'g': case 'G':
      e.preventDefault();
      if (typeof startGps === 'function') startGps();
      break;
    case 'Escape':
      // Schließt offene Overlays in Priorität
      if (document.getElementById('settings-panel').classList.contains('open')) {
        e.preventDefault(); closeSettings(); return;
      }
      if (document.getElementById('qrm') && document.getElementById('qrm').classList.contains('show')) {
        e.preventDefault(); closeQrModal(); return;
      }
      break;
  }
}

// A11Y-Einstellungen im Settings-Panel aktualisieren (UI ↔ State)
function _applyA11yUi() {
  const rng    = document.getElementById('a11y-rate');
  const hcc    = document.getElementById('a11y-hc');
  const rngVal = document.getElementById('a11y-rate-val');
  if (rng)    rng.value   = _a11y.rate;
  if (hcc)    hcc.checked = _a11y.hc;
  if (rngVal) rngVal.textContent = _a11y.rate.toFixed(1) + '×';
  // Big toggle button state
  const btn  = document.getElementById('a11y-big-toggle');
  const lbl  = document.getElementById('a11y-toggle-state');
  const stts = document.getElementById('sheet-tts-btn');
  if (btn)  btn.classList.toggle('on', _a11y.enabled);
  if (lbl)  lbl.textContent = _a11y.enabled ? 'EIN — aktiv' : 'AUS';
  if (stts) stts.classList.toggle('active', _a11y.enabled);
  // data-a11y-on steuert Sichtbarkeit von TTS Control Bar + Speak-FAB
  if (_a11y.enabled) document.documentElement.setAttribute('data-a11y-on','');
  else               document.documentElement.removeAttribute('data-a11y-on');
  _updateTtsBar();
}

function onA11yToggle(val) {
  _a11y.enabled = !!val;
  _saveA11ySettings();
  const stts = document.getElementById('sheet-tts-btn');
  if (_a11y.enabled) {
    document.documentElement.setAttribute('data-a11y-on','');
    const btn = document.getElementById('a11y-big-toggle');
    const lbl = document.getElementById('a11y-toggle-state');
    if (btn)  btn.classList.add('on');
    if (lbl)  lbl.textContent = 'EIN — aktiv';
    if (stts) stts.classList.add('active');
    _updateTtsBar('Bereit');
    speak('Vorlesefunktion aktiviert.', true);
  } else {
    document.documentElement.removeAttribute('data-a11y-on');
    const btn = document.getElementById('a11y-big-toggle');
    const lbl = document.getElementById('a11y-toggle-state');
    if (btn)  btn.classList.remove('on');
    if (lbl)  lbl.textContent = 'AUS';
    if (stts) stts.classList.remove('active');
    speakStop();
  }
}

/** Aktualisiert die TTS-Control-Bar (Status + Pause-Icon) */
function _updateTtsBar(status) {
  const txt  = document.getElementById('tts-status-txt');
  const pBtn = document.getElementById('tts-pause-btn');
  if (txt && status !== undefined) txt.textContent = status;
  if (pBtn) pBtn.textContent = (window.speechSynthesis && speechSynthesis.paused) ? '▶️' : '⏸';
}

let _ttsPaused = false;
/** Pausiert oder setzt TTS fort */
function ttsTogglePause() {
  if (!window.speechSynthesis) return;
  if (speechSynthesis.paused) {
    speechSynthesis.resume();
    _ttsPaused = false;
    _updateTtsBar('Liest vor…');
  } else if (speechSynthesis.speaking) {
    speechSynthesis.pause();
    _ttsPaused = true;
    _updateTtsBar('Pause');
  } else {
    speakCurrentContext();
  }
  const pBtn = document.getElementById('tts-pause-btn');
  if (pBtn) pBtn.textContent = _ttsPaused ? '▶️' : '⏸';
}
function onA11yRate(val) {
  _a11y.rate = parseFloat(val) || 1.0;
  _saveA11ySettings();
  speak('Sprechrate ' + _a11y.rate.toFixed(1), false);
}
function onA11yHc(val) {
  _a11y.hc = !!val;
  _saveA11ySettings();
  toast(_a11y.hc ? '🔆 Hoher Kontrast aktiviert' : '🔅 Hoher Kontrast deaktiviert');
}

// ── Kontextbewusstes Vorlesen (Speaker-FAB + Shortcut V) ────────
function speakCurrentContext() {
  // 1. Settings-Panel offen?
  const sp = document.getElementById('settings-panel');
  if (sp && sp.classList.contains('open')) {
    const active = document.querySelector('.sp-tab.active');
    const tabName = active ? active.dataset.t : 'general';
    _speakSettingsTab(tabName);
    return;
  }
  // 2. Race-Overlay offen?
  const ro = document.getElementById('race-overlay');
  if (ro && ro.classList.contains('show')) {
    const timerEl = document.getElementById('race-timer-display') || document.getElementById('r-time');
    const posEl   = document.getElementById('r-pos');
    const timer   = timerEl ? timerEl.textContent : '?';
    const pos     = posEl   ? posEl.textContent   : '';
    speak(`Rennen läuft. Zeit: ${timer}. ${pos}`, true);
    return;
  }
  // 3. GPX-Sheet (Aufnahme/Strecken) offen?
  const gs = document.getElementById('gpx-sheet');
  if (gs && (gs.style.transform === 'translateY(0px)' || gs.classList.contains('open'))) {
    const activeTab = document.querySelector('.gpx-tab.active');
    const tabLbl = activeTab ? activeTab.textContent.trim() : 'GPX';
    speak(`GPX-Panel offen: ${tabLbl}.`, true);
    return;
  }
  // 4. QR-Modal offen?
  const qrm = document.getElementById('qrm');
  if (qrm && qrm.classList.contains('show')) {
    const nm = document.getElementById('qrm-name');
    speak(nm ? `QR-Code: ${nm.textContent}` : 'QR-Code anzeigen.', true);
    return;
  }
  // 5. Standard: Karte vorlesen
  speakMapOverview();
}

function _speakSettingsTab(tabName) {
  const labels = {
    general:  'Allgemein — GPS-Emoji, Home-Position, Barrierefreiheit, Einstellungen speichern.',
    tracks:   'Strecken — geladene GPX-Strecken verwalten, teilen und löschen.',
    backup:   'Backup — Alle Daten exportieren oder importieren.',
    markers:  'Marker — eigene Punkte und Kartenmarker bearbeiten.',
    qr:       'QR-Scanner — QR-Codes scannen für Strecken und Marker.',
    app:      'App-Installation — App als PWA installieren und Offline-Cache verwalten.',
    profile:  'Fahrerprofil — Name, Muni-Daten und persönliche Angaben.',
  };
  const tracks = trackStore.tracks.map(t=>t.name).join(', ') || 'Keine Strecken geladen';
  const extra = tabName === 'tracks' ? ` Geladen: ${tracks}` : '';
  speak((labels[tabName] || tabName) + extra, true);
}

// ── AUTO-DOWNLOAD: GMTW 2026 TRACKS ───────────────────────────
// Offizielle Quelle: Munimap GitHub Repository (RAW-Links)
const REPO_RAW_BASE = 'https://raw.githubusercontent.com/Munimap/munimap.github.io/main/gpx/';
const REPO_API_URL  = 'https://api.github.com/repos/Munimap/munimap.github.io/contents/gpx';

const AUTO_TRACKS = [
  { name:'GMTW 2026 Beginner',              cat:'beginner', file:'GMTW2026_Beginner.gpx' },
  { name:'GMTW 2026 Beginner/Mittel',       cat:'mittel',   file:'GMTW2026_Beginner_Intermediate.gpx' },
  { name:'GMTW 2026 Expert 1',              cat:'expert',   file:'GMTW2026_Expert_1.gpx' },
  { name:'GMTW 2026 Expert 2',              cat:'expert',   file:'GMTW2026_Expert_2.gpx' },
  { name:'GMTW 2026 Expert 3',              cat:'expert',   file:'GMTW2026_Expert_3.gpx' },
  { name:'GMTW 2026 Mittel',                cat:'mittel',   file:'GMTW2026_Intermediate.gpx' },
].map(t => ({ ...t, url: REPO_RAW_BASE + t.file }));

async function autoDownloadTracks() {
  let downloaded = 0;
  for (const def of AUTO_TRACKS) {
    const alreadyLoaded = trackStore.tracks.some(
      t => t.sourceUrl === def.url || t.name === def.name
    );
    if (alreadyLoaded) continue;
    try {
      const resp = await fetch(def.url);
      if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
      const txt = await resp.text();
      const gpxStr = sanitizeGpx(txt);
      if (!gpxStr.startsWith('<')) throw new Error('Kein gültiges GPX');
      loadGpxXml(gpxStr, def.name, def.cat, null, def.url, true);
      downloaded++;
    } catch(e) {
      console.info(`Auto-Download übersprungen (${def.name}):`, e.message);
    }
  }
  if (downloaded > 0) toast(`⬇ ${downloaded} Strecke${downloaded!==1?'n':''} geladen`);
}

// ── STRECKEN-UPDATE CHECK: Prüft GitHub auf neue GPX-Files ─────
// Fragt die GitHub API nach allen .gpx Dateien im Repository
// und vergleicht mit bereits geladenen Tracks → Nutzer bestätigt Import
async function checkForTrackUpdates() {
  const btn = document.getElementById('sp-update-btn');
  if (btn) { btn.disabled = true; btn.textContent = '⏳ Prüfe…'; }

  try {
    const resp = await fetch(REPO_API_URL, {
      headers: { 'Accept': 'application/vnd.github.v3+json' }
    });
    if (!resp.ok) throw new Error(`GitHub API: HTTP ${resp.status}`);

    const files = await resp.json();
    const gpxFiles = files.filter(f => f.name.toLowerCase().endsWith('.gpx'));

    // Welche sind noch nicht geladen?
    const newTracks = gpxFiles.filter(f => {
      const rawUrl = REPO_RAW_BASE + f.name;
      return !trackStore.tracks.some(t => t.sourceUrl === rawUrl || t.name === f.name.replace('.gpx',''));
    });

    if (btn) { btn.disabled = false; btn.textContent = '🔄 Nach Updates suchen'; }

    if (newTracks.length === 0) {
      toast('✅ Alle Strecken sind bereits geladen!');
      updateTrackUpdateUI(0);
      return;
    }

    // Nutzer fragen ob importiert werden soll
    updateTrackUpdateUI(newTracks.length, newTracks);

  } catch(e) {
    if (btn) { btn.disabled = false; btn.textContent = '🔄 Nach Updates suchen'; }
    toast('❌ Update-Prüfung fehlgeschlagen: ' + e.message);
    const el = document.getElementById('sp-update-result');
    if (el) el.innerHTML = `<div style="color:var(--tm);font-size:12px">Offline oder GitHub nicht erreichbar.<br>${escHtml(e.message)}</div>`;
  }
}

function updateTrackUpdateUI(count, newTracks) {
  const el = document.getElementById('sp-update-result');
  if (!el) return;
  if (count === 0) {
    el.innerHTML = '<div style="color:var(--ac);font-size:12px">✅ Alle Strecken sind aktuell.</div>';
    return;
  }
  const list = newTracks.map(f => `<div style="display:flex;align-items:center;gap:8px;padding:5px 0;border-bottom:1px solid var(--bd2);font-size:12px">
    <span style="font-size:16px">📄</span>
    <span style="flex:1;color:var(--tx)">${escHtml(f.name)}</span>
  </div>`).join('');

  el.innerHTML = `
    <div style="font-size:12px;color:var(--td);margin-bottom:8px">${count} neue Strecke${count>1?'n':''} gefunden:</div>
    <div style="background:var(--s3);border-radius:8px;padding:8px;margin-bottom:10px;max-height:160px;overflow-y:auto">${list}</div>
    <button class="sp-btn prim" onclick="importNewTracks(${JSON.stringify(newTracks.map(f=>f.name))})" style="width:100%;justify-content:center">
      ⬇ ${count} Strecke${count>1?'n':''} importieren
    </button>`;
}

async function importNewTracks(fileNames) {
  const btn = event?.target;
  if (btn) { btn.disabled = true; btn.textContent = '⏳ Importiere…'; }
  let ok = 0, fail = 0;
  for (const fname of fileNames) {
    const url = REPO_RAW_BASE + fname;
    const namePretty = fname.replace('.gpx','').replace(/_/g,' ');
    const cat = fname.toLowerCase().includes('expert') ? 'expert'
              : fname.toLowerCase().includes('beginner') ? 'beginner' : 'mittel';
    try {
      const resp = await fetch(url);
      if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
      const txt = await resp.text();
      const gpxStr = sanitizeGpx(txt);
      if (!gpxStr.startsWith('<')) throw new Error('Kein GPX');
      loadGpxXml(gpxStr, namePretty, cat, null, url, true);
      ok++;
    } catch(e) {
      console.warn('Import fehlgeschlagen:', fname, e.message);
      fail++;
    }
  }
  if (btn) { btn.disabled = false; btn.textContent = '✅ Importiert'; }
  toast(`✅ ${ok} importiert${fail ? ` · ❌ ${fail} fehlgeschlagen` : ''}`);
  const el = document.getElementById('sp-update-result');
  if (el) el.innerHTML = `<div style="color:var(--ac);font-size:12px">✅ ${ok} Strecken importiert!</div>`;
}

// ── DEEP LINK ──────────────────────────────────────────────────
window.addEventListener('load', async ()=>{
  initTheme();
  // Projekte initialisieren (vor Track-Restore, damit projectId-Migration möglich)
  _initProjects();
  const params=new URLSearchParams(window.location.search);
  const locId=params.get('loc');
  if(locId&&MKR[locId]) setTimeout(()=>focusMarker(locId),700);
  // ?gpx=URL Parameter: Track direkt laden
  const gpxUrl=params.get('gpx');
  if(gpxUrl){
    const cat=params.get('cat')||'mittel';
    const name=decodeURIComponent(params.get('name')||gpxUrl.split('/').pop().replace('.gpx','')||'Track');
    toast('⏳ Lade GPX aus URL…');
    setTimeout(()=>createGpxLayer(useProxy?`https://corsproxy.io/?${encodeURIComponent(gpxUrl)}`:gpxUrl, cat, name),900);
  }
  // Gespeicherte Daten wiederherstellen (await: Auto-Download erst danach prüfen)
  restoreRecorder();
  await restoreTracks();
  // Migration: bestehende Tracks dem Standard-Projekt zuweisen
  _migrateToProjects();
  // Fehlende Official-Tracks im Hintergrund laden (silent, offline-safe)
  autoDownloadTracks();
  // Run-Cache für sync renderTrackList befüllen
  _initRunCache();
  // Eigene Custom-Marker laden und rendern
  _loadAndRenderCustomMarkers();
  // A11Y-Einstellungen laden (High-Contrast, TTS-State, Keyboard-Shortcuts)
  _loadA11ySettings();
  _applyA11yUi(); // TTS-Bar + data-a11y-on bei jedem Reload wiederherstellen
  // iOS PWA-Hinweis prüfen
  _checkIosInstall();
});

// ── GPX SYSTEM ─────────────────────────────────────────────────
// ═══════════════════════════════════════════════════════════════
// ROOT CAUSE: leaflet-gpx nutzt XHR für URLs → auf iOS/Android
// liefern blob: URLs status=0 → 'loaded' Event feuert NIE.
//
// FIX: GPX-XML-String direkt an new L.GPX(string) übergeben.
// leaflet-gpx prüft: if(input.substr(0,1)==='<') → DOMParser.
// DOMParser hat KEINEN status-Check → 100% zuverlässig.
// ═══════════════════════════════════════════════════════════════

let useProxy = false;
function useCorsProxy() { useProxy=!useProxy; toast(useProxy?'🔀 CORS-Proxy aktiv':'🔀 Direktverbindung'); }

const trackStore = { tracks:[], _id:1 };
let gpxFilter = 'all';
let _cachedRuns = {}; // Sync-safe run cache — refreshed by _initRunCache() and after each save
let _activeDetailId = null; // Track ID whose detail panel is currently open

// GPX-String bereinigen: BOM, Whitespace, XML-Startpunkt finden
function sanitizeGpx(str) {
  if (!str) return '';
  // BOM entfernen (UTF-8: 0xFEFF, manchmal als 3-Byte-Sequenz)
  if (str.charCodeAt(0) === 0xFEFF) str = str.slice(1);
  str = str.trim();

  // HTML-Dokumente sofort abweisen — z.B. GitHub /blob/ Seiten
  const low = str.substring(0, 120).toLowerCase();
  if (low.startsWith('<!doctype html') || low.startsWith('<html') ||
      low.includes('<html ') || low.includes('<html>')) {
    return '';
  }

  // XML-Startpunkt finden wenn nötig
  if (!str.startsWith('<')) {
    const xmlIdx = str.indexOf('<?xml');
    const gpxIdx = str.indexOf('<gpx');
    const start = Math.min(
      xmlIdx >= 0 ? xmlIdx : Infinity,
      gpxIdx >= 0 ? gpxIdx : Infinity
    );
    if (isFinite(start)) str = str.slice(start);
    else return ''; // kein XML-Startpunkt gefunden
  }

  // Nochmal prüfen ob es GPX-Inhalte gibt
  if (!str.includes('<trk') && !str.includes('<rte') && !str.includes('<wpt') && !str.includes('<gpx')) {
    return '';
  }

  return str;
}

function openGpxPanel(tab='load') {
  closeAll();
  document.getElementById('gpx-panel').classList.add('open');
  document.getElementById('backdrop').classList.add('show');
  switchGpxTab(tab, document.querySelector(`.gpx-tab[data-tab="${tab}"]`));
  map.invalidateSize();
}
function closeGpxPanel() {
  document.getElementById('gpx-panel').classList.remove('open');
  document.getElementById('backdrop').classList.remove('show');
  map.invalidateSize();
}
function switchGpxTab(tab, btn) {
  document.querySelectorAll('.gpx-tab').forEach(t => t.classList.remove('on'));
  document.querySelectorAll('.gpx-content').forEach(c => c.classList.remove('on'));
  if (btn) btn.classList.add('on');
  else { const b = document.querySelector(`.gpx-tab[data-tab="${tab}"]`); if(b) b.classList.add('on'); }
  const el = document.getElementById(`gpx-tab-${tab}`);
  if (el) { el.classList.add('on'); if(tab==='tracks') renderTrackList(); }
}

// ── DATEI-UPLOAD ───────────────────────────────────────────────
function handleGpxFiles(input) {
  const files = Array.from(input.files);
  if (!files.length) return;
  const cat = document.getElementById('gpx-cat').value;
  let pending = files.length;
  // input.value erst nach ALLEN Lesevorgängen zurücksetzen
  const done = () => { if (--pending <= 0) input.value = ''; };

  files.forEach(file => {
    if (trackStore.tracks.length >= 50) { toast('⚠️ Max. 50 Tracks'); done(); return; }

    const reader = new FileReader();

    reader.onload = function(ev) {
      try {
        const gpxStr = sanitizeGpx(ev.target.result);

        if (!gpxStr.startsWith('<')) {
          toast('❌ ' + escHtml(file.name) + ': Kein XML-Inhalt'); done(); return;
        }
        if (!gpxStr.includes('trk') && !gpxStr.includes('rte') && !gpxStr.includes('wpt')) {
          toast('❌ ' + escHtml(file.name) + ': Keine Track-Daten'); done(); return;
        }

        const name = file.name.replace(/\.gpx$/i, '').replace(/[_-]+/g, ' ').trim() || 'Track';
        // DIREKT als XML-String laden — kein Blob, kein XHR!
        loadGpxXml(gpxStr, name, cat);
      } catch(err) {
        toast('❌ Fehler beim Lesen: ' + escHtml(file.name));
        console.error('GPX file read error:', err);
      }
      done();
    };

    reader.onerror = () => { toast('❌ Datei nicht lesbar: ' + escHtml(file.name)); done(); };
    reader.readAsText(file, 'UTF-8');
  });
}

// ── URL-LADEN ─────────────────────────────────────────────────
async function loadGpxFromUrl() {
  const inp = document.getElementById('gpx-url-inp');
  let url = inp.value.trim();
  if (!url) { toast('⚠️ URL eingeben'); return; }
  if (trackStore.tracks.length >= 50) { toast('⚠️ Max. 50 Tracks'); return; }

  // ── AUTO-KORREKTUREN ──────────────────────────────────────
  // GitHub: /blob/-URL → raw.githubusercontent.com
  if (url.includes('github.com') && url.includes('/blob/')) {
    url = url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
    toast('ℹ️ GitHub-URL → Raw-URL umgewandelt');
  }
  // Gist direkt: gist.github.com → raw (falls versehentlich)
  if (url.includes('gist.github.com') && !url.includes('/raw')) {
    url = url + '/raw';
  }

  const cat = document.getElementById('gpx-cat').value;
  // Trackname aus dem originalen URL-Pfad (vor der Umwandlung)
  const name = url.split('/').pop().split('?')[0]
    .replace(/\.gpx$/i,'').replace(/[_-]+/g,' ').trim() || 'Track';
  inp.value = '';
  toast('⏳ Lade ' + escHtml(name) + '…');

  // Fetch-Versuche: direkt → Proxy (außer Proxy ist schon aktiv)
  const fetchUrls = useProxy
    ? [`https://corsproxy.io/?${encodeURIComponent(url)}`]
    : [url, `https://corsproxy.io/?${encodeURIComponent(url)}`];

  let lastErr = '';
  for (let i = 0; i < fetchUrls.length; i++) {
    const fetchUrl = fetchUrls[i];
    const isProxy = fetchUrl.includes('corsproxy.io');
    try {
      const resp = await fetch(fetchUrl, { mode:'cors', credentials:'omit' });
      if (!resp.ok) throw new Error(`HTTP ${resp.status}: ${resp.statusText}`);

      const txt = await resp.text();
      const gpxStr = sanitizeGpx(txt);

      if (!gpxStr) {
        // sanitizeGpx hat leeren String zurückgegeben
        if (txt.toLowerCase().includes('<!doctype html') || txt.toLowerCase().includes('<html')) {
          throw new Error('Antwort ist eine HTML-Seite, keine GPX-Datei. Prüfe die URL (Raw-Link nötig?)');
        }
        throw new Error('Antwort enthält keine GPX-Trackdaten');
      }

      if (!gpxStr.startsWith('<')) {
        throw new Error('Kein gültiges XML: ' + gpxStr.substring(0, 40));
      }

      loadGpxXml(gpxStr, name, cat, null, url);
      return; // Erfolg

    } catch(err) {
      lastErr = err.message;
      console.warn(`GPX fetch [${isProxy?'proxy':'direkt'}] fehlgeschlagen:`, err.message);
      if (i < fetchUrls.length - 1) {
        toast('⚠️ Direkt gescheitert, versuche CORS-Proxy…');
        await new Promise(r => setTimeout(r, 400)); // kurze Pause
      }
    }
  }

  // Alle Versuche fehlgeschlagen
  const hint = lastErr.includes('HTML') ? ' (Raw-URL verwenden!)' :
               lastErr.includes('HTTP 4') ? ' (Datei nicht gefunden)' :
               lastErr.includes('HTTP 5') ? ' (Server-Fehler)' : '';
  toast('❌ GPX konnte nicht geladen werden' + hint);
  console.error('GPX URL load failed:', lastErr);
}

// ── KERN-FUNKTION: XML-String → Leaflet-Layer ─────────────────
// Übergibt den XML-String direkt an L.GPX.
// leaflet-gpx erkennt '<' als Präfix → DOMParser (kein XHR!).
function loadGpxXml(gpxStr, name, cat, existingId=null, sourceUrl=null, silent=false) {
  if (!gpxStr) {
    toast('❌ Kein GPX-Inhalt für: ' + escHtml(name));
    return null;
  }
  if (!gpxStr.startsWith('<')) {
    toast('❌ Kein XML für: ' + escHtml(name) + ' (beginnt mit: ' + gpxStr.substring(0,20) + ')');
    return null;
  }
  // HTML-Dokument abfangen (z.B. GitHub /blob/ Seite)
  const _gpxLow = gpxStr.substring(0, 60).toLowerCase();
  if (_gpxLow.startsWith('<!doctype html') || _gpxLow.includes('<html')) {
    toast('❌ ' + escHtml(name) + ': HTML-Seite statt GPX. Bitte Raw-URL verwenden.');
    return null;
  }

  const color = GPX_COLORS[cat] || '#27AE60';
  const id = existingId || ('trk-' + trackStore._id++);

  const layer = new L.GPX(gpxStr, {
    async: true,
    marker_options: {
      startIconUrl: null, endIconUrl: null, shadowUrl: null,
      wptIconUrls: { '': null }
    },
    polyline_options: {
      color, weight: 4.5, opacity: 0.9, lineCap: 'round', lineJoin: 'round'
    }
  });

  layer.on('loaded', function(e) {
    const gl = e.target;

    let dist = '?', dur = '—';
    try { dist = (gl.get_distance() / 1000).toFixed(2); } catch(ex) {}
    try {
      const ms = gl.get_total_time();
      if (ms) {
        const m = Math.round(ms / 60000);
        dur = m >= 60 ? `${Math.floor(m/60)}h ${m%60}m` : `${m}m`;
      }
    } catch(ex) {}

    const bounds = (() => {
      try { const b = gl.getBounds(); return (b && b.isValid && b.isValid()) ? b : null; }
      catch(ex) { return null; }
    })();

    // Punkte extrahieren — für Start/Ziel-Marker und spätere Nutzung
    const pts = _getGpxPoints(gl, gpxStr);

    const track = {
      id, name, cat, color,
      gpxLayer: gl, visible: true,
      sourceUrl: sourceUrl || null,
      gpxString: gpxStr,
      bounds,
      startPt:  pts.length > 0 ? pts[0]              : null,
      finishPt: pts.length > 1 ? pts[pts.length - 1] : null,
      stats: { dist, dur },
      elevData: extractElevData(gl),
      projectId: _activeProjectId || (_projects[0]?.id || '')
    };

    trackStore.tracks.push(track);
    // Kategorie-Filter: Layer von Karte nehmen wenn er nicht in den Filter passt
    if (gpxFilter !== 'all' && track.cat !== gpxFilter) {
      map.removeLayer(gl);
    }
    // GPX-Waypoints als Features importieren (falls QR-übertragen)
    _parseFeaturesFromGpx(id, gpxStr);
    // Start- und Ziel-Marker rendern
    _addStartMarker(track);
    _addFinishMarker(track);
    // Geo-tagged feature markers auf Hauptkarte rendern
    _renderTrackFeatures(track);
    updateGpxBadge();
    renderTrackList();
    persistTracks();

    if (!silent) {
      toast(`✅ "${escHtml(name)}" · ${dist} km`);
      switchGpxTab('tracks', null);
      // Zoom: nahe an Startpunkt (Zoom 17) + Popup öffnen
      if (track.startPt) {
        map.flyTo([track.startPt.lat, track.startPt.lng], 17, { animate:true, duration:1.2 });
        setTimeout(() => { if (track._startMkr) track._startMkr.openPopup(); }, 1350);
      } else if (bounds) {
        map.flyToBounds(bounds, { padding:[44,44], maxZoom:16, animate:true, duration:1.2 });
      }
    }
  });

  layer.on('error', function(e) {
    const msg = (e && e.err) ? String(e.err).substring(0, 80) : 'Parse-Fehler';
    toast('❌ GPX: ' + msg);
    console.error('L.GPX error:', e, '\nGPX start:', gpxStr.substring(0, 300));
  });

  layer.addTo(map);
  return layer;
}

// Alias-Funktion für Abwärtskompatibilität
function loadGpxFromString(gpxStr, name, cat) {
  loadGpxXml(sanitizeGpx(gpxStr), name, cat);
}

// ── TRACK-VERWALTUNG ──────────────────────────────────────────
function toggleTrack(id) {
  const t = trackStore.tracks.find(t => t.id===id); if(!t) return;
  if (t.visible) {
    // Track + Start/Ziel-Marker + Feature-Marker ausblenden
    if (map.hasLayer(t.gpxLayer))                               map.removeLayer(t.gpxLayer);
    if (t._startMkr  && map.hasLayer(t._startMkr))             map.removeLayer(t._startMkr);
    if (t._finishMkr && map.hasLayer(t._finishMkr))            map.removeLayer(t._finishMkr);
    (t._featMarkers||[]).forEach(m => { try { map.removeLayer(m); } catch(e) {} });
    t.visible = false;
  } else {
    t.visible = true;
    // Nur einblenden wenn Kategoriefilter passt
    if (gpxFilter === 'all' || t.cat === gpxFilter) {
      if (!map.hasLayer(t.gpxLayer))                            t.gpxLayer.addTo(map);
      if (t._startMkr  && !map.hasLayer(t._startMkr))          t._startMkr.addTo(map);
      if (t._finishMkr && !map.hasLayer(t._finishMkr))         t._finishMkr.addTo(map);
      _renderTrackFeatures(t);
    }
  }
  renderTrackList();
}

function removeTrack(id) {
  const idx = trackStore.tracks.findIndex(t => t.id===id); if(idx<0) return;
  _removeStartMarker(trackStore.tracks[idx]);
  _removeFinishMarker(trackStore.tracks[idx]);
  map.removeLayer(trackStore.tracks[idx].gpxLayer);
  trackStore.tracks.splice(idx, 1);
  updateGpxBadge();
  renderTrackList();
  persistTracks();
  document.getElementById('elev-panel').style.display = 'none';
  toast('🗑 Track entfernt');
}

function zoomTrack(id) {
  const t = trackStore.tracks.find(t => t.id===id); if(!t) return;
  // Zoom nah an Startpunkt (Zoom 17) und Popup öffnen
  if (t.startPt) {
    map.flyTo([t.startPt.lat, t.startPt.lng], 17, { animate:true, duration:1 });
    setTimeout(() => { if (t._startMkr) t._startMkr.openPopup(); }, 1100);
  } else {
    try {
      const b = t.bounds || t.gpxLayer.getBounds();
      if (b && b.isValid && b.isValid())
        map.flyToBounds(b, { padding:[44,44], maxZoom:16, animate:true, duration:1 });
    } catch(e) { console.warn('zoomTrack error:', e); }
  }
}

// Gesamte Strecke auf Karte anzeigen (Bounds-Ansicht)
function zoomTrackFull(id) {
  const t = trackStore.tracks.find(t => t.id===id); if(!t) return;
  try {
    const b = t.bounds || t.gpxLayer.getBounds();
    if (b && b.isValid && b.isValid())
      map.flyToBounds(b, { padding:[44,44], maxZoom:16, animate:true, duration:1 });
  } catch(e) { console.warn('zoomTrackFull error:', e); }
}

function filterTracks(cat, btn) {
  document.getElementById('elev-panel').style.display = 'none';
  // Globalen setFilter aufrufen → synchronisiert LOCS, Tracks, Custom-Marker, Chips
  setFilter(cat, null);
  // Eigene cat-fbtn-Buttons synchronisieren
  document.querySelectorAll('.cat-fbtn').forEach(b => b.classList.remove('on'));
  if (btn) btn.classList.add('on');
  renderTrackList();
}

function renderTrackList() {
  const cont = document.getElementById('trk-list'); if(!cont) return;
  // Tracks des Fokus-Projekts anzeigen (im Tracks-Panel)
  const base = trackStore.tracks.filter(t => !_activeProjectId || t.projectId===_activeProjectId);
  const list = gpxFilter==='all' ? base : base.filter(t => t.cat===gpxFilter);

  if (!list.length) {
    cont.innerHTML = `<div style="padding:20px 16px;text-align:center;color:var(--td);`
      + `font-family:var(--fh);font-size:13px;font-weight:700;text-transform:uppercase;`
      + `letter-spacing:1px">${trackStore.tracks.length
        ? 'Keine Tracks in dieser Kategorie' : 'Noch keine Tracks geladen'}</div>`;
    document.getElementById('gpx-track-cnt').textContent =
      trackStore.tracks.length + ' Track' + (trackStore.tracks.length!==1?'s':'');
    return;
  }

  cont.innerHTML = '';
  list.forEach(t => {
    const runCount = (_cachedRuns[t.id]||[]).length;
    const bestRun  = (_cachedRuns[t.id]||[]).slice().sort((a,b)=>a.totalMs-b.totalMs)[0];
    const isRacing = typeof RACE !== 'undefined' && RACE.trackId===t.id && RACE.state!=='idle' && RACE.state!=='finished';
    const row = document.createElement('div');
    row.className = 'trk-row'; row.setAttribute('role','listitem');
    const hasElev = !!(t.elevData && t.elevData.length > 1);
    row.innerHTML =
      `<div class="trk-dot" style="background:${t.color}"></div>`
      + `<div class="trk-inf" style="cursor:pointer" onclick="openTrackDetail('${t.id}')">`
      +   `<div class="trk-nm">${escHtml(t.name)}${isRacing?'<span style="color:var(--exp);font-size:10px;margin-left:6px">● LIVE</span>':''}</div>`
      +   `<div class="trk-meta">${escHtml(t.cat.charAt(0).toUpperCase()+t.cat.slice(1))}`
      +     ` · ${t.stats.dist} km · ${t.stats.dur}${hasElev?' · 📈':''}${runCount>0?` · <span style="color:var(--ac)">${runCount}×</span>${bestRun?' '+_fmtTime(bestRun.totalMs):''}`:''}</div>`
      + `</div>`
      + `<div class="trk-btns">`
      +   `<button class="trk-btn${t.visible?' on':''}" aria-label="${t.visible?'Ausblenden':'Einblenden'}" onclick="toggleTrack('${t.id}')">`
      +   (t.visible
          ? '<svg width="14" height="14" viewBox="0 0 14 14" fill="none"><path d="M1 7C1 7 3 3 7 3s6 4 6 4-2 4-6 4S1 7 1 7Z" stroke="currentColor" stroke-width="1.4"/><circle cx="7" cy="7" r="1.8" fill="currentColor"/></svg>'
          : '<svg width="14" height="14" viewBox="0 0 14 14" fill="none"><path d="M1 7C1 7 3 3 7 3s6 4 6 4-2 4-6 4S1 7 1 7Z" stroke="currentColor" stroke-width="1.4" opacity=".3"/><path d="M2 2L12 12" stroke="currentColor" stroke-width="1.4" stroke-linecap="round"/></svg>')
      +   `</button>`
      +   `<button class="trk-btn" style="color:var(--ac)" aria-label="QR/GPX" onclick="closeSettings();setTimeout(()=>openTrackQR('${t.id}'),280)">`
      +     `<svg width="13" height="13" viewBox="0 0 14 14" fill="none"><rect x="1" y="1" width="4" height="4" rx=".5" stroke="currentColor" stroke-width="1.3"/><rect x="9" y="1" width="4" height="4" rx=".5" stroke="currentColor" stroke-width="1.3"/><rect x="1" y="9" width="4" height="4" rx=".5" stroke="currentColor" stroke-width="1.3"/><path d="M9 9h1v1M11 9h1M9 11v1M11 12h1M12 11v-1" stroke="currentColor" stroke-width="1.3" stroke-linecap="round"/></svg>`
      +   `</button>`
      +   `<button class="trk-btn" style="color:#ef4444" aria-label="Löschen" onclick="removeTrack('${t.id}')">`
      +     `<svg width="14" height="14" viewBox="0 0 14 14" fill="none"><path d="M2 4H12M5 4V2H9V4M11 4L10 12H4L3 4" stroke="currentColor" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round"/></svg>`
      +   `</button>`
      + `</div>`;
    cont.appendChild(row);

    // Inline detail panel placeholder — filled asynchronously by _fillDetailSlot()
    if (_activeDetailId === t.id) {
      const slot = document.createElement('div');
      slot.id = 'trk-detail-slot';
      slot.className = 'trk-detail-loading';
      slot.textContent = 'Lädt…';
      cont.appendChild(slot);
    }
  });

  document.getElementById('gpx-track-cnt').textContent =
    trackStore.tracks.length + ' Track' + (trackStore.tracks.length!==1?'s':'');
}

function updateGpxBadge() {
  const b = document.getElementById('gpx-cnt');
  const n = trackStore.tracks.length;
  b.textContent = n; b.style.display = n ? '' : 'none';
}

// ── DRAG & DROP ───────────────────────────────────────────────
const dropOverlay = document.getElementById('gpx-drop-overlay');
document.addEventListener('dragover', e => {
  if ([...e.dataTransfer.items].some(i => i.kind==='file')) {
    e.preventDefault(); dropOverlay.style.display = 'flex';
  }
});
document.addEventListener('dragleave', e => {
  if (!e.relatedTarget || !document.contains(e.relatedTarget))
    dropOverlay.style.display = 'none';
});
document.addEventListener('drop', e => {
  e.preventDefault(); dropOverlay.style.display = 'none';
  const cat = document.getElementById('gpx-cat').value;
  [...e.dataTransfer.files]
    .filter(f => f.name.toLowerCase().endsWith('.gpx') || f.type.includes('gpx'))
    .forEach(file => {
      const reader = new FileReader();
      reader.onload = ev => {
        const gpxStr = sanitizeGpx(ev.target.result);
        if (gpxStr.startsWith('<'))
          loadGpxXml(gpxStr, file.name.replace(/\.gpx$/i,''), cat);
        else
          toast('❌ ' + escHtml(file.name) + ': Kein XML');
      };
      reader.readAsText(file, 'UTF-8');
    });
});

// ── INDEXEDDB: TRACKS (via localforage — kein Quota-Limit) ────
async function persistTracks() {
  try {
    const rows = trackStore.tracks.map(t => ({
      id:        t.id,
      name:      t.name,
      cat:       t.cat,
      color:     t.color,
      visible:   t.visible,
      stats:     t.stats,
      gpxString: t.gpxString || null,
      sourceUrl: t.sourceUrl || null,
      projectId: t.projectId || (_projects[0]?.id || '')
    }));
    await localforage.setItem(LS.K.TRACKS, rows);
  } catch(e) {
    console.warn('IndexedDB persistTracks error:', e);
  }
}

async function restoreTracks() {
  let saved;
  try {
    saved = await localforage.getItem(LS.K.TRACKS);
  } catch(e) {
    console.warn('IndexedDB restoreTracks error, LS-Fallback:', e);
    saved = LS.get(LS.K.TRACKS, []);
  }
  if (!saved || !saved.length) return;

  let restored = 0, skipped = 0;
  for (const t of saved) {
    if (trackStore.tracks.length >= 50) break;
    if (!t.gpxString) { skipped++; continue; }

    const gpxStr = sanitizeGpx(t.gpxString);
    if (!gpxStr.startsWith('<')) { skipped++; continue; }

    // Warten auf loaded/error Event mit Timeout-Sicherheitsnetz
    const ok = await new Promise(resolve => {
      const timeout = setTimeout(() => { console.warn('GPX restore timeout:', t.name); resolve(false); }, 10000);

      const layer = new L.GPX(gpxStr, {
        async: true,
        marker_options: { startIconUrl:null, endIconUrl:null, shadowUrl:null, wptIconUrls:{'':null} },
        polyline_options: { color:t.color||'#27AE60', weight:4.5, opacity:0.9, lineCap:'round', lineJoin:'round' }
      });

      layer.on('loaded', function(e) {
        clearTimeout(timeout);
        const gl = e.target;
        let dist=t.stats?.dist||'?', dur=t.stats?.dur||'—';
        try { dist=(gl.get_distance()/1000).toFixed(2); } catch(ex) {}
        const bounds = (() => {
          try { const b=gl.getBounds(); return (b&&b.isValid&&b.isValid())?b:null; } catch(ex){ return null; }
        })();
        const rPts = _getGpxPoints(gl, gpxStr);
        const track = {
          id:t.id, name:t.name, cat:t.cat, color:t.color,
          gpxLayer:gl, visible:t.visible!==false,
          sourceUrl:t.sourceUrl||null, gpxString:gpxStr,
          bounds, stats:{ dist, dur }, elevData:extractElevData(gl),
          startPt:  rPts.length > 0 ? rPts[0]               : null,
          finishPt: rPts.length > 1 ? rPts[rPts.length - 1] : null,
          projectId: t.projectId || ''
        };
        trackStore.tracks.push(track);
        // Sichtbarkeit: user-Präferenz + Kategorie-Filter + Projekt enabled
        const projEnabled = _projects.find(p => p.id === track.projectId)?.enabled !== false;
        const shouldBeOnMap = track.visible && (gpxFilter === 'all' || track.cat === gpxFilter) && projEnabled;
        if (!shouldBeOnMap) map.removeLayer(gl);
        // Start- und Ziel-Marker
        _addStartMarker(track);
        _addFinishMarker(track);
        resolve(true);
      });

      layer.on('error', function(e) {
        clearTimeout(timeout);
        console.warn('GPX restore error for', t.name, e);
        resolve(false);
      });

      // WICHTIG: Layer zur Karte hinzufügen, damit 'loaded' feuert
      layer.addTo(map);
    });

    if (ok) restored++; else skipped++;
  }

  updateGpxBadge();
  renderTrackList();
  if (restored > 0) toast(`💾 ${restored} Track${restored!==1?'s':''} wiederhergestellt`);
  if (skipped > 0)  console.info(`${skipped} Tracks übersprungen (kein GPX gespeichert)`);
}

// ── ELEVATION PROFIL ───────────────────────────────────────────
function extractElevData(gpxLayer){
  try{
    const elevs=[];
    gpxLayer.eachLayer(layer=>{
      if(layer.getLatLngs){
        const lls=layer.getLatLngs();
        const flat=Array.isArray(lls[0])?lls.flat():lls;
        flat.forEach(ll=>{if(ll.alt!=null&&!isNaN(ll.alt))elevs.push(ll.alt);});
      }
    });
    return elevs.length>=2?elevs:null;
  }catch(e){return null;}
}

function showElevProfile(id){
  const t=trackStore.tracks.find(t=>t.id===id);
  const panel=document.getElementById('elev-panel');
  if(!t||!t.elevData||t.elevData.length<2){panel.style.display='none';return;}
  panel.style.display='block';
  const canvas=document.getElementById('elev-canvas');
  const W=Math.max(200,panel.clientWidth-24),H=80;
  canvas.width=W;canvas.height=H;
  const data=t.elevData;
  const minE=Math.min(...data),maxE=Math.max(...data);
  const range=maxE-minE||1;
  let gain=0;
  for(let i=1;i<data.length;i++){const d=data[i]-data[i-1];if(d>0)gain+=d;}
  const ctx=canvas.getContext('2d');
  // Hintergrund
  ctx.fillStyle=isDark?'rgba(37,46,66,.8)':'rgba(220,226,236,.8)';
  ctx.fillRect(0,0,W,H);
  // Füll-Gradient
  const grad=ctx.createLinearGradient(0,0,0,H);
  grad.addColorStop(0,t.color+'cc');
  grad.addColorStop(1,t.color+'22');
  ctx.beginPath();
  data.forEach((e,i)=>{
    const x=(i/(data.length-1))*W;
    const y=H-((e-minE)/range)*(H-10)-5;
    i===0?ctx.moveTo(x,H):void 0;
    ctx.lineTo(x,y);
  });
  ctx.lineTo(W,H);ctx.lineTo(0,H);ctx.closePath();
  ctx.fillStyle=grad;ctx.fill();
  // Linie
  ctx.beginPath();ctx.strokeStyle=t.color;ctx.lineWidth=2.5;ctx.lineJoin='round';
  data.forEach((e,i)=>{
    const x=(i/(data.length-1))*W;
    const y=H-((e-minE)/range)*(H-10)-5;
    i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
  });
  ctx.stroke();
  document.getElementById('elev-min').textContent=Math.round(minE);
  document.getElementById('elev-max').textContent=Math.round(maxE);
  document.getElementById('elev-gain').textContent=Math.round(gain);
  document.getElementById('elev-dist').textContent=t.stats.dist;
}

// ═══════════════════════════════════════════════════════════════
// TRACK QR-CODE — Chunked Compressed Offline Transfer v2
// Architektur: Delta-Encode → pako DEFLATE → Base64url → Chunks
// Format:  {v:1, T:'gmtw-chunk', id, i, n, z, d}
//   z=1 → pako DEFLATE   z=0 → plain UTF-8 base64url (pako-Fallback)
//   d   → Datenchunk (base64url)
// Payload: {v:1, type:'gmtw-track', n, c, ts?, he?, ht?, p:[...]}
//   p    → delta-codierte Punkte [[lat_e5,lon_e5,ele_dm?,t_s?],...]
// ═══════════════════════════════════════════════════════════════
let curTrkQrId = null;
let _qrChunks  = [];  // Sender: aktuelle Chunks
let _qrChunkIdx = 0;  // Sender: Index des angezeigten Chunks

// ── Konstanten ─────────────────────────────────────────────────
const _QR_CHUNK_SIZE = 1100; // chars/Chunk → QR-Version ~25–28, sicher scannbar
const _QR_MAX_PTS    = 1000; // Max Punkte nach RDP-Vereinfachung

// ── GPX-Punkte parsen ──────────────────────────────────────────
// Gibt Array von {lat, lon, ele, time, _hasEle, _hasTime} zurück
function _parseGpxPoints(gpxStr) {
  try {
    const doc = new DOMParser().parseFromString(gpxStr, 'text/xml');
    // DOMParser liefert parseerror-Element bei fehlerhaftem XML
    if (doc.querySelector('parsererror')) return [];
    const pts = [];
    doc.querySelectorAll('trkpt, rtept').forEach(pt => {
      const lat = parseFloat(pt.getAttribute('lat'));
      const lon = parseFloat(pt.getAttribute('lon'));
      if (!isFinite(lat) || !isFinite(lon)) return;
      const eleEl  = pt.querySelector('ele');
      const timeEl = pt.querySelector('time');
      const ele    = eleEl  ? (parseFloat(eleEl.textContent)  || 0) : 0;
      const tRaw   = timeEl ? timeEl.textContent.trim() : '';
      const tMs    = tRaw   ? (new Date(tRaw).getTime() || 0)       : 0;
      pts.push({ lat, lon, ele, time: tMs, _hasEle: !!eleEl, _hasTime: tMs > 0 });
    });
    return pts;
  } catch(e) { return []; }
}

// ── Ramer-Douglas-Peucker (iterativ via Stack → kein Stack-Overflow) ──
function _rdpPerp(pt, a, b) {
  const dx = b.lon - a.lon, dy = b.lat - a.lat;
  if (!dx && !dy) return Math.hypot(pt.lon - a.lon, pt.lat - a.lat);
  const t = Math.max(0, Math.min(1, ((pt.lon-a.lon)*dx + (pt.lat-a.lat)*dy) / (dx*dx+dy*dy)));
  return Math.hypot(pt.lon - a.lon - t*dx, pt.lat - a.lat - t*dy);
}
function _rdpIter(pts, eps) {
  if (pts.length <= 2) return pts.slice();
  const keep = new Uint8Array(pts.length); // 0 = wegwerfen, 1 = behalten
  keep[0] = keep[pts.length - 1] = 1;
  const stack = [[0, pts.length - 1]];  // [start, end] Paare
  while (stack.length) {
    const [s, e] = stack.pop();
    let maxD = 0, idx = s;
    for (let k = s + 1; k < e; k++) {
      const d = _rdpPerp(pts[k], pts[s], pts[e]);
      if (d > maxD) { maxD = d; idx = k; }
    }
    if (maxD > eps) {
      keep[idx] = 1;
      if (idx - s > 1) stack.push([s, idx]);
      if (e - idx > 1) stack.push([idx, e]);
    }
  }
  return pts.filter((_, i) => keep[i]);
}
function _simplifyPoints(pts, maxPts) {
  if (pts.length <= maxPts) return pts;
  // Vorab-Sampling für sehr große Tracks (>8000 Punkte)
  let work = pts;
  if (pts.length > 8000) {
    const step = pts.length / 5000;
    const s = [pts[0]];
    for (let i = step; i < pts.length - 1; i += step) s.push(pts[Math.round(i)]);
    s.push(pts[pts.length - 1]);
    work = s;
  }
  // Binäre Suche auf optimalem Epsilon — 18 Schritte → Genauigkeit 1:2^18
  let lo = 1e-8, hi = 2.0, best = work;
  for (let it = 0; it < 18; it++) {
    const mid = (lo + hi) / 2;
    const r   = _rdpIter(work, mid);
    if (r.length > maxPts) lo = mid;
    else { hi = mid; best = r; }
  }
  // Sicherheitsnetz: wenn best leer (nur Start+Ende), gib mindestens die zurück
  return best.length >= 2 ? best : [pts[0], pts[pts.length - 1]];
}

// ── Kompaktes Track-Format: Encode ────────────────────────────
function _encodeTrackCompact(track, pts) {
  if (!pts.length) return { v:1, type:'gmtw-track', n:track.name, c:track.cat, p:[] };
  // Flags auf Basis der tatsächlich vorhandenen Daten entscheiden
  const hasEle  = pts.some(p => p._hasEle);
  const hasTime = pts.some(p => p._hasTime);
  const t0 = hasTime ? (pts.find(p => p._hasTime) || pts[0]).time : 0;

  let pLat=0, pLon=0, pEle=0, pT=0;
  const p = pts.map((pt, i) => {
    const la = Math.round(pt.lat * 1e5);
    const lo = Math.round(pt.lon * 1e5);
    const el = Math.round(pt.ele * 10);        // Dezimeter
    const ts = pt._hasTime ? Math.round((pt.time - t0) / 1000) : 0; // Sekunden
    let row;
    if (i === 0) {
      row = hasEle ? (hasTime ? [la,lo,el,ts] : [la,lo,el]) : [la,lo];
      pLat=la; pLon=lo; pEle=el; pT=ts;
    } else {
      const dl=la-pLat, dn=lo-pLon, de=el-pEle, dt=ts-pT;
      row = hasEle ? (hasTime ? [dl,dn,de,dt] : [dl,dn,de]) : [dl,dn];
      pLat=la; pLon=lo; pEle=el; pT=ts;
    }
    return row;
  });

  const payload = { v:1, type:'gmtw-track', n:track.name, c:track.cat, p };
  if (hasEle)  payload.he = 1;
  if (hasTime) { payload.ht = 1; payload.ts = new Date(t0).toISOString(); }
  return payload;
}

// ── Kompaktes Track-Format: Decode → GPX/1.1-XML ──────────────
// Gibt Standard-GPX zurück, der sanitizeGpx() + L.GPX-Parser besteht
function _decodeTrackCompactToGpx(payload) {
  if (!payload || !Array.isArray(payload.p)) return null;
  const pts = payload.p;
  if (!pts.length) return null;

  const name    = String(payload.n || 'Importierter Track').slice(0, 200);
  const cat     = String(payload.c || 'mittel');
  const hasEle  = !!payload.he;
  const hasTime = !!payload.ht;
  // Startzeit: ISO-String aus payload.ts oder aktuelle Zeit (für Elevationsberechnung nicht relevant)
  const t0Ms = (hasTime && payload.ts)
    ? (new Date(payload.ts).getTime() || Date.now()) : 0;

  let aLat=0, aLon=0, aEle=0, aT=0;
  const trkptLines = [];
  let valid = 0;

  for (let i = 0; i < pts.length; i++) {
    const row = pts[i];
    if (!Array.isArray(row) || row.length < 2) continue;
    if (i === 0) {
      aLat = row[0]; aLon = row[1];
      aEle = hasEle  ? (row[2] || 0) : 0;
      aT   = hasTime ? (row[hasEle ? 3 : 2] || 0) : 0;
    } else {
      aLat += row[0]; aLon += row[1];
      aEle += hasEle  ? (row[2] || 0) : 0;
      aT   += hasTime ? (row[hasEle ? 3 : 2] || 0) : 0;
    }
    const lat = aLat / 1e5;
    const lon = aLon / 1e5;
    // Sanity-Check: lat ∈ [-90,90], lon ∈ [-180,180]
    if (lat < -90 || lat > 90 || lon < -180 || lon > 180) continue;
    const latS = lat.toFixed(7);
    const lonS = lon.toFixed(7);
    const inner = [];
    if (hasEle)  inner.push(`      <ele>${(aEle / 10).toFixed(1)}</ele>`);
    if (hasTime) inner.push(`      <time>${new Date(t0Ms + aT * 1000).toISOString()}</time>`);
    trkptLines.push(
      `    <trkpt lat="${latS}" lon="${lonS}">`
      + (inner.length ? '\n' + inner.join('\n') + '\n    ' : '')
      + '</trkpt>'
    );
    valid++;
  }

  if (valid === 0) return null;

  return `<?xml version="1.0" encoding="UTF-8"?>\n`
    + `<gpx version="1.1" creator="GMTW Trail Map v2"\n`
    + `     xmlns="http://www.topografix.com/GPX/1/1"\n`
    + `     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n`
    + `     xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd">\n`
    + `  <metadata><name>${escXml(name)}</name></metadata>\n`
    + `  <trk>\n`
    + `    <name>${escXml(name)}</name>\n`
    + `    <desc>Kat: ${escXml(cat)} · QR-Import GMTW</desc>\n`
    + `    <trkseg>\n`
    + trkptLines.join('\n') + '\n'
    + `    </trkseg>\n`
    + `  </trk>\n`
    + `</gpx>`;
}

// ── Base64url encode/decode ────────────────────────────────────
function _b64uEncode(u8) {
  // Uint8Array → base64url (URL-safe, kein Padding)
  let s = '';
  for (let i = 0; i < u8.length; i++) s += String.fromCharCode(u8[i]);
  return btoa(s).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
}
function _b64uDecode(str) {
  // base64url → Uint8Array
  const s   = (str + '==='.slice((str.length + 3) & 3)).replace(/-/g,'+').replace(/_/g,'/');
  const raw = atob(s);
  const u8  = new Uint8Array(raw.length);
  for (let i = 0; i < raw.length; i++) u8[i] = raw.charCodeAt(i);
  return u8;
}

// ── Fallback: Punkte aus Leaflet-Layer extrahieren ────────────
function _ptsFromLayer(track) {
  const pts = [];
  try {
    track.gpxLayer.eachLayer(layer => {
      if (!layer.getLatLngs) return;
      const lls = layer.getLatLngs();
      const flat = (lls.length && Array.isArray(lls[0])) ? lls.flat() : lls;
      flat.forEach(ll => {
        if (typeof ll.lat === 'number' && typeof ll.lng === 'number')
          pts.push({ lat: ll.lat, lon: ll.lng, ele: ll.alt || 0, time: 0, _hasEle: !!ll.alt, _hasTime: false });
      });
    });
  } catch(e) { console.warn('_ptsFromLayer:', e); }
  return pts;
}

// ── Track zu QR-Chunks aufbereiten (Sender) ───────────────────
async function _buildTrackQrChunks(track, gpxStr) {
  // 1. Punkte gewinnen
  let rawPts = _parseGpxPoints(gpxStr);
  if (!rawPts.length) rawPts = _ptsFromLayer(track); // Layer-Fallback
  if (!rawPts.length) throw new Error('Keine GPS-Punkte gefunden');

  // 2. RDP-Vereinfachung
  const simplified = _simplifyPoints(rawPts, _QR_MAX_PTS);

  // 3. Kompaktes Format
  const payload = _encodeTrackCompact(track, simplified);
  const jsonStr = JSON.stringify(payload);

  // 4. Komprimierung: pako DEFLATE Level 9 → Base64url
  let compressed, z;
  if (window.pako) {
    try {
      compressed = _b64uEncode(pako.deflate(jsonStr, { level: 9 }));
      z = 1; // pako DEFLATE
    } catch(e) { /* Fallback unten */ }
  }
  if (!compressed) {
    // Fallback: plain UTF-8 base64url (kein pako)
    const bytes = new TextEncoder().encode(jsonStr);
    compressed = _b64uEncode(bytes);
    z = 0; // kein DEFLATE
  }

  // 5. In Chunks splitten
  const n   = Math.ceil(compressed.length / _QR_CHUNK_SIZE);
  const id  = Math.random().toString(36).slice(2, 9); // 7-Zeichen-ID
  const chunks = [];
  for (let i = 0; i < n; i++) {
    const d = compressed.slice(i * _QR_CHUNK_SIZE, (i + 1) * _QR_CHUNK_SIZE);
    // z-Flag im Chunk → Receiver weiß ob pako.inflate nötig
    chunks.push(JSON.stringify({ v:1, T:'gmtw-chunk', id, i, n, z, d }));
  }

  return { chunks, rawPts, pts: simplified, compressed, jsonStr, z };
}

// ── Sender: QR-Chunk zeichnen + UI aktualisieren ──────────────
function _drawQrChunk(idx) {
  _qrChunkIdx = idx;
  const canvas = document.getElementById('trk-qr-canvas');
  drawQR(canvas, _qrChunks[idx], 212, '#0b0e14', '#ffffff');
  // Counter
  const ctr = document.getElementById('trk-qr-chunk-counter');
  if (ctr) ctr.textContent = `${idx + 1} / ${_qrChunks.length}`;
  // Segment-Fortschrittsbalken (welcher ist aktiv)
  const bar = document.getElementById('trk-qr-chunk-bar');
  if (bar) bar.innerHTML = _qrChunks.map((_, j) =>
    `<div style="flex:1;height:4px;border-radius:2px;background:${
      j === idx ? 'var(--ac)' : j < idx ? 'rgba(200,255,0,.45)' : 'var(--bd2)'
    }"></div>`
  ).join('');
  // Navigations-Buttons
  const prev = document.getElementById('trk-qr-prev');
  const next = document.getElementById('trk-qr-next');
  if (prev) prev.disabled = idx === 0;
  if (next) {
    const last = idx === _qrChunks.length - 1;
    next.disabled = last;
    next.textContent = last ? '✅ Fertig' : 'Weiter →';
    next.style.background = last ? 'var(--s3)' : 'var(--ac)';
  }
}
function trkQrPrevChunk() { if (_qrChunkIdx > 0) _drawQrChunk(_qrChunkIdx - 1); }
function trkQrNextChunk() { if (_qrChunkIdx < _qrChunks.length - 1) _drawQrChunk(_qrChunkIdx + 1); }

// ── Modal öffnen (intern, nach Chunk-Berechnung) ──────────────
function _openTrkQrModal(gpxStr, track) {
  const dlBtn = document.getElementById('trk-qr-dl-btn');
  if (dlBtn) { dlBtn.dataset.gpx = gpxStr; dlBtn.dataset.name = track.name; }
  closeAll();
  _updateTrkQrShareBtn();
  const m = document.getElementById('trk-qrm');
  m.style.opacity = '0'; m.style.visibility = 'visible';
  m.style.transform = 'translate(-50%,-50%) scale(.88)';
  requestAnimationFrame(() => {
    m.style.transition = 'all .25s cubic-bezier(.32,.72,0,1)';
    m.style.opacity    = '1';
    m.style.transform  = 'translate(-50%,-50%) scale(1)';
  });
  document.getElementById('backdrop').classList.add('show');
}

/**
 * Injects geo-tagged features as GPX <wpt> elements into a GPX string.
 * Only for features that have lat/lng. Called before QR generation for local tracks.
 * @param {string} trackId
 * @param {string} gpxStr  Original GPX string
 * @returns {string}       GPX string with <wpt> elements injected
 */
function _injectFeaturesIntoGpx(trackId, gpxStr) {
  _loadTrkFeatures();
  const feats = (_trkFeatures[trackId] || []).filter(f => f.lat != null && f.lng != null);
  if (!feats.length) return gpxStr;
  const wpts = feats.map(f => {
    const name = escHtml(f.name || FEAT_NAMES[f.type] || f.type);
    const desc = `gmtw:feat:${f.type}:${f.diff||1}`;
    return `<wpt lat="${f.lat.toFixed(6)}" lon="${f.lng.toFixed(6)}">\n  <name>${name}</name>\n  <desc>${desc}</desc>\n  <sym>Waypoint</sym>\n</wpt>`;
  }).join('\n');
  // Insert before </gpx>
  return gpxStr.replace(/<\/gpx>(\s*)$/, `${wpts}\n</gpx>$1`);
}

/**
 * Parses gmtw:feat:* waypoints from a GPX string and stores them as track features.
 * Called in loadGpxXml after a track is fully loaded.
 * @param {string} trackId
 * @param {string} gpxStr
 */
function _parseFeaturesFromGpx(trackId, gpxStr) {
  try {
    const parser = new DOMParser();
    const xml = parser.parseFromString(gpxStr, 'text/xml');
    const wpts = Array.from(xml.querySelectorAll('wpt'));
    const gmtwWpts = wpts.filter(w => {
      const desc = w.querySelector('desc');
      return desc && desc.textContent.startsWith('gmtw:feat:');
    });
    if (!gmtwWpts.length) return;
    _loadTrkFeatures();
    if (!_trkFeatures[trackId]) _trkFeatures[trackId] = [];
    gmtwWpts.forEach(w => {
      const lat  = parseFloat(w.getAttribute('lat'));
      const lng  = parseFloat(w.getAttribute('lon'));
      const desc = w.querySelector('desc').textContent; // gmtw:feat:type:diff
      const name = (w.querySelector('name')?.textContent || '').trim();
      const parts = desc.split(':'); // ['gmtw','feat','type','diff']
      const type = parts[2] || 'drop';
      const diff = parseInt(parts[3]) || 1;
      if (isNaN(lat) || isNaN(lng)) return;
      // Avoid duplicates: skip if same lat/lng already exists
      const dup = _trkFeatures[trackId].some(f => f.lat && Math.abs(f.lat - lat) < 0.00001 && Math.abs(f.lng - lng) < 0.00001);
      if (!dup) {
        _trkFeatures[trackId].push({ type, name, diff, date: Date.now(), lat, lng });
      }
    });
    _saveTrkFeatures();
  } catch(e) { console.warn('[parseFeaturesFromGpx]', e); }
}

// ── Hauptfunktion: Track-QR öffnen ────────────────────────────
function openTrackQR(trackId) {
  const t = trackStore.tracks.find(tr => tr.id === trackId);
  if (!t) { toast('❌ Track nicht gefunden'); return; }
  curTrkQrId = trackId;
  document.getElementById('trk-qr-nm').textContent = t.name;
  const catLabel = t.cat.charAt(0).toUpperCase() + t.cat.slice(1);
  // Vorläufige Info (wird nach Komprimierung aktualisiert)
  document.getElementById('trk-qr-info').innerHTML =
    `<strong>${escHtml(t.name)}</strong><br>${escHtml(catLabel)} · ${t.stats.dist} km<br>`
    + `<span style="color:var(--td);font-size:10px">⏳ QR wird erstellt…</span>`;

  extractGpxFromLayer(t).then(async gpxStr => {
    const gpxKB = Math.round(new Blob([gpxStr]).size / 1024);

    // ── Strategie 1: Online-URL → einfacher URL-QR ────────────
    if (t.sourceUrl && !t.sourceUrl.startsWith('blob:')) {
      _qrChunks = [t.sourceUrl]; _qrChunkIdx = 0;
      document.getElementById('trk-qr-hint').textContent = 'QR scannen → GPX-URL laden';
      document.getElementById('trk-qr-chunk-nav').style.display = 'none';
      document.getElementById('trk-qr-info').innerHTML =
        `<strong>${escHtml(t.name)}</strong><br>${escHtml(catLabel)} · ${t.stats.dist} km`
        + ` · <span style="color:var(--ac)">🌐 Online-Link</span>`;
      drawQR(document.getElementById('trk-qr-canvas'), t.sourceUrl, 212);
      _openTrkQrModal(gpxStr, t);
      return;
    }

    // ── Strategie 2: Lokaler Track → komprimierte Chunks ──────
    try {
      // Features als <wpt> in GPX einbetten (nur lokale Tracks)
      const gpxWithFeats = _injectFeaturesIntoGpx(trackId, gpxStr);
      const res = await _buildTrackQrChunks(t, gpxWithFeats);
      _qrChunks  = res.chunks;
      _qrChunkIdx = 0;

      const n       = res.chunks.length;
      const origN   = res.rawPts.length;
      const simN    = res.pts.length;
      const compKB  = (res.compressed.length / 1024).toFixed(1);
      const ratio   = origN ? Math.round((1 - res.compressed.length / (gpxKB * 1024)) * 100) : 0;
      const zLabel  = res.z === 1 ? 'pako' : 'raw';

      document.getElementById('trk-qr-info').innerHTML =
        `<strong>${escHtml(t.name)}</strong> · ${escHtml(catLabel)}<br>`
        + `${t.stats.dist} km · ${gpxKB} KB → `
        + `<span style="color:var(--ac)">${compKB} KB (${zLabel}, ${ratio}%↓)</span><br>`
        + `${simN}${simN < origN ? ' / ' + origN : ''} Pkte · `
        + `<strong style="color:var(--ac)">📡 ${n} QR-Code${n > 1 ? 's' : ''}</strong>`;

      document.getElementById('trk-qr-hint').textContent = n > 1
        ? `Alle ${n} QR-Codes der Reihe nach scannen (Handy 2)`
        : 'QR-Code scannen → Track vollständig übertragen';

      const nav = document.getElementById('trk-qr-chunk-nav');
      if (nav) nav.style.display = n > 1 ? '' : 'none';

      _drawQrChunk(0);
      _openTrkQrModal(gpxStr, t);
    } catch(e) {
      toast('❌ QR-Erstellung: ' + e.message);
      console.error('openTrackQR Fehler:', e);
    }
  });
}

async function extractGpxFromLayer(track){
  if(track.gpxString) return track.gpxString;
  const lines=[];
  track.gpxLayer.eachLayer(layer=>{
    if(layer.getLatLngs){try{const c=layer.getLatLngs();if(c&&c.length)lines.push(Array.isArray(c[0])?c.flat():c);}catch(e){}}
  });
  const allPts=lines.flat();
  if(!allPts.length) return buildSimpleGpx(track.name);
  const pts=allPts.map(ll=>`    <trkpt lat="${ll.lat.toFixed(7)}" lon="${ll.lng.toFixed(7)}">${ll.alt!=null?`\n      <ele>${ll.alt.toFixed(1)}</ele>`:''}\n    </trkpt>`).join('\n');
  return `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="GMTW Trail Map" xmlns="http://www.topografix.com/GPX/1/1">
  <metadata><name>${escXml(track.name)}</name></metadata>
  <trk><name>${escXml(track.name)}</name><desc>Kategorie: ${escXml(track.cat)} · ${track.stats.dist} km</desc>
    <trkseg>\n${pts}\n    </trkseg></trk>
</gpx>`;
}

function buildSimpleGpx(name){return `<?xml version="1.0" encoding="UTF-8"?><gpx version="1.1" creator="GMTW Trail Map"><trk><name>${escXml(name)}</name></trk></gpx>`;}
function extractWaypoints(track){
  try{const b=track.gpxLayer.getBounds();return{start:`${b.getSouthWest().lat.toFixed(5)},${b.getSouthWest().lng.toFixed(5)}`,end:`${b.getNorthEast().lat.toFixed(5)},${b.getNorthEast().lng.toFixed(5)}`};}
  catch(e){return{start:'0,0',end:'0,0'};}
}

function trkQrDownloadGpx(){
  const btn=document.getElementById('trk-qr-dl-btn');
  const gpxStr=btn.dataset.gpx,name=btn.dataset.name||'GMTW_Track';
  if(!gpxStr){toast('❌ Kein GPX verfügbar');return;}
  dlFile(name+'.gpx',gpxStr,'application/gpx+xml');
  toast('⬇ GPX gespeichert!');
}
function trkQrDownloadImg(){
  const canvas=document.getElementById('trk-qr-canvas');
  const t=trackStore.tracks.find(t=>t.id===curTrkQrId);
  const name=(t?t.name:'GMTW_Track').replace(/[^a-zA-Z0-9_-]/g,'_');
  downloadCanvas(canvas,name+'_QR.png');
}
function trkQrCopyUrl(){
  const t=trackStore.tracks.find(t=>t.id===curTrkQrId);
  const url=(t&&t.sourceUrl)?t.sourceUrl:window.location.href;
  if(navigator.clipboard) navigator.clipboard.writeText(url).then(()=>toast('📋 Link kopiert!'));
  else{legacyCopy(url);toast('📋 Link kopiert!');}
}

// Web Share: GPX aus Track-QR-Modal teilen
async function trkQrShareGpx(){
  const btn=document.getElementById('trk-qr-dl-btn');
  const gpxStr=btn.dataset.gpx;
  const t=trackStore.tracks.find(t=>t.id===curTrkQrId);
  const name=(t?t.name:'GMTW_Track');
  const subtitle=t?`${t.stats.dist} km · ${t.cat}`:'';
  if(!gpxStr){toast('❌ Kein GPX verfügbar');return;}
  await _shareGpxFile(gpxStr, name, subtitle);
}

// Track-QR-Modal Share-Button: nach Öffnen sichtbar schalten
function _updateTrkQrShareBtn(){
  const btn=document.getElementById('trk-qr-share-btn');
  if(btn) btn.style.display=(navigator.share||navigator.canShare)?'':'none';
}

// ── STRECKEN-AUFNAHME ──────────────────────────────────────────
const recorder={
  isRecording:false,isPaused:false,
  points:[],watchId:null,
  elapsed:0,_segStart:null,
  _timerInt:null,_persistInt:null,_lastPos:null,_lastTime:null,
  totalDist:0,previewLine:null,MIN_SPEED:0.5
};

// ── Aufnahme: Robustheitssystem ─────────────────────────────────
let _recWakeLock  = null;   // Screen Wake Lock (verhindert Displayabschaltung)
let _recGpsErrors = 0;      // Zähler GPS-Fehler für automatischen Retry

async function _recAcquireWakeLock() {
  if (!('wakeLock' in navigator)) return;
  try {
    _recWakeLock = await navigator.wakeLock.request('screen');
    _recWakeLock.onrelease = () => { _recWakeLock = null; };
  } catch(e) { console.warn('[Rec] WakeLock nicht verfügbar:', e.message); }
}
function _recReleaseWakeLock() {
  if (_recWakeLock) { _recWakeLock.release().catch(()=>{}); _recWakeLock = null; }
}

// GPS-Fehler-Behandlung: bis zu 3 Versuche, dann Stopp
function _recHandleGpsError(err) {
  if (!recorder.isRecording) return;
  _recGpsErrors++;
  const msgs = {1:'GPS-Zugriff verweigert',2:'Kein GPS-Signal',3:'GPS-Timeout'};
  const label = msgs[err.code] || 'GPS-Fehler';
  if (_recGpsErrors >= 3) {
    toast(`❌ ${label} — Aufnahme gestoppt (3 Fehler).`);
    speak(`${label}. Aufnahme gestoppt.`, true);
    recStop();
    return;
  }
  toast(`⚠️ ${label} — Retry ${_recGpsErrors}/3…`);
  speak(`${label}. Neuer Versuch.`, false);
  // GPS-Watch neu starten mit leicht gelockerten Constraints
  if (recorder.watchId !== null) {
    navigator.geolocation.clearWatch(recorder.watchId);
    recorder.watchId = null;
  }
  setTimeout(() => {
    if (!recorder.isRecording) return;
    recorder.watchId = navigator.geolocation.watchPosition(
      pos => { _recGpsErrors = 0; recOnPosition(pos); },
      _recHandleGpsError,
      { enableHighAccuracy: _recGpsErrors < 2, timeout: 20000, maximumAge: 5000 }
    );
  }, 2000 * _recGpsErrors);
}

// Sichtbarkeitswechsel (Bildschirm aus/an)
document.addEventListener('visibilitychange', async () => {
  if (!recorder.isRecording) return;
  if (document.visibilityState === 'hidden') {
    persistRecorder(); // State sichern wenn Bildschirm aus geht
  } else {
    // Zurück aus Hintergrund: Wake Lock ggf. neu anfordern
    persistRecorder();
    if (!_recWakeLock) await _recAcquireWakeLock();
    // GPS-Watch neu starten (kann im Hintergrund abgebrochen worden sein)
    if (recorder.watchId !== null) {
      navigator.geolocation.clearWatch(recorder.watchId);
      recorder.watchId = null;
    }
    _recGpsErrors = 0;
    recorder.watchId = navigator.geolocation.watchPosition(
      pos => { _recGpsErrors = 0; recOnPosition(pos); },
      _recHandleGpsError,
      { enableHighAccuracy: true, timeout: 15000, maximumAge: 2000 }
    );
    toast('📡 GPS nach Bildschirmpause neu verbunden');
  }
});

function haversine(lat1,lng1,lat2,lng2){
  const R=6371000,r=Math.PI/180;
  const dLat=(lat2-lat1)*r,dLng=(lng2-lng1)*r;
  const a=Math.sin(dLat/2)**2+Math.cos(lat1*r)*Math.cos(lat2*r)*Math.sin(dLng/2)**2;
  return R*2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));
}

async function recStart(){
  if(!('geolocation'in navigator)){showGpsHint('GPS nicht verfügbar','Geolocation wird für die Aufnahme benötigt.');return;}

  // Fahrerprofil laden und anzeigen
  const prof = LS.get(LS.K.PROFILE, {});
  const riderName = prof.name     || '';
  const muniName  = prof.muniName || '';
  const riderInfo = [riderName, muniName].filter(Boolean).join(' · ') || '(kein Profil)';
  const riderBar  = document.getElementById('rec-rider-bar');
  const riderInfoEl = document.getElementById('rec-rider-info');
  if (riderBar)   { riderBar.style.display = 'flex'; }
  if (riderInfoEl){ riderInfoEl.textContent = riderInfo; }

  // Track-Name vorbelegen: "Name – Muni – YYYY-MM-DD"
  const today = new Date().toISOString().slice(0,10);
  const suggestedName = [riderName, muniName, today].filter(Boolean).join(' – ');
  const nameInp = document.getElementById('rec-name-inp');
  if (nameInp && !nameInp.value) nameInp.value = suggestedName;

  // Status reset
  recorder.isRecording=true; recorder.isPaused=false;
  recorder.points=[];        recorder.elapsed=0;     recorder.totalDist=0;
  recorder._lastPos=null;    recorder._lastTime=null; recorder._segStart=Date.now();
  _recGpsErrors = 0;

  recUpdateUI();
  document.getElementById('rec-save-section').style.display = 'none';
  toast('🔴 Aufnahme läuft…');
  speak(`Aufnahme gestartet. Fahrer: ${riderName||'unbekannt'}. Muni: ${muniName||'unbekannt'}.`, true);
  document.getElementById('rec-bar').classList.add('show');

  if(recorder.previewLine){map.removeLayer(recorder.previewLine);recorder.previewLine=null;}
  recorder.previewLine=L.polyline([],{color:'#ef4444',weight:3,opacity:.85,dashArray:'6 4'}).addTo(map);

  // GPS-Watch starten
  recorder.watchId=navigator.geolocation.watchPosition(
    pos=>{ _recGpsErrors=0; recOnPosition(pos); },
    _recHandleGpsError,
    {enableHighAccuracy:true,timeout:15000,maximumAge:1000}
  );

  // Timer + Auto-Save
  recorder._timerInt   = setInterval(recTickDisplay, 1000);
  recorder._persistInt = setInterval(persistRecorder, 5000);

  // Screen Wake Lock (verhindert Displayabschaltung während Aufnahme)
  await _recAcquireWakeLock();
}

function recOnPosition(pos){
  if(!recorder.isRecording||recorder.isPaused)return;
  const{latitude:lat,longitude:lng,altitude:ele,speed,accuracy}=pos.coords;
  if(accuracy>50)return; // Schlechte Genauigkeit ignorieren
  const pt={lat,lng,ele:ele||0,time:new Date(pos.timestamp).toISOString(),speed:speed||0};
  if(recorder._lastPos){
    const dist=haversine(recorder._lastPos.lat,recorder._lastPos.lng,lat,lng);
    const dt=(pos.timestamp-recorder._lastTime)/1000;
    const spd=dt>0?dist/dt:0;
    const moving=(speed!==null&&speed>recorder.MIN_SPEED)||(spd>recorder.MIN_SPEED);
    if(moving)recorder.totalDist+=dist;
  }
  recorder._lastPos={lat,lng};recorder._lastTime=pos.timestamp;
  recorder.points.push(pt);
  recorder.previewLine.addLatLng([lat,lng]);
  document.getElementById('rec-pts').textContent=recorder.points.length;
  document.getElementById('rec-dist').textContent=(recorder.totalDist/1000).toFixed(2);
}

function recPause(){
  if(!recorder.isRecording)return;
  recorder.isPaused=!recorder.isPaused;
  if(recorder.isPaused){
    if(recorder._segStart!==null){recorder.elapsed+=(Date.now()-recorder._segStart);recorder._segStart=null;}
  } else {
    recorder._segStart=Date.now();
  }
  document.getElementById('rec-pause-btn').textContent=recorder.isPaused?'Weiter':'Pause';
  document.getElementById('rec-status-txt').textContent=recorder.isPaused?'Pausiert':'Aufnahme läuft';
  document.getElementById('rec-status-txt').style.color=recorder.isPaused?'var(--mit)':'#ef4444';
  toast(recorder.isPaused?'⏸ Pause':'▶ Aufnahme weiter');
}

function recStop(){
  if(recorder._segStart!==null){recorder.elapsed+=(Date.now()-recorder._segStart);recorder._segStart=null;}
  recorder.isRecording=false;recorder.isPaused=false;
  if(recorder.watchId!==null){navigator.geolocation.clearWatch(recorder.watchId);recorder.watchId=null;}
  clearInterval(recorder._timerInt);   recorder._timerInt=null;
  clearInterval(recorder._persistInt); recorder._persistInt=null;
  _recReleaseWakeLock();

  document.getElementById('rec-bar').classList.remove('show');
  document.getElementById('rec-status-txt').textContent=`Beendet · ${recorder.points.length} Punkte`;
  document.getElementById('rec-status-txt').style.color='var(--ac)';
  document.getElementById('rec-start-btn').style.display='';
  document.getElementById('rec-pause-btn').style.display='none';
  document.getElementById('rec-stop-btn').style.display='none';

  if(!recorder.points.length){toast('⚠️ Keine GPS-Punkte aufgezeichnet');recReset();return;}

  // Zusammenfassung befüllen
  const totalSec = Math.floor(recorder.elapsed/1000);
  const hh=Math.floor(totalSec/3600),mm=Math.floor((totalSec%3600)/60),ss=totalSec%60;
  const durStr=`${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}`;
  const distKm=(recorder.totalDist/1000).toFixed(2);
  const sumEl = document.getElementById('rec-summary');
  if (sumEl) {
    sumEl.innerHTML = [
      `⏱ <b>${durStr}</b>`,
      `📏 <b>${distKm} km</b>`,
      `📍 <b>${recorder.points.length}</b> GPS-Punkte`,
    ].map(s=>`<span style="margin-right:10px">${s}</span>`).join('');
  }

  document.getElementById('rec-save-section').style.display='';
  // Share-Button nur anzeigen wenn Web Share API verfügbar
  const rsb=document.getElementById('rec-share-btn');
  if(rsb) rsb.style.display=(navigator.share||navigator.canShare)?'':'none';
  LS.del(LS.K.REC); // Autosave löschen (erfolgreich beendet)
  toast(`✅ Aufnahme beendet · ${recorder.points.length} Punkte`);
  speak(`Aufnahme beendet. ${recorder.points.length} GPS-Punkte. ${distKm} Kilometer. Dauer: ${durStr}.`, true);
}

function recReset(){
  if(recorder.watchId!==null){navigator.geolocation.clearWatch(recorder.watchId);recorder.watchId=null;}
  clearInterval(recorder._timerInt);   recorder._timerInt=null;
  clearInterval(recorder._persistInt); recorder._persistInt=null;
  _recReleaseWakeLock();
  _recGpsErrors = 0;
  if(recorder.previewLine){map.removeLayer(recorder.previewLine);recorder.previewLine=null;}
  recorder.isRecording=false;recorder.isPaused=false;
  recorder.points=[];recorder.elapsed=0;recorder.totalDist=0;recorder._segStart=null;recorder._lastPos=null;
  document.getElementById('rec-bar').classList.remove('show');
  document.getElementById('rec-save-section').style.display='none';
  document.getElementById('rec-name-inp').value='';
  const ni = document.getElementById('rec-notes-inp'); if(ni) ni.value='';
  const rb = document.getElementById('rec-rider-bar'); if(rb) rb.style.display='none';
  document.getElementById('rec-timer').textContent='00:00:00';
  document.getElementById('rec-dist').textContent='0.0';
  document.getElementById('rec-pts').textContent='0';
  document.getElementById('rec-speed').textContent='0.0';
  recUpdateUI();
  document.getElementById('rec-status-txt').textContent='Bereit';
  document.getElementById('rec-status-txt').style.color='var(--tm)';
  LS.del(LS.K.REC);
  toast('🗑 Aufnahme verworfen');
}

function recUpdateUI(){
  const s=recorder.isRecording;
  document.getElementById('rec-start-btn').style.display=s?'none':'';
  document.getElementById('rec-pause-btn').style.display=s?'':'none';
  document.getElementById('rec-stop-btn').style.display=s?'':'none';
  document.getElementById('rec-status-txt').textContent=s?'Aufnahme läuft':'Bereit';
  document.getElementById('rec-status-txt').style.color=s?'#ef4444':'var(--tm)';
}

function recTickDisplay(){
  let display=recorder.elapsed;
  if(recorder.isRecording&&!recorder.isPaused&&recorder._segStart!==null)
    display+=(Date.now()-recorder._segStart);
  const totalSec=Math.floor(display/1000);
  const hh=Math.floor(totalSec/3600),mm=Math.floor((totalSec%3600)/60),ss=totalSec%60;
  const str=`${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}`;
  document.getElementById('rec-timer').textContent=str;
  document.getElementById('rec-bar-txt').textContent=str;
  if(recorder.points.length>0){
    const last=recorder.points[recorder.points.length-1];
    document.getElementById('rec-speed').textContent=((last.speed||0)*3.6).toFixed(1);
  }
}

// ── AUFNAHME SPEICHERN ─────────────────────────────────────────
function recBuildGpxString(name, notes){
  const pts=recorder.points.map(p=>`    <trkpt lat="${p.lat.toFixed(7)}" lon="${p.lng.toFixed(7)}">\n      <ele>${(p.ele||0).toFixed(1)}</ele>\n      <time>${p.time}</time>\n    </trkpt>`).join('\n');
  const prof   = LS.get(LS.K.PROFILE, {});
  const rider  = [prof.name, prof.muniName].filter(Boolean).join(' · ');
  const km     = (recorder.totalDist/1000).toFixed(2);
  const notesStr = notes ? `\n${escXml(notes)}` : '';
  const descStr  = `Aufgezeichnet mit GMTW Trail Map · ${km} km${rider?' · '+escXml(rider):''}${notesStr}`;
  return `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="GMTW Trail Map" xmlns="http://www.topografix.com/GPX/1/1">
  <metadata><name>${escXml(name)}</name><time>${new Date().toISOString()}</time></metadata>
  <trk><name>${escXml(name)}</name>
    <desc>${descStr}</desc>
    <trkseg>\n${pts}\n    </trkseg>
  </trk>
</gpx>`;
}

function recAddToMap(){
  if(!recorder.points.length){toast('⚠️ Keine Punkte aufgezeichnet');return;}
  const nameVal = document.getElementById('rec-name-inp').value.trim();
  const today   = new Date().toISOString().slice(0,10);
  const name    = nameVal || `GMTW Aufnahme ${today}`;
  const cat     = document.getElementById('rec-save-cat').value;
  const notesEl = document.getElementById('rec-notes-inp');
  const notes   = notesEl ? notesEl.value.trim() : '';
  const gpxStr  = recBuildGpxString(name, notes);
  loadGpxFromString(gpxStr, name, cat);
  // Preview-Linie entfernen (wird durch GPX-Layer ersetzt)
  if(recorder.previewLine){map.removeLayer(recorder.previewLine);recorder.previewLine=null;}
  // Recorder zurücksetzen
  recorder.points=[];recorder.elapsed=0;recorder.totalDist=0;recorder._segStart=null;
  document.getElementById('rec-save-section').style.display='none';
  document.getElementById('rec-name-inp').value='';
  if(notesEl) notesEl.value='';
  const rb = document.getElementById('rec-rider-bar'); if(rb) rb.style.display='none';
  document.getElementById('rec-timer').textContent='00:00:00';
  document.getElementById('rec-dist').textContent='0.0';
  document.getElementById('rec-pts').textContent='0';
  recUpdateUI();
  document.getElementById('rec-status-txt').textContent='Bereit';
  document.getElementById('rec-status-txt').style.color='var(--tm)';
  LS.del(LS.K.REC);
  toast(`✅ "${escHtml(name)}" zur Karte hinzugefügt!`);
  setTimeout(()=>switchGpxTab('tracks',document.querySelector('.gpx-tab[data-tab="tracks"]')),400);
}

function recExportGpx(){
  if(!recorder.points.length){toast('⚠️ Keine Punkte zum Speichern');return;}
  const name    = document.getElementById('rec-name-inp').value.trim()||'GMTW_Track';
  const notesEl = document.getElementById('rec-notes-inp');
  const notes   = notesEl ? notesEl.value.trim() : '';
  dlFile(name+'.gpx',recBuildGpxString(name,notes),'application/gpx+xml');
  toast('⬇ GPX gespeichert!');
}

function recExportJson(){
  if(!recorder.points.length){toast('⚠️ Keine Punkte zum Speichern');return;}
  const name=document.getElementById('rec-name-inp').value.trim()||'GMTW_Track';
  dlFile(name+'.json',JSON.stringify({name,creator:'GMTW Trail Map',created:new Date().toISOString(),stats:{points:recorder.points.length,distanceKm:(recorder.totalDist/1000).toFixed(3),elapsedMs:recorder.elapsed},points:recorder.points},null,2),'application/json');
  toast('⬇ JSON gespeichert!');
}

// Web Share API — Aufgezeichnete Strecke als GPX-Datei teilen
async function recShareGpx(){
  if(!recorder.points.length){toast('⚠️ Keine Punkte aufgezeichnet');return;}
  const name    = document.getElementById('rec-name-inp').value.trim()||'GMTW_Track';
  const notesEl = document.getElementById('rec-notes-inp');
  const notes   = notesEl ? notesEl.value.trim() : '';
  const gpxStr  = recBuildGpxString(name, notes);
  await _shareGpxFile(gpxStr, name, `${recorder.points.length} Punkte · ${(recorder.totalDist/1000).toFixed(2)} km`);
}

// Gemeinsame Funktion: GPX-Datei per Web Share API teilen (mit Fallback)
async function _shareGpxFile(gpxStr, name, subtitle){
  const safeName = name.replace(/[^a-zA-Z0-9_\-äöüÄÖÜß ]/g,'').trim() || 'GMTW_Track';
  const fileName  = safeName.replace(/\s+/g,'_') + '.gpx';
  // Web Share API Level 2: Datei-Sharing
  if(navigator.canShare){
    const file = new File([gpxStr], fileName, {type:'application/gpx+xml'});
    if(navigator.canShare({files:[file]})){
      try{
        await navigator.share({
          title: `GMTW – ${safeName}`,
          text:  subtitle || 'Aufgezeichnet mit GMTW Trail Map',
          files: [file]
        });
        toast('✅ Geteilt!');
        return;
      } catch(e){
        if(e.name==='AbortError') return; // Nutzer hat abgebrochen
        console.warn('Web Share files failed:', e);
      }
    }
  }
  // Fallback: normales Share ohne Datei (nur Text/URL)
  if(navigator.share){
    try{
      await navigator.share({
        title: `GMTW – ${safeName}`,
        text:  `${subtitle || 'GPX Track'} — Lade die GPX-Datei in der GMTW Trail Map App.`,
        url:   window.location.href
      });
      toast('✅ Link geteilt (Datei-Sharing nicht unterstützt)');
      return;
    } catch(e){
      if(e.name==='AbortError') return;
    }
  }
  // Letzter Fallback: direkt herunterladen
  dlFile(fileName, gpxStr, 'application/gpx+xml');
  toast('⬇ GPX heruntergeladen (Teilen nicht verfügbar)');
}

// Share-Buttons anzeigen wenn Web Share API verfügbar ist
function _initShareButtons(){
  if(navigator.share || navigator.canShare){
    const recBtn = document.getElementById('rec-share-btn');
    if(recBtn) recBtn.style.display='';
    const trkBtn = document.getElementById('trk-qr-share-btn');
    if(trkBtn) trkBtn.style.display='';
  }
}
// Beim Start prüfen und nach jedem Track-QR-Öffnen
document.addEventListener('DOMContentLoaded', _initShareButtons);

function dlFile(filename,content,mime){
  const blob=new Blob([content],{type:mime});
  const url=URL.createObjectURL(blob);
  const a=document.createElement('a');a.href=url;a.download=filename;
  document.body.appendChild(a);a.click();document.body.removeChild(a);URL.revokeObjectURL(url);
}

// ── LOKALSTORAGE: RECORDER PERSISTENZ ─────────────────────────
function persistRecorder(){
  if(recorder.points.length>0){
    LS.set(LS.K.REC,{points:recorder.points,totalDist:recorder.totalDist,elapsed:recorder.elapsed,savedAt:Date.now()});
  }
}

function restoreRecorder(){
  const saved=LS.get(LS.K.REC);
  if(!saved||!saved.points||!saved.points.length)return;
  const ageMins=Math.round((Date.now()-saved.savedAt)/60000);
  const ageTxt=ageMins<60?`${ageMins} Min`:`${Math.round(ageMins/60)} Std`;
  setTimeout(()=>{
    if(confirm(`📍 Unterbrochene Aufnahme gefunden!\n${saved.points.length} Punkte · ${(saved.totalDist/1000).toFixed(2)} km · vor ${ageTxt}\n\nWiederherstellen?`)){
      recorder.points=saved.points;
      recorder.totalDist=saved.totalDist;
      recorder.elapsed=saved.elapsed;
      recorder._lastPos=saved.points.length>0?{lat:saved.points[saved.points.length-1].lat,lng:saved.points[saved.points.length-1].lng}:null;
      if(recorder.previewLine)map.removeLayer(recorder.previewLine);
      recorder.previewLine=L.polyline(saved.points.map(p=>[p.lat,p.lng]),{color:'#ef4444',weight:3,opacity:.85,dashArray:'6 4'}).addTo(map);
      document.getElementById('rec-pts').textContent=saved.points.length;
      document.getElementById('rec-dist').textContent=(saved.totalDist/1000).toFixed(2);
      document.getElementById('rec-save-section').style.display='';
      document.getElementById('rec-status-txt').textContent=`Wiederhergestellt · ${saved.points.length} Punkte`;
      document.getElementById('rec-status-txt').style.color='var(--ac)';
      toast(`✅ ${saved.points.length} Punkte wiederhergestellt`);
      openGpxPanel('rec');
    } else {
      LS.del(LS.K.REC);
    }
  },1800);
}

// ── BEFOREUNLOAD SAFETY NET ────────────────────────────────────
window.addEventListener('beforeunload',e=>{
  if(recorder.isRecording&&recorder.points.length>0){
    persistRecorder();
    e.preventDefault();
    e.returnValue=`Aufnahme läuft! ${recorder.points.length} GPS-Punkte werden gespeichert.`;
    return e.returnValue;
  }
  if(!recorder.isRecording&&recorder.points.length>0) persistRecorder();
});
// Autosave alle 15 Sekunden
setInterval(()=>{if(recorder.isRecording&&recorder.points.length>0)persistRecorder();},15000);

// leaflet-gpx ist inline eingebettet — kein Fallback nötig

// ══════════════════════════════════════════════════════════════
// ── START MARKERS ─────────────────────────────────────────────
// Sichtbarer Startpunkt-Marker jedes Tracks — Klick öffnet Detail-Panel
// Vollständig unabhängig vom GPX-Recorder!
// ══════════════════════════════════════════════════════════════

// ── START / FINISH MARKERS ─────────────────────────────────────
// Rich Leaflet popup: Name, GPS-Koordinaten, Navigation, Timing, QR, Details

function _buildTrackPopup(track, isFinish) {
  const pts  = _getGpxPoints(track.gpxLayer, track.gpxString);
  if (!pts.length) return null;
  const pt   = isFinish ? pts[pts.length - 1] : pts[0];
  const cat  = { beginner:'Beginner', mittel:'Mittel', expert:'Expert' }[track.cat] || track.cat;
  const stat = `${track.stats.dist} km · ${track.stats.dur || '—'}`;
  const lbl  = isFinish ? 'Ziel' : 'Start';

  const popHtml = `
    <div class="tpop">
      <div class="tpop-badge" style="background:${track.color}">${escHtml(cat)}</div>
      <div class="tpop-name">${escHtml(track.name)}</div>
      <div class="tpop-meta">${lbl} · ${escHtml(stat)}</div>
      <div class="tpop-gps" title="Koordinaten kopieren" onclick="navigator.clipboard?.writeText('${pt.lat.toFixed(6)},${pt.lng.toFixed(6)}').then(()=>toast('📋 Kopiert'))">
        📍 ${pt.lat.toFixed(5)}, ${pt.lng.toFixed(5)}
      </div>
    </div>
    <hr class="tpop-sep">
    <div class="tpop-acts">
      <button class="tpop-btn navi" onclick="map.closePopup();startNavigation('${track.id}')">🧭 Navigation</button>
      <button class="tpop-btn race" onclick="map.closePopup();beginPreRace('${track.id}')">⏱ Timing</button>
      <button class="tpop-btn sec"  onclick="map.closePopup();openTrackQR('${track.id}')">📲 QR</button>
      <button class="tpop-btn sec"  onclick="map.closePopup();openGpxPanel('tracks');setTimeout(()=>openTrackDetail('${track.id}'),180)">📋 Details</button>
      <button class="tpop-btn spk"  onclick="speakTrackPopup('${track.id}',${isFinish})" style="grid-column:span 2" aria-label="Vorlesen">🔊 Vorlesen</button>
    </div>`;
  return L.popup({ className:'trk-popup-wrap', maxWidth:272, minWidth:230, offset:[0,-28] }).setContent(popHtml);
}

// ── Start/Finish Pin Icons mit Skalierung ─────────────────────
// Baut ein skalierbares Leaflet-divIcon für Start-Marker
function _buildStartPinIcon(track) {
  const sc  = _markerScale;
  const w   = Math.round(26 * sc);
  const h   = Math.round(32 * sc);
  const fs  = Math.round(13 * sc);
  const brd = Math.max(1.5, Math.round(25 * sc) / 10); // 2.5px bei 100%
  const html = `<div class="start-pin" style="width:${w}px;height:${h}px;background:${track.color};border-width:${brd}px" title="Start: ${esc(track.name)}">` +
               `<span class="start-pin-flag" style="font-size:${fs}px">▶</span></div>`;
  return L.divIcon({ className:'', html, iconSize:[w, h], iconAnchor:[Math.round(w/2), h] });
}

// Baut ein skalierbares Leaflet-divIcon für Ziel-Marker
function _buildFinishPinIcon(track) {
  const sc  = _markerScale;
  const w   = Math.round(26 * sc);
  const h   = Math.round(32 * sc);
  const fs  = Math.round(13 * sc);
  const brd = Math.max(1.5, Math.round(25 * sc) / 10);
  const html = `<div class="finish-pin" style="width:${w}px;height:${h}px;border-color:${track.color};border-width:${brd}px" title="Ziel: ${esc(track.name)}">` +
               `<span class="finish-pin-flag" style="font-size:${fs}px">🏁</span></div>`;
  return L.divIcon({ className:'', html, iconSize:[w, h], iconAnchor:[Math.round(w/2), h] });
}

// Aktualisiert Icons aller vorhandenen Start/Ziel-Marker (bei Skalierungsänderung)
function _updateAllStartFinishMarkerIcons() {
  trackStore.tracks.forEach(track => {
    if (!track.gpxLayer) return;
    if (track._startMkr)  track._startMkr.setIcon(_buildStartPinIcon(track));
    if (track._finishMkr) track._finishMkr.setIcon(_buildFinishPinIcon(track));
  });
}

function _addStartMarker(track) {
  try {
    const pts = _getGpxPoints(track.gpxLayer, track.gpxString);
    if (!pts.length) return;
    const sp    = pts[0];
    const icon  = _buildStartPinIcon(track);
    const popup = _buildTrackPopup(track, false);

    const mkr = L.marker([sp.lat, sp.lng], { icon, zIndexOffset:800, title:`Start: ${track.name}` })
      // --- Dauerhaftes Label unter dem Marker ---
      .bindTooltip(track.name, { permanent: true, direction: 'bottom', offset: [0, 4], className: 'map-label' })
      // -----------------------------------------------
      .addTo(map);

    if (popup) mkr.bindPopup(popup);
    track._startMkr = mkr;
  } catch(e) { console.warn('_addStartMarker error:', e); }
}

function _addFinishMarker(track) {
  try {
    const pts = _getGpxPoints(track.gpxLayer, track.gpxString);
    if (pts.length < 2) return;
    const fp = pts[pts.length - 1];
    // Rundkurs: kein separater Ziel-Marker wenn Start und Ziel zu nah
    const distSF = _distM(pts[0].lat, pts[0].lng, fp.lat, fp.lng);
    if (distSF < 30) return;

    const icon  = _buildFinishPinIcon(track);
    const popup = _buildTrackPopup(track, true);
    const mkr   = L.marker([fp.lat, fp.lng], { icon, zIndexOffset:799, title:`Ziel: ${track.name}` })
      .addTo(map);
    if (popup) mkr.bindPopup(popup);
    track._finishMkr = mkr;
  } catch(e) { console.warn('_addFinishMarker error:', e); }
}

function _removeStartMarker(track) {
  if (track && track._startMkr) {
    try { map.removeLayer(track._startMkr); } catch(e) {}
    track._startMkr = null;
  }
}

function _removeFinishMarker(track) {
  if (track && track._finishMkr) {
    try { map.removeLayer(track._finishMkr); } catch(e) {}
    track._finishMkr = null;
  }
}

// ══════════════════════════════════════════════════════════════
// ── NAVIGATION ENGINE ─────────────────────────────────────────
// ══════════════════════════════════════════════════════════════
const NAV = {
  active:          false,
  trackId:         null,
  startPt:         null,     // {lat,lng} - target start point
  trackPts:        [],       // full GPX points [{lat,lng},...]
  routeLine:       null,     // Leaflet polyline user→target
  mode:            'to-start', // 'to-start' | 'on-track'
  _prevDist:       null,     // for wrong-direction detection
  _offRouteCnt:    0,        // consecutive off-route GPS fixes
  _lastBear:       0,        // for arrow rotation (smooth)
  _heading:        null,     // user's estimated travel heading (from GPS fixes)
  _prevLat:        null,
  _prevLng:        null,
  _lastTurnSpeak:  null,     // 'left'|'right'|null — prevents repeat TTS announcements
};

// Bearing from A to B in degrees [0-360]
function _bearing(lat1,lon1,lat2,lon2){
  const dLon=(lon2-lon1)*Math.PI/180;
  const φ1=lat1*Math.PI/180, φ2=lat2*Math.PI/180;
  const y=Math.sin(dLon)*Math.cos(φ2);
  const x=Math.cos(φ1)*Math.sin(φ2)-Math.sin(φ1)*Math.cos(φ2)*Math.cos(dLon);
  return((Math.atan2(y,x)*180/Math.PI)+360)%360;
}
// Haversine distance in meters
function _distM(lat1,lon1,lat2,lon2){
  const R=6371000, dLat=(lat2-lat1)*Math.PI/180, dLon=(lon2-lon1)*Math.PI/180;
  const a=Math.sin(dLat/2)**2+Math.cos(lat1*Math.PI/180)*Math.cos(lat2*Math.PI/180)*Math.sin(dLon/2)**2;
  return R*2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));
}
// Bearing arrow emoji
function _bearingArrow(deg){
  const dirs=['↑','↗','→','↘','↓','↙','←','↖'];
  return dirs[Math.round(deg/45)%8];
}
// Human-readable distance
function _fmtDist(m){
  return m>=1000?`${(m/1000).toFixed(1)} km`:`${Math.round(m)} m`;
}
// Format ms as mm:ss.t
function _fmtTime(ms, tenths=true){
  if(ms==null||isNaN(ms))return'—';
  const neg=ms<0;ms=Math.abs(ms);
  const mins=Math.floor(ms/60000);
  const secs=Math.floor((ms%60000)/1000);
  const t=Math.floor((ms%1000)/100);
  let s=(neg?'-':'')+(mins<10?'0':'')+mins+':'+(secs<10?'0':'')+secs;
  if(tenths)s+='.'+t;
  return s;
}

// Extrahiert alle {lat,lng}-Punkte aus einem GPX-Layer.
// Primär: Leaflet-Layer-Geometrie. Fallback: DOMParser auf gpxString.
// gpxString ist optional — wird nur für den Fallback benötigt.
function _getGpxPoints(gpxLayer, gpxString) {
  const pts = [];

  // Primär: Leaflet eachLayer — flacht ggf. verschachtelte Segmente ab
  try {
    gpxLayer.eachLayer(layer => {
      if (layer.getLatLngs) {
        const raw = layer.getLatLngs();
        // Polyline kann [[LatLng,...]] (multi-segment) oder [LatLng,...] sein
        const segs = (Array.isArray(raw) && raw.length && Array.isArray(raw[0])) ? raw : [raw];
        segs.forEach(seg => seg.forEach(ll => {
          if (ll && typeof ll.lat === 'number' && typeof ll.lng === 'number')
            pts.push({ lat: ll.lat, lng: ll.lng });
        }));
      }
    });
  } catch(e) { console.warn('_getGpxPoints layer error:', e); }

  // Fallback: DOMParser auf GPX-XML wenn Layer nichts liefert
  if (pts.length === 0 && gpxString) {
    try {
      const doc = new DOMParser().parseFromString(gpxString, 'text/xml');
      // trkpt (Tracks) + rtept (Routen) berücksichtigen
      doc.querySelectorAll('trkpt, rtept').forEach(pt => {
        const lat = parseFloat(pt.getAttribute('lat'));
        const lon = parseFloat(pt.getAttribute('lon'));
        if (!isNaN(lat) && !isNaN(lon)) pts.push({ lat, lng: lon });
      });
    } catch(e) { console.warn('_getGpxPoints DOMParser error:', e); }
  }

  return pts; // [{lat, lng}, ...]
}

// Compute 3 checkpoints + 1 finish using Turf.js lineChunk
function _computeCheckpoints(pts) {
  if (!window.turf || pts.length < 2) return null;
  const coords = pts.map(p => [p.lng, p.lat]); // turf uses [lng,lat]
  const line = turf.lineString(coords);
  const totalKm = turf.length(line, {units:'kilometers'});
  if (totalKm < 0.05) return null; // too short
  const segKm = totalKm / 4;
  const cps = [];
  for (let i = 1; i <= 4; i++) {
    const pt = turf.along(line, segKm * i, {units:'kilometers'});
    cps.push({
      lat: pt.geometry.coordinates[1],
      lng: pt.geometry.coordinates[0],
      isFinish: i === 4,
      label: i === 4 ? 'Ziel' : `S${i}`
    });
  }
  return {checkpoints:cps, totalKm};
}

// Draw start line perpendicular to track (6m wide)
function _drawStartLine(startPt, secondPt) {
  if (!window.turf) return null;
  const bearing = turf.bearing(
    turf.point([startPt.lng, startPt.lat]),
    turf.point([secondPt.lng, secondPt.lat])
  );
  const left  = turf.destination(turf.point([startPt.lng, startPt.lat]), 0.003, bearing - 90, {units:'kilometers'});
  const right = turf.destination(turf.point([startPt.lng, startPt.lat]), 0.003, bearing + 90, {units:'kilometers'});
  const lLatLng = [left.geometry.coordinates[1],  left.geometry.coordinates[0]];
  const rLatLng = [right.geometry.coordinates[1], right.geometry.coordinates[0]];
  return L.polyline([lLatLng, rLatLng], {
    color:'#c8ff00', weight:5, opacity:.9, dashArray:null
  }).addTo(map);
}

/**
 * Startet die Navigation zum Startpunkt einer Strecke.
 * Zeigt das HUD, aktiviert GPS, zeichnet die Verbindungslinie.
 */
async function startNavigation(trackId) {
  const t = trackStore.tracks.find(t => t.id === trackId);
  if (!t) return;
  const pts = _getGpxPoints(t.gpxLayer, t.gpxString);
  if (!pts.length) { toast('⚠️ Track hat keine Koordinaten'); return; }

  stopNavigation(false); // Vorherige Navigation stoppen

  // NAV-State initialisieren
  Object.assign(NAV, {
    active: true, trackId, startPt: pts[0], trackPts: pts,
    mode: 'to-start', routeLine: null,
    _prevDist: null, _offRouteCnt: 0, _lastBear: 0,
    _heading: null, _prevLat: null, _prevLng: null, _lastTurnSpeak: null,
  });

  // HUD befüllen und anzeigen
  const gmUrl = `https://www.google.com/maps/dir/?api=1&destination=${pts[0].lat},${pts[0].lng}&travelmode=bicycling`;
  const hud = document.getElementById('nav-hud');
  document.getElementById('nh-gmaps').href = gmUrl;
  document.getElementById('nh-title').textContent = escHtml(t.name);
  document.getElementById('nh-dist').textContent = '…';
  document.getElementById('nh-sub').textContent = 'GPS wird aktiviert…';
  document.getElementById('nh-mode-txt').textContent = 'Navigiere zum Start';
  hud.className = ''; hud.classList.add('show');

  // Zur Strecken-Start-Position fliegen
  map.flyTo([pts[0].lat, pts[0].lng], 16, {animate:true, duration:1.5});

  try {
    _gpsAutoFollow = false;
    await ensureGpsActive();
    speak('Navigation gestartet. Folge dem Pfeil zum Startpunkt.', false);
  } catch(e) {
    showGpsHint('GPS nötig', 'Erlaube Standortzugriff für die Navigation.');
    stopNavigation(false);
  }
}

function stopNavigation(showToast=true) {
  if (NAV.routeLine) { try { map.removeLayer(NAV.routeLine); } catch(e){} NAV.routeLine = null; }
  Object.assign(NAV, { active:false, trackId:null, startPt:null, trackPts:[], mode:'to-start',
    _prevDist:null, _offRouteCnt:0, _heading:null, _prevLat:null, _prevLng:null, _lastTurnSpeak:null });
  const hud = document.getElementById('nav-hud');
  if (hud) hud.classList.remove('show','nav-offroute','nav-close','nav-ontrack');
  if (showToast) toast('🛑 Navigation beendet');
}

/**
 * GPS-Update-Hook — wird bei jedem Standort-Update aufgerufen wenn Navigation aktiv.
 * Berechnet: Richtung, Distanz, Falsch-Richtungs-Warnung, Off-Route-Erkennung.
 */
function _onNavGpsUpdate(lat, lng, acc) {
  if (!NAV.active || !NAV.startPt) return;

  // ── Heading aus aufeinanderfolgenden Fixes berechnen ──────────
  if (NAV._prevLat !== null && NAV._prevLng !== null) {
    const moveDist = _distM(NAV._prevLat, NAV._prevLng, lat, lng);
    if (moveDist > 3) { // nur wenn wirklich bewegt (kein GPS-Drift)
      NAV._heading = _bearing(NAV._prevLat, NAV._prevLng, lat, lng);
    }
  }
  NAV._prevLat = lat; NAV._prevLng = lng;

  // ── Modus: Zum Startpunkt navigieren ─────────────────────────
  if (NAV.mode === 'to-start') {
    const dist = _distM(lat, lng, NAV.startPt.lat, NAV.startPt.lng);
    const bear = _bearing(lat, lng, NAV.startPt.lat, NAV.startPt.lng);

    // Distanz-Anzeige
    document.getElementById('nh-dist').textContent = _fmtDist(dist);
    document.getElementById('nh-sub').textContent  = `${Math.round(bear)}°  ±${Math.round(acc)} m`;

    // Animierter Pfeil — smooth rotation via transform
    const arrowEl = document.getElementById('nh-arrow');
    if (arrowEl) {
      // Wähle Unicode-Pfeil basierend auf Bearing
      const arrows = ['↑','↗','→','↘','↓','↙','←','↖'];
      arrowEl.textContent = arrows[Math.round(bear/45)%8];
    }

    // Falsche-Richtungs-Warnung (Distanz nimmt zu & > 20m vom Start)
    const isWrongWay = NAV._prevDist !== null && dist > NAV._prevDist + 8 && dist > 30;
    NAV._prevDist = dist;

    // Off-Route-Zähler
    if (isWrongWay) NAV._offRouteCnt = Math.min(NAV._offRouteCnt + 1, 5);
    else            NAV._offRouteCnt = Math.max(NAV._offRouteCnt - 1, 0);

    const hud = document.getElementById('nav-hud');
    const isOffRoute = NAV._offRouteCnt >= 3;
    if (hud) {
      hud.classList.toggle('nav-offroute', isOffRoute);
      hud.classList.toggle('nav-close',    dist < 30 && !isOffRoute);
      hud.classList.remove('nav-ontrack');
    }
    if (isOffRoute) {
      document.getElementById('nh-sub').textContent = '⚠️ Falsche Richtung — umkehren!';
      if (NAV._offRouteCnt === 3) speak('Falsche Richtung. Bitte umkehren.', true);
    }
    document.getElementById('nh-mode-txt').textContent =
      dist < 30 ? '🎯 Fast da!' :
      isOffRoute ? '⚠️ Falsche Richtung' :
      'Navigiere zum Start';

    // Verbindungslinie User → Start zeichnen/aktualisieren
    if (NAV.routeLine) {
      NAV.routeLine.setLatLngs([[lat,lng],[NAV.startPt.lat,NAV.startPt.lng]]);
    } else {
      NAV.routeLine = L.polyline([[lat,lng],[NAV.startPt.lat,NAV.startPt.lng]],
        {color:'#38bdf8',weight:3,opacity:.75,dashArray:'8 8'}).addTo(map);
    }

    // Auto-Übergang: Am Start angekommen → Pre-Race
    if (dist < 50 && RACE.state === 'idle' && NAV.trackId) {
      beginPreRace(NAV.trackId);
    }

  } else if (NAV.mode === 'on-track') {
    // ── Modus: Auf der Strecke fahren — nächsten Punkt anzeigen ──
    if (!NAV.trackPts.length) return;

    // Nächsten Track-Punkt finden (minimale Distanz)
    let minDist = Infinity, nearestIdx = 0;
    NAV.trackPts.forEach((p, i) => {
      const d = _distM(lat, lng, p.lat, p.lng);
      if (d < minDist) { minDist = d; nearestIdx = i; }
    });

    // Nächster Punkt in Fahrtrichtung (ca. 20m voraus)
    let nextIdx = nearestIdx;
    let cumDist = 0;
    for (let i = nearestIdx + 1; i < NAV.trackPts.length; i++) {
      cumDist += _distM(NAV.trackPts[i-1].lat, NAV.trackPts[i-1].lng, NAV.trackPts[i].lat, NAV.trackPts[i].lng);
      if (cumDist >= 20) { nextIdx = i; break; }
    }

    const target = NAV.trackPts[nextIdx] || NAV.trackPts[NAV.trackPts.length-1];
    const bear   = _bearing(lat, lng, target.lat, target.lng);
    const distToTrack = minDist;

    // Off-Route-Erkennung (> 25m von nächstem Track-Punkt)
    const offTrack = distToTrack > 25;
    if (offTrack) NAV._offRouteCnt = Math.min(NAV._offRouteCnt + 1, 6);
    else          NAV._offRouteCnt = Math.max(NAV._offRouteCnt - 1, 0);
    const isOffRoute = NAV._offRouteCnt >= 3;

    // ── Turn detection: vergleiche Track-Richtung 20m vs 50m voraus ────
    const arrowEl = document.getElementById('nh-arrow');
    if (arrowEl) {
      // Finde einen Punkt ~50m voraus für Kurvendetektion
      let farIdx = nextIdx;
      let farAccum = 0;
      for (let i = nextIdx + 1; i < NAV.trackPts.length; i++) {
        farAccum += _distM(NAV.trackPts[i-1].lat, NAV.trackPts[i-1].lng, NAV.trackPts[i].lat, NAV.trackPts[i].lng);
        if (farAccum >= 30) { farIdx = i; break; }
      }
      const nearBear = bear; // Richtung zum Punkt 20m voraus
      const farTarget = NAV.trackPts[farIdx];
      const farBear = _bearing(target.lat, target.lng, farTarget.lat, farTarget.lng);
      // Winkelunterschied -180..+180 (negativ=links, positiv=rechts)
      const turnDelta = ((farBear - nearBear) + 540) % 360 - 180;

      let turnChar = '↑'; // geradeaus
      let turnSpeak = null;
      if (!isOffRoute) {
        if      (turnDelta < -50) { turnChar = '↰'; turnSpeak = 'links';  }
        else if (turnDelta < -22) { turnChar = '↖'; }
        else if (turnDelta >  50) { turnChar = '↱'; turnSpeak = 'rechts'; }
        else if (turnDelta >  22) { turnChar = '↗'; }
      }
      arrowEl.textContent = turnChar;

      // TTS-Ansage bei Annäherung (< 25m zum nächsten Wegpunkt)
      const distToNext = _distM(lat, lng, target.lat, target.lng);
      if (turnSpeak && distToNext < 25 && NAV._lastTurnSpeak !== turnSpeak) {
        speak(turnSpeak === 'links' ? 'Links abbiegen' : 'Rechts abbiegen', false);
        NAV._lastTurnSpeak = turnSpeak;
      } else if (distToNext >= 35) {
        NAV._lastTurnSpeak = null; // Reset nach Passieren des Wegpunkts
      }
    }

    const remainingPts = NAV.trackPts.slice(nearestIdx);
    let remainDist = 0;
    for (let i = 1; i < remainingPts.length; i++) {
      remainDist += _distM(remainingPts[i-1].lat, remainingPts[i-1].lng, remainingPts[i].lat, remainingPts[i].lng);
    }

    const pct = NAV.trackPts.length > 1
      ? Math.round((nearestIdx / (NAV.trackPts.length - 1)) * 100)
      : 0;

    document.getElementById('nh-dist').textContent = _fmtDist(remainDist) + ' verbleibend';
    document.getElementById('nh-sub').textContent  = isOffRoute
      ? `⚠️ ${Math.round(distToTrack)}m von Strecke`
      : `${pct}% · ±${Math.round(acc)}m`;
    document.getElementById('nh-mode-txt').textContent = isOffRoute ? '⚠️ Neben Strecke' : '🟢 Auf Strecke';

    const hud = document.getElementById('nav-hud');
    if (hud) {
      hud.classList.toggle('nav-offroute', isOffRoute);
      hud.classList.toggle('nav-ontrack',  !isOffRoute);
      hud.classList.remove('nav-close');
    }
    if (isOffRoute && NAV._offRouteCnt === 3) {
      speak(`Achtung, du bist ${Math.round(distToTrack)} Meter von der Strecke entfernt.`, true);
    }

    // Finish erkennen
    if (nearestIdx >= NAV.trackPts.length - 3) {
      document.getElementById('nh-mode-txt').textContent = '🏁 Fast am Ziel!';
    }
  }
}

/** Wechselt zwischen "Zum Start" und "Auf Strecke"-Modus */
function _switchNavMode(mode) {
  if (!NAV.active) return;
  NAV.mode = mode;
  NAV._prevDist = null;
  NAV._offRouteCnt = 0;
  NAV._lastTurnSpeak = null;
  const hud = document.getElementById('nav-hud');
  if (hud) hud.classList.remove('nav-offroute','nav-close','nav-ontrack');
  const modeNames = { 'to-start':'Navigiere zum Start', 'on-track':'Strecke verfolgen' };
  document.getElementById('nh-mode-txt').textContent = modeNames[mode] || mode;
  if (NAV.routeLine) { try { map.removeLayer(NAV.routeLine); } catch(e){} NAV.routeLine = null; }
}

// ══════════════════════════════════════════════════════════════
// ── RACE SENSOR FUSION & HELPERS ───────────────────────────────
// ══════════════════════════════════════════════════════════════

// Motion sensor state shared across all race functions
const SENSORS = {
  motionActive: false,
  _handler: null,
  ax: 0, ay: 0, az: 0,       // accelerometer (m/s²) incl. gravity
  gx: 0, gy: 0, gz: 0,       // gyroscope (deg/s)
  accelMag: 9.81,             // current total acceleration magnitude
  _lastImpactTs: 0,           // performance.now() of last impact spike
  _checkFallTimer: null       // timer to confirm fall ~400ms after impact
};

function _startMotionSensors() {
  if (SENSORS.motionActive || !window.DeviceMotionEvent) return;
  SENSORS._handler = _onDeviceMotion;
  window.addEventListener('devicemotion', SENSORS._handler, {passive:true});
  SENSORS.motionActive = true;
  // iOS 13+ requires explicit permission prompt
  if (typeof DeviceMotionEvent.requestPermission === 'function') {
    DeviceMotionEvent.requestPermission().catch(() => {});
  }
  _updateRaceSensorBadges();
}

function _stopMotionSensors() {
  if (!SENSORS.motionActive) return;
  if (SENSORS._handler) { window.removeEventListener('devicemotion', SENSORS._handler); SENSORS._handler = null; }
  if (SENSORS._checkFallTimer) { clearTimeout(SENSORS._checkFallTimer); SENSORS._checkFallTimer = null; }
  SENSORS.motionActive = false;
}

function _onDeviceMotion(e) {
  if (RACE.state !== 'racing') return;
  const a = e.accelerationIncludingGravity;
  if (!a) return;
  SENSORS.ax = a.x || 0; SENSORS.ay = a.y || 0; SENSORS.az = a.z || 0;
  if (e.rotationRate) {
    SENSORS.gx = e.rotationRate.alpha || 0;
    SENSORS.gy = e.rotationRate.beta  || 0;
    SENSORS.gz = e.rotationRate.gamma || 0;
  }
  const mag = Math.sqrt(SENSORS.ax**2 + SENSORS.ay**2 + SENSORS.az**2);
  SENSORS.accelMag = mag;
  // Impact detection: spike > 35 m/s² (≈ 3.5G) — likely crash/hard landing
  const now = performance.now();
  if (mag > 35 && now - SENSORS._lastImpactTs > 2500) {
    SENSORS._lastImpactTs = now;
    if (SENSORS._checkFallTimer) clearTimeout(SENSORS._checkFallTimer);
    // Confirm 400ms later: if still low-G → lying still → fall confirmed
    SENSORS._checkFallTimer = setTimeout(() => {
      SENSORS._checkFallTimer = null;
      if (SENSORS.accelMag < 4 && RACE.state === 'racing') _recordFallEvent('fall');
    }, 400);
  }
}

function _recordFallEvent(type) {
  const now = performance.now();
  if (now - RACE._lastFallTs < 3000) return; // throttle: max 1 event per 3 s
  RACE._lastFallTs = now;
  const evt = {
    type,
    ts:  RACE.startTs ? Math.round(now - RACE.startTs) : 0,
    lat: RACE._lastLat,
    lng: RACE._lastLng
  };
  RACE.fallEvents.push(evt);
  if (navigator.vibrate) navigator.vibrate([60, 60, 60]);
  // Show badge in running page
  const row = document.getElementById('rr-fall-row');
  if (row) {
    const badge = document.createElement('span');
    badge.className = 'rr-fall-badge';
    badge.textContent = type === 'fall'
      ? `💥 Sturz ${_fmtTime(evt.ts)}`
      : `🚶 Absteigen ${_fmtTime(evt.ts)}`;
    if (row.children.length >= 2) row.removeChild(row.firstChild);
    row.appendChild(badge);
  }
  if (RACE._backgroundMode) toast(type === 'fall' ? '💥 Sturz erkannt!' : '🚶 Absteigen erkannt!');
}

function _updateRaceSensorBadges() {
  const gpsBadge    = document.getElementById('ra-sensor-gps');
  const motionBadge = document.getElementById('ra-sensor-motion');
  const btBadge     = document.getElementById('ra-sensor-bt');
  if (gpsBadge) {
    const acc = RACE._lastAcc;
    const ok  = acc != null && acc < 20;
    gpsBadge.className = 'ra-sensor-badge' + (acc != null ? (ok ? ' ok' : ' warn') : '');
    gpsBadge.textContent = acc != null ? `📍 GPS ±${Math.round(acc)}m` : '📍 GPS –';
  }
  if (motionBadge) {
    motionBadge.className = 'ra-sensor-badge' + (SENSORS.motionActive ? ' ok' : '');
    motionBadge.textContent = SENSORS.motionActive ? '📐 Sensor ✓' : '📐 Sensor –';
  }
  if (btBadge) {
    const btGpsFresh = RACE.btGpsLat != null && (performance.now() - RACE.btGpsTs) < 3000;
    btBadge.className = 'ra-sensor-badge' + (RACE.btDevice ? (btGpsFresh ? ' ok' : ' warn') : '');
    btBadge.textContent = RACE.btDevice ? (btGpsFresh ? '🔵 BT GPS ✓' : '🔵 BT verbunden') : '🔵 BT –';
  }
}

// ── WEB BLUETOOTH SMARTWATCH GPS INTEGRATION ───────────────────
async function _connectSmartwatch() {
  if (!navigator.bluetooth) { toast('⚠️ Web Bluetooth nicht unterstützt'); return; }
  try {
    toast('🔵 Suche Bluetooth-Gerät…');
    const device = await navigator.bluetooth.requestDevice({
      acceptAllDevices: true,
      optionalServices: [0x1819, 0x1816, 0x180D, 'location_and_navigation',
                         'cycling_speed_and_cadence', 'heart_rate']
    });
    RACE.btDevice = device;
    const server = await device.gatt.connect();
    RACE.btServer = server;
    toast(`🔵 ${device.name || 'Gerät'} verbunden`);
    _updateRaceSensorBadges();
    // Try Location & Navigation service (0x1819) for GPS
    try {
      const svc     = await server.getPrimaryService(0x1819);
      const locChar = await svc.getCharacteristic(0x2A67).catch(() => null);
      if (locChar) {
        await locChar.startNotifications();
        locChar.addEventListener('characteristicvaluechanged', _onBtLocationUpdate);
        toast('🔵 Smartwatch GPS aktiv 🛰');
        _updateRaceSensorBadges();
      }
    } catch(e) { /* Location service not available on this device */ }
    device.addEventListener('gattserverdisconnected', () => {
      RACE.btDevice = null; RACE.btServer = null;
      RACE.btGpsLat = null; RACE.btGpsLng = null;
      toast('🔵 Bluetooth getrennt');
      _updateRaceSensorBadges();
    });
  } catch(e) {
    if (e.name !== 'NotFoundError') toast('🔵 BT Fehler: ' + e.message);
  }
}

function _onBtLocationUpdate(e) {
  const v = e.target.value;
  if (!v || v.byteLength < 4) return;
  const flags = v.getUint16(0, true);
  let off = 2;
  if (flags & 0x02) off += 2; // Instantaneous Speed present
  if (flags & 0x04) off += 3; // Total Distance present
  if ((flags & 0x08) && v.byteLength >= off + 8) {
    const lat = v.getInt32(off, true) * 1e-7;
    const lng = v.getInt32(off + 4, true) * 1e-7;
    if (Math.abs(lat) <= 90 && Math.abs(lng) <= 180) {
      RACE.btGpsLat = lat; RACE.btGpsLng = lng; RACE.btGpsTs = performance.now();
      _updateRaceSensorBadges();
    }
  }
}

// ── CRYPTOGRAPHIC HMAC-SHA256 RESULT SIGNING ───────────────────
async function _signRaceResult(run) {
  if (!window.crypto || !crypto.subtle) return 'unsigned';
  try {
    // Day-specific rotating key — makes signature valid only for its creation date
    const secret = 'GMTW26-RACE-' + run.date.slice(0, 10);
    const key = await crypto.subtle.importKey(
      'raw', new TextEncoder().encode(secret),
      {name:'HMAC', hash:'SHA-256'}, false, ['sign']
    );
    const payload = JSON.stringify({
      trackId: run.trackId,
      date:    run.date,
      totalMs: Math.round(run.totalMs),
      splits:  run.splits.map(s => Math.round(s)),
      rider:   run.riderName || '',
      muni:    run.muniName  || ''
    });
    const buf = await crypto.subtle.sign('HMAC', key, new TextEncoder().encode(payload));
    return Array.from(new Uint8Array(buf)).map(b => b.toString(16).padStart(2,'0')).join('').slice(0, 24);
  } catch(e) { return 'unsigned'; }
}

// ── GPX TRACK BUILDER FOR RECORDED RACE ────────────────────────
function _buildRaceGpx(run) {
  if (!run.gpsTrack || run.gpsTrack.length < 2) return null;
  const startWallMs = new Date(run.date).getTime() - run.totalMs;
  const pts = run.gpsTrack.map(p => {
    const wt = new Date(startWallMs + (p.ts || 0)).toISOString();
    let pt = `    <trkpt lat="${p.lat.toFixed(7)}" lon="${p.lng.toFixed(7)}">\n`;
    if (p.alt != null)   pt += `      <ele>${p.alt.toFixed(1)}</ele>\n`;
    pt += `      <time>${wt}</time>\n`;
    if (p.speed != null) pt += `      <extensions><gpxtpx:speed>${p.speed.toFixed(2)}</gpxtpx:speed></extensions>\n`;
    pt += `    </trkpt>`;
    return pt;
  }).join('\n');
  const safeNm  = (run.trackName || 'Lauf').replace(/[<>&"]/g, '_');
  const dateStr = new Date(run.date).toLocaleDateString('de');
  return `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="GMTW Trail Map 2026"
  xmlns="http://www.topografix.com/GPX/1/1"
  xmlns:gpxtpx="http://www.garmin.com/xmlschemas/TrackPointExtension/v1">
  <trk>
    <name>${safeNm} — Lauf ${dateStr}</name>
    <desc>Gesamtzeit: ${_fmtTime(run.totalMs)} | Stuerze: ${(run.fallEvents||[]).length} | Sig: ${run.signature||'?'}</desc>
    <trkseg>
${pts}
    </trkseg>
  </trk>
</gpx>`;
}

function exportRaceGpx() {
  const run = RACE.lastRunData;
  if (!run || !run.gpsTrack || run.gpsTrack.length < 2) {
    toast('⚠️ Kein GPS-Track aufgezeichnet'); return;
  }
  const gpx = _buildRaceGpx(run);
  if (!gpx) { toast('⚠️ GPX-Generierung fehlgeschlagen'); return; }
  const nm = (run.trackName || 'lauf').replace(/[^a-zA-Z0-9_-]/g, '_');
  dlFile(`${nm}_lauf_${new Date().toISOString().slice(0,10)}.gpx`, gpx, 'application/gpx+xml');
  toast('⬇ Lauf-GPX exportiert');
}

// ══════════════════════════════════════════════════════════════
// ── RACE STATE MACHINE ─────────────────────────────────────────
// ══════════════════════════════════════════════════════════════
const RACE = {
  state: 'idle',     // idle|approaching|at_line|go|racing|finished
  trackId: null,
  trackName: '',
  startPt: null,     // {lat,lng}
  startLine: null,   // Leaflet polyline
  checkpoints: [],   // [{lat,lng,isFinish,label}]
  cpMarkers: [],     // Leaflet markers on map
  nextCpIdx: 0,      // which checkpoint to watch next
  totalKm: 0,        // total track length in km

  // Timing (all in ms)
  startTs: null,         // performance.now() at race start
  startWallTs: null,     // Date.now() at race start (wall clock for signing)
  splitTimes: [],        // [ms] elapsed per split (up to 4)
  splitTimestamps: [],   // wall-clock Date.now() at each split crossing
  lastSplitTs: null,

  // GPS track recording during race
  gpsTrack: [],          // [{lat,lng,alt,ts,speed,acc}] recorded during race
  _lastLat: null,        // last GPS lat (for fall events)
  _lastLng: null,        // last GPS lng (for fall events)

  // Approach / start-line crossing detection
  _lastAcc: null,
  _gpsHistory: [],       // last 5 {lat,lng,ts} positions for velocity calc
  _minDistToStart: Infinity, // closest approach distance achieved
  _confirmShown: false,
  _armed: false,         // user confirmed → auto-crossing will fire
  _backgroundMode: false,

  // Fall / dismount detection
  fallEvents: [],        // [{type,ts,lat,lng}]  type='fall'|'dismount'
  _lastFallTs: 0,        // throttle fall event recording
  _lastGpsSpeed: 0,      // km/h — used for dismount detection

  // Cryptographic signature of finished result
  signature: null,

  // Bluetooth smartwatch GPS
  btDevice: null,
  btServer: null,
  btGpsLat: null,
  btGpsLng: null,
  btGpsTs: 0,

  // Resources to clean up
  gpsWatcher: null,
  wakeLock: null,
  timerInterval: null,
  _canvasRaf: null,
  lastRunData: null  // for export/QR after finish
};

function _raceElapsed() {
  if (!RACE.startTs) return 0;
  return Math.max(0, performance.now() - RACE.startTs);
}

function _showRacePage(pageId) {
  ['rp-approaching','rp-approach','rp-go','rp-running','rp-results']
    .forEach(id => { const el=document.getElementById(id); if(el) el.style.display='none'; });
  const el = document.getElementById(pageId);
  if (el) el.style.display = pageId === 'rp-approach' ? 'block' : '';
  // Stop canvas animation if leaving approach page
  if (pageId !== 'rp-approach' && RACE._canvasRaf) {
    cancelAnimationFrame(RACE._canvasRaf); RACE._canvasRaf = null;
  }
}

// ── CANVAS APPROACH DRAWING ────────────────────────────────────
// Renders the distance warning canvas (5m → 2m approach animation)
// Completely independent from GPX recorder
function _drawApproachCanvas(distM) {
  const canvas = document.getElementById('approach-canvas');
  if (!canvas || !canvas.getContext) return;
  const parent = canvas.parentElement;
  if (!parent) return;
  const W = parent.clientWidth  || window.innerWidth;
  const H = parent.clientHeight || window.innerHeight;
  if (canvas.width !== W)  canvas.width  = W;
  if (canvas.height !== H) canvas.height = H;
  const ctx = canvas.getContext('2d');

  // ── Background
  ctx.fillStyle = isDark ? '#0b0e14' : '#121624';
  ctx.fillRect(0, 0, W, H);

  const atStart = distM <= 2;

  if (atStart) {
    // ══ START LINE VIEW ══════════════════════════════════
    // Vertical edge bars
    ctx.fillStyle = '#c8ff00';
    ctx.fillRect(0, 0, 6, H);
    ctx.fillRect(W - 6, 0, 6, H);

    // Horizontal start line
    const lineY = Math.round(H * 0.52);
    ctx.fillStyle = '#c8ff00';
    ctx.fillRect(0, lineY - 5, W, 10);

    // "BEREIT!" or "START" lettering
    const fStart = Math.min(Math.round(W * 0.27), 90);
    ctx.font = `900 ${fStart}px 'Barlow Condensed',sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    const armedColor = RACE._armed ? '#4ade80' : '#c8ff00';
    ctx.fillStyle   = armedColor;
    ctx.shadowColor = armedColor;
    ctx.shadowBlur  = 18;
    ctx.fillText(RACE._armed ? 'BEREIT!' : 'START', W / 2, lineY - fStart * 0.65);
    ctx.shadowBlur = 0;

    // Sub-label below line
    const cm = Math.round(distM * 100);
    ctx.font = `600 20px 'Barlow Condensed',sans-serif`;
    ctx.fillStyle = 'rgba(255,255,255,0.55)';
    ctx.fillText(RACE._armed ? 'Überquere die Linie!' : `${cm} cm`, W / 2, lineY + 32);

  } else {
    // ══ APPROACHING VIEW (5m → 2m) ═══════════════════════
    // Progress 0 at 5m → 1 at 2m
    const progress = Math.max(0, Math.min(1, (5 - distM) / 3));

    // Color: amber at 5m (#f59e0b) → lime at 2m (#c8ff00)
    const r = Math.round(245 - progress * 47);
    const g = Math.round(158 + progress * 97);
    const b = Math.round(11);
    const distColor = `rgb(${r},${g},${b})`;

    // Big distance number
    const numSize = Math.round(80 + progress * 70);  // 80px → 150px
    ctx.font = `900 ${numSize}px 'Barlow Condensed',sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = distColor;
    ctx.shadowColor = distColor;
    ctx.shadowBlur = 12 + progress * 16;
    ctx.fillText(`${Math.round(distM)} m`, W / 2, H / 2 - numSize * 0.3);
    ctx.shadowBlur = 0;

    // "Bitte vorwerts laufen" — grows as you approach
    const txtSize = Math.round(14 + progress * 34);   // 14px → 48px
    const txtAlpha = 0.3 + progress * 0.7;             // 0.3 → 1.0
    ctx.font = `600 ${txtSize}px 'Barlow',sans-serif`;
    ctx.fillStyle = `rgba(255,255,255,${txtAlpha.toFixed(2)})`;
    ctx.fillText('Vorwärts zur Startlinie!', W / 2, H / 2 + numSize * 0.6 + progress * 8);

    // GPS accuracy info at bottom
    ctx.font = `400 11px sans-serif`;
    ctx.fillStyle = 'rgba(255,255,255,0.25)';
    ctx.fillText(`GPS ±${RACE._lastAcc != null ? Math.round(RACE._lastAcc) : '?'}m`, W / 2, H - 28);
  }
}

// Called via requestAnimationFrame to keep canvas crisp during approach
function _scheduleCanvasUpdate(distM) {
  if (RACE._canvasRaf) cancelAnimationFrame(RACE._canvasRaf);
  RACE._canvasRaf = requestAnimationFrame(() => {
    RACE._canvasRaf = null;
    _drawApproachCanvas(distM);
  });
}

// User confirms / denies race start from the 2m dialog
function _confirmRaceStart(confirmed) {
  const conf = document.getElementById('approach-confirm');
  if (conf) conf.classList.remove('show');

  if (!confirmed) {
    // "Nochmal anfahren" — go back to approaching phase without aborting
    if (RACE.startLine) { map.removeLayer(RACE.startLine); RACE.startLine = null; }
    if (RACE._canvasRaf) { cancelAnimationFrame(RACE._canvasRaf); RACE._canvasRaf = null; }
    RACE.state = 'approaching';
    RACE._confirmShown = false;
    RACE._armed = false;
    RACE._minDistToStart = Infinity;
    RACE._gpsHistory = [];
    _showRacePage('rp-approaching');
    return;
  }

  // YES — arm the auto-cross detection; timer fires when line is actually crossed
  RACE._armed = true;
  RACE._backgroundMode = true;
  if (navigator.vibrate) navigator.vibrate([150, 60, 150]);
  toast('✅ Bereit — überquere die Startlinie!');
  // Redraw canvas with armed state (shows "BEREIT!" at ~2m)
  const d = RACE._minDistToStart < Infinity ? RACE._minDistToStart : 2.0;
  _drawApproachCanvas(d);
}

async function beginPreRace(trackId) {
  if (RACE.state !== 'idle') return;
  const t = trackStore.tracks.find(t => t.id === trackId);
  if (!t) return;

  const pts = _getGpxPoints(t.gpxLayer, t.gpxString);
  if (pts.length < 2) { toast('⚠️ Track zu kurz für Zeitnahme'); return; }

  const cpData = _computeCheckpoints(pts);

  // ── Reset all RACE fields ──────────────────────────────────
  RACE.state          = 'approaching';
  RACE.trackId        = trackId;
  RACE.trackName      = t.name;
  RACE.startPt        = pts[0];
  RACE.checkpoints    = cpData?.checkpoints || [];
  RACE.totalKm        = cpData?.totalKm    || 0;
  RACE.nextCpIdx      = 0;
  RACE.splitTimes     = []; RACE.splitTimestamps = [];
  RACE.startTs        = null; RACE.startWallTs = null; RACE.lastSplitTs = null;
  RACE.gpsTrack       = []; RACE._lastLat = null; RACE._lastLng = null;
  RACE._gpsHistory    = []; RACE._minDistToStart = Infinity;
  RACE._armed         = false; RACE._confirmShown = false; RACE._backgroundMode = false;
  RACE.fallEvents     = []; RACE._lastFallTs = 0; RACE._lastGpsSpeed = 0;
  RACE.signature      = null; RACE._lastAcc = null;
  if (RACE._canvasRaf) { cancelAnimationFrame(RACE._canvasRaf); RACE._canvasRaf = null; }
  const fallRow = document.getElementById('rr-fall-row');
  if (fallRow) fallRow.innerHTML = '';

  // ── Checkpoint markers on map ──────────────────────────────
  _clearCpMarkers();
  if (RACE.checkpoints.length) {
    RACE.checkpoints.forEach(cp => {
      const s = Math.round(16 * _markerScale), hs = Math.round(s / 2);
      const icon = L.divIcon({
        className: '',
        html: `<div class="chk-div${cp.isFinish?' finish':''}" style="width:${s}px;height:${s}px"></div>`,
        iconSize:[s,s], iconAnchor:[hs,hs]
      });
      RACE.cpMarkers.push(L.marker([cp.lat,cp.lng],{icon,zIndexOffset:900}).addTo(map)
        .bindTooltip(cp.label,{permanent:true,direction:'top',className:'map-label'}));
    });
  }

  // ── Show pre-race overlay ──────────────────────────────────
  document.getElementById('race-overlay').classList.add('show');
  _showRacePage('rp-approaching');
  document.getElementById('ra-track-nm').textContent = t.name;

  // ── Start motion sensors (fall / dismount detection) ──────
  _startMotionSensors();
  _updateRaceSensorBadges();

  // ── Wake Lock ──────────────────────────────────────────────
  try {
    if ('wakeLock' in navigator) RACE.wakeLock = await navigator.wakeLock.request('screen');
  } catch(e) { console.info('Wake Lock nicht verfügbar:', e.message); }

  // ── Ensure GPS ─────────────────────────────────────────────
  try { await ensureGpsActive(); } catch(e) { /* handled */ }

  toast('🏁 Fahre zur Startlinie!');
}

function _clearCpMarkers() {
  RACE.cpMarkers.forEach(m => map.removeLayer(m));
  RACE.cpMarkers = [];
  if (RACE.startLine) { map.removeLayer(RACE.startLine); RACE.startLine = null; }
}

// Checkpoint-Marker-Icons bei Skalierungsänderung aktualisieren
function _updateCpMarkerIcons() {
  if (!RACE || !Array.isArray(RACE.cpMarkers) || !Array.isArray(RACE.checkpoints)) return;
  RACE.cpMarkers.forEach((mkr, i) => {
    const cp = RACE.checkpoints[i];
    if (!cp || !mkr) return;
    const s  = Math.round(16 * _markerScale);
    const hs = Math.round(s / 2);
    mkr.setIcon(L.divIcon({
      className: '',
      html: `<div class="chk-div${cp.isFinish?' finish':''}" style="width:${s}px;height:${s}px"></div>`,
      iconSize: [s, s], iconAnchor: [hs, hs]
    }));
  });
}

// GPS callback during pre-race & racing
function _onRaceGpsUpdate(lat, lng, acc, speed) {
  if (RACE.state === 'idle' || RACE.state === 'finished') return;

  // ── BT GPS sensor fusion ───────────────────────────────────
  // If BT GPS is fresh (< 3 s), average with device GPS for better accuracy
  let useLat = lat, useLng = lng, useAcc = acc;
  if (RACE.btGpsLat != null && (performance.now() - RACE.btGpsTs) < 3000) {
    useLat = (lat + RACE.btGpsLat) / 2;
    useLng = (lng + RACE.btGpsLng) / 2;
    useAcc = Math.min(acc, 5); // BT watch assumed higher accuracy
  }

  RACE._lastLat = useLat;
  RACE._lastLng = useLng;
  RACE._lastAcc = useAcc;

  // ── Maintain GPS position history (last 5 positions) ───────
  const nowTs = performance.now();
  RACE._gpsHistory.push({lat:useLat, lng:useLng, ts:nowTs});
  if (RACE._gpsHistory.length > 5) RACE._gpsHistory.shift();

  const distToStart = _distM(useLat, useLng, RACE.startPt.lat, RACE.startPt.lng);

  if (RACE.state === 'approaching') {
    document.getElementById('ra-dist-val').textContent = Math.round(distToStart);
    document.getElementById('ra-gps-acc').textContent  = `GPS ±${Math.round(useAcc)}m`;
    _updateRaceSensorBadges();
    if (distToStart <= 5 && useAcc <= 20) _enterStartLine(useLat, useLng, useAcc);
    return;
  }

  if (RACE.state === 'at_line') {
    // Track how close the rider got to the line
    if (distToStart < RACE._minDistToStart) RACE._minDistToStart = distToStart;

    _scheduleCanvasUpdate(distToStart);
    _updateRaceSensorBadges();

    // Show confirm dialog at 2m with decent accuracy (only once)
    if (distToStart <= 2.0 && !RACE._confirmShown && useAcc <= 15) {
      RACE._confirmShown = true;
      RACE._armed = true; // also auto-arms (rider is clearly at the line)
      const conf = document.getElementById('approach-confirm');
      if (conf) conf.classList.add('show');
      _drawApproachCanvas(distToStart);
      if (navigator.vibrate) navigator.vibrate([300, 100, 300]);
    }

    // ── Auto-cross detection ───────────────────────────────
    // When armed: was within 1.5 m → now clearly moving away → crossed!
    // Threshold: rider moved ≥1.5 m past the minimum achieved distance.
    // This handles fast riders who cross before (or instead of) tapping.
    if (RACE._armed && RACE._minDistToStart < 1.5 &&
        distToStart > RACE._minDistToStart + 1.5 && !RACE.startTs) {
      const conf = document.getElementById('approach-confirm');
      if (conf) conf.classList.remove('show');
      _crossStartLine();
    }
    return;
  }

  if (RACE.state === 'racing') {
    _processRacePosition(useLat, useLng, useAcc, speed);
    return;
  }
}

function _enterStartLine(lat, lng, acc) {
  RACE.state = 'at_line';
  RACE._confirmShown = false;
  RACE._armed = false;
  RACE._minDistToStart = Infinity; // reset so crossing detection starts fresh
  RACE._gpsHistory = [];

  // Pulse vibration — approach warning
  if (navigator.vibrate) navigator.vibrate([150, 80, 150]);

  // Draw start line on map (perpendicular to track direction)
  const _raceTrack = trackStore.tracks.find(t => t.id === RACE.trackId);
  const pts = _raceTrack ? _getGpxPoints(_raceTrack.gpxLayer, _raceTrack.gpxString) : [];
  if (pts.length >= 2) RACE.startLine = _drawStartLine(pts[0], pts[1]);

  // Show full-screen canvas approach page
  _showRacePage('rp-approach');
  document.getElementById('race-overlay').classList.add('show');
  const dist = _distM(lat, lng, RACE.startPt.lat, RACE.startPt.lng);
  _drawApproachCanvas(dist);
}

function _crossStartLine() {
  if (RACE.state === 'go' || RACE.state === 'racing') return; // guard against double-fire
  RACE.state = 'go';
  if (navigator.vibrate) navigator.vibrate([300]);

  // ── Initialize GPX recording ───────────────────────────────
  RACE.gpsTrack    = [];
  RACE.startWallTs = Date.now();

  if (RACE._backgroundMode) {
    // ── BACKGROUND MODE: hide overlay, race runs silently ─────
    document.getElementById('race-overlay').classList.remove('show');
    if (RACE._canvasRaf) { cancelAnimationFrame(RACE._canvasRaf); RACE._canvasRaf = null; }
    RACE.state       = 'racing';
    RACE.startTs     = performance.now();
    RACE.lastSplitTs = RACE.startTs;
    RACE.timerInterval = setInterval(_tickTimer, 100);
    stopNavigation(false);
    toast('▶ Los! Zeitmessung läuft…');
  } else {
    // ── NORMAL MODE: show GO! page → running page ─────────────
    _showRacePage('rp-go');
    document.getElementById('race-overlay').classList.add('show');

    // Build split boxes
    const grid = document.getElementById('rr-splits-grid');
    grid.innerHTML = '';
    const labels = ['Split 1','Split 2','Split 3','Ziel'];
    labels.forEach((lbl, i) => {
      const div = document.createElement('div');
      div.className = 'rr-split-box' + (i === 0 ? ' active' : '');
      div.id = `rr-split-${i}`;
      div.innerHTML = `<div class="rr-split-lbl">${lbl}</div><div class="rr-split-val empty" id="rr-sv-${i}">—</div>`;
      grid.appendChild(div);
    });
    document.getElementById('rr-track-nm').textContent = RACE.trackName;

    setTimeout(() => {
      RACE.state       = 'racing';
      RACE.startTs     = performance.now();
      RACE.lastSplitTs = RACE.startTs;
      _showRacePage('rp-running');
      RACE.timerInterval = setInterval(_tickTimer, 100);
      stopNavigation(false);
    }, 800);
  }
}

function _tickTimer() {
  if (RACE.state !== 'racing') return;
  const el = document.getElementById('rr-timer');
  if (el) el.textContent = _fmtTime(_raceElapsed());
}

function _processRacePosition(lat, lng, acc, speed) {
  const spd  = (speed != null && !isNaN(speed)) ? speed : 0;
  const kmh  = spd * 3.6;
  const prev = RACE._lastGpsSpeed;
  RACE._lastGpsSpeed = kmh;

  document.getElementById('rr-speed-lbl').textContent =
    `${kmh.toFixed(1)} km/h · ±${Math.round(acc)}m`;

  // ── Record GPS track point ─────────────────────────────────
  // Throttle: add point if moved > 5 m or > 2 s since last point
  if (RACE.startTs) {
    const ts   = Math.round(performance.now() - RACE.startTs);
    const last = RACE.gpsTrack[RACE.gpsTrack.length - 1];
    const movedM  = last ? _distM(lat, lng, last.lat, last.lng) : 999;
    const elapsedMs = last ? (ts - last.ts) : 9999;
    if (movedM > 5 || elapsedMs > 2000) {
      RACE.gpsTrack.push({ lat, lng, alt:null, ts, speed:spd, acc:Math.round(acc) });
    }
  }

  // ── Dismount detection: GPS speed drops from > 5 km/h to < 1 km/h ──
  if (prev > 5 && kmh < 1) {
    _recordFallEvent('dismount');
  }

  if (RACE.state !== 'racing') return;
  if (RACE.nextCpIdx >= RACE.checkpoints.length) return;

  const cp    = RACE.checkpoints[RACE.nextCpIdx];
  const dToCp = _distM(lat, lng, cp.lat, cp.lng);

  // Adaptive checkpoint radius: 3 m minimum, scales up with GPS accuracy
  // Formula: max(3, min(8, acc * 0.4)) — e.g. acc=10m → radius=4m
  const cpRadius = Math.max(3, Math.min(8, acc * 0.4));

  if (dToCp < cpRadius) {
    const now     = performance.now();
    const splitMs = now - RACE.lastSplitTs;
    RACE.lastSplitTs = now;
    RACE.splitTimes.push(splitMs);
    RACE.splitTimestamps.push(Date.now());
    if (navigator.vibrate) navigator.vibrate([100]);

    if (RACE._backgroundMode) {
      const lbl = cp.isFinish ? '🏁 Ziel' : `⏱ ${cp.label}`;
      toast(`${lbl}: ${_fmtTime(splitMs)}`);
    } else {
      const svEl = document.getElementById(`rr-sv-${RACE.nextCpIdx}`);
      const sbEl = document.getElementById(`rr-split-${RACE.nextCpIdx}`);
      if (svEl) { svEl.textContent = _fmtTime(splitMs); svEl.classList.remove('empty'); }
      if (sbEl) { sbEl.classList.remove('active'); sbEl.classList.add('done'); }
      const nextSb = document.getElementById(`rr-split-${RACE.nextCpIdx + 1}`);
      if (nextSb) nextSb.classList.add('active');
    }

    if (cp.isFinish) {
      _finishRace();
    } else {
      RACE.nextCpIdx++;
    }
  }
}

async function _finishRace() {
  RACE.state = 'finished';
  clearInterval(RACE.timerInterval);
  RACE.timerInterval = null;
  if (navigator.vibrate) navigator.vibrate([200, 100, 200, 100, 400]);

  const totalMs = _raceElapsed();
  const slabels = ['Split 1','Split 2','Split 3','Ziel'];

  // ── Load profile for run metadata ─────────────────────────
  const _prof = loadProfile();

  // ── Build run object ───────────────────────────────────────
  const run = {
    trackId:         RACE.trackId,
    trackName:       RACE.trackName,
    date:            new Date().toISOString(),
    totalMs,
    splits:          RACE.splitTimes.slice(),
    splitTimestamps: RACE.splitTimestamps.slice(),
    fallEvents:      RACE.fallEvents.slice(),
    gpsTrack:        RACE.gpsTrack.slice(),
    gpsPoints:       RACE.gpsTrack.length,
    riderName:       _prof.name       || '',
    muniName:        _prof.muniName   || '',
    muniDetails: {
      wheelSize:      _prof.wheelSize      || '',
      color:          _prof.color          || '',
      brake:          _prof.brake          || '',
      seatClampColor: _prof.seatClampColor || '',
      special:        _prof.special        || ''
    },
    signature: null  // filled after signing
  };

  // ── Cryptographic signing ─────────────────────────────────
  run.signature  = await _signRaceResult(run);
  RACE.signature = run.signature;
  RACE.lastRunData = run;

  // ── Save to IndexedDB (strip gpsTrack from stored record to save space)
  const runForStore = Object.assign({}, run, {gpsTrack: undefined});
  await _saveRun(runForStore);

  // ── Release wake lock ─────────────────────────────────────
  if (RACE.wakeLock) { try { await RACE.wakeLock.release(); } catch(e){} RACE.wakeLock = null; }

  // ── Load leaderboard ──────────────────────────────────────
  const runs   = await _getRunsForTrack(RACE.trackId);
  const sorted = [...runs].sort((a,b) => a.totalMs - b.totalMs);

  // ── Build results UI ──────────────────────────────────────
  document.getElementById('rres-track-nm').textContent = RACE.trackName;
  document.getElementById('rres-total').textContent    = _fmtTime(totalMs);

  const splitsGrid = document.getElementById('rres-splits-grid');
  splitsGrid.innerHTML = '';
  RACE.splitTimes.forEach((ms, i) => {
    const card = document.createElement('div');
    card.className = 'rres-split-card';
    card.innerHTML = `<div class="rres-split-lbl">${slabels[i]||'Split'}</div><div class="rres-split-val">${_fmtTime(ms)}</div>`;
    splitsGrid.appendChild(card);
  });

  // ── Signature box ─────────────────────────────────────────
  const sigBox = document.getElementById('rres-sig-box');
  const sigVal = document.getElementById('rres-sig-val');
  if (sigBox && sigVal && run.signature && run.signature !== 'unsigned') {
    sigVal.textContent = run.signature;
    sigBox.style.display = '';
  }

  // ── Leaderboard (clickable rows) ──────────────────────────
  const lb = document.getElementById('rres-lb');
  lb.innerHTML = '';
  sorted.slice(0, 8).forEach((r, i) => {
    const isCur = r.date === run.date;
    const row   = document.createElement('div');
    row.className = `rres-lb-row cursor-ptr${i===0?' gold-row':''}${isCur?' cur-row':''}`;
    row.title = 'Details anzeigen';
    const nameLabel = r.riderName
      ? `<span class="rres-lb-name">${escHtml(r.riderName)}</span>`
      : `<span class="rres-lb-date">${new Date(r.date).toLocaleDateString('de')}</span>`;
    row.innerHTML = `<span class="rres-lb-rank${i===0?' gold':''}">${i===0?'🥇':i+1}</span>
      ${nameLabel}
      <span class="rres-lb-time">${_fmtTime(r.totalMs)}</span>`;
    row.addEventListener('click', () => openRunDetail(r));
    lb.appendChild(row);
  });

  // ── QR code with signed metadata (incl. rider + muni) ────
  try {
    const qrPayload = JSON.stringify({
      app:   'GMTW26',
      track:  run.trackName,
      date:   run.date,
      rider:  run.riderName  || '',
      muni:   run.muniName   || '',
      wheel:  (run.muniDetails?.wheelSize) || '',
      total:  _fmtTime(totalMs, false),
      splits: run.splits.map((ms,i) => ({s: slabels[i]||`S${i+1}`, t: _fmtTime(ms, false)})),
      falls:  run.fallEvents.length,
      pts:    run.gpsPoints,
      sig:    (run.signature||'unsigned').slice(0, 16)
    });
    const qrCanvas = document.getElementById('rres-qr-canvas');
    if (qrCanvas) drawQR(qrCanvas, qrPayload, 120, '#0b0e14', '#ffffff');
  } catch(e) { console.warn('QR render error:', e); }

  _showRacePage('rp-results');
  document.getElementById('race-overlay').classList.add('show'); // always show at finish
  _clearCpMarkers();
  renderTrackList(); // refresh run counts in track list
}

function confirmAbortRace() {
  if (RACE.state === 'finished' || RACE.state === 'idle') { abortRace(); return; }
  // Beim Anfahren noch kein Rennen gestartet — direkt abbrechen, kein Bestätigungsdialog
  if (RACE.state === 'approaching' || RACE.state === 'at_line') { abortRace(); return; }
  // Rennen läuft — Bestätigung einholen
  document.getElementById('rr-confirm').classList.add('show');
  _showRacePage('rp-running'); // running page muss sichtbar sein für den Bestätigungsdialog
}
function hideAbortConfirm() {
  document.getElementById('rr-confirm').classList.remove('show');
}
function abortRace() {
  clearInterval(RACE.timerInterval); RACE.timerInterval = null;
  if (RACE._canvasRaf) { cancelAnimationFrame(RACE._canvasRaf); RACE._canvasRaf = null; }
  if (RACE.wakeLock)   { try { RACE.wakeLock.release(); } catch(e){} RACE.wakeLock = null; }
  _clearCpMarkers();
  stopNavigation(false);
  // Stop motion sensors
  _stopMotionSensors();
  // Disconnect Bluetooth if connected
  if (RACE.btDevice) {
    try { RACE.btDevice.gatt.disconnect(); } catch(e) {}
    RACE.btDevice = null; RACE.btServer = null;
    RACE.btGpsLat = null; RACE.btGpsLng = null;
  }
  RACE.state           = 'idle';
  RACE.trackId         = null;
  RACE._backgroundMode = false;
  RACE._confirmShown   = false;
  RACE._armed          = false;
  document.getElementById('race-overlay').classList.remove('show');
  const conf = document.getElementById('approach-confirm');
  if (conf) conf.classList.remove('show');
  const fallRow = document.getElementById('rr-fall-row');
  if (fallRow) fallRow.innerHTML = '';
  toast('🛑 Rennen abgebrochen');
}
function closeRaceOverlay() {
  if (RACE.state !== 'finished') { abortRace(); return; }
  RACE.state = 'idle';
  RACE.trackId = null;
  document.getElementById('race-overlay').classList.remove('show');
  renderTrackList(); // refresh leaderboard in list
}

// ══════════════════════════════════════════════════════════════
// ── LEADERBOARD & RUN STORAGE ──────────────────────────────────
// ══════════════════════════════════════════════════════════════
async function _saveRun(run) {
  try {
    const all = (await localforage.getItem(LS.K.RUNS)) || {};
    if (!all[run.trackId]) all[run.trackId] = [];
    all[run.trackId].push(run);
    // Keep max 50 runs per track, sorted best first
    all[run.trackId].sort((a,b)=>a.totalMs-b.totalMs);
    if (all[run.trackId].length > 50) all[run.trackId] = all[run.trackId].slice(0,50);
    await localforage.setItem(LS.K.RUNS, all);
    _cachedRuns = all; // refresh sync cache immediately
  } catch(e) { console.warn('Lauf speichern fehlgeschlagen:', e); }
}
async function _getRunsForTrack(trackId) {
  try {
    const all = (await localforage.getItem(LS.K.RUNS)) || {};
    return all[trackId] || [];
  } catch(e) { return []; }
}
async function _getAllRuns() {
  try { return (await localforage.getItem(LS.K.RUNS)) || {}; } catch(e) { return {}; }
}

function exportRunJson() {
  if (!RACE.lastRunData) return;
  const nm = (RACE.lastRunData.trackName || 'run').replace(/[^a-zA-Z0-9_-]/g, '_');
  // Include full data (signature, fall events, GPS track)
  dlFile(`${nm}_lauf_${new Date().toISOString().slice(0,10)}.json`,
    JSON.stringify(RACE.lastRunData, null, 2), 'application/json');
  toast('⬇ JSON exportiert');
}
function shareRunQr() {
  if (!RACE.lastRunData) return;
  const d = RACE.lastRunData;
  // Build compact signed QR payload
  const payload = {
    app:   'GMTW26',
    track:  d.trackName,
    date:   d.date,
    total:  _fmtTime(d.totalMs, false),
    splits: d.splits.map((ms,i) => ({s:`S${i+1}`, t:_fmtTime(ms,false)})),
    falls: (d.fallEvents||[]).length,
    pts:   d.gpsPoints || 0,
    sig:   (d.signature||'unsigned').slice(0, 16)
  };
  const canvas = document.getElementById('rres-qr-canvas');
  if (canvas) drawQR(canvas, JSON.stringify(payload), 120, '#0b0e14', '#ffffff');
  toast('📋 QR mit Signatur generiert!');
}

// ══════════════════════════════════════════════════════════════
// ── TRACK DETAIL PANEL (in track list) ─────────────────────────
// ══════════════════════════════════════════════════════════════
// _activeDetailId is declared at trackStore level above for sync access

function openTrackDetail(trackId) {
  if (_activeDetailId === trackId) { closeTrackDetail(); return; }
  _activeDetailId = trackId;
  renderTrackList(); // sync render — adds placeholder slot
  _fillDetailSlot(); // async — fills placeholder with real content
}
function closeTrackDetail() {
  _activeDetailId = null;
  renderTrackList();
}

// Async: fills #trk-detail-slot with the rendered detail panel
async function _fillDetailSlot() {
  const slot = document.getElementById('trk-detail-slot');
  if (!slot || !_activeDetailId) return;
  const t = trackStore.tracks.find(t => t.id === _activeDetailId);
  if (!t) return;
  const div = await _renderTrackDetailPanel(t);
  if (slot.isConnected) { // still in DOM (not closed meanwhile)
    slot.className = ''; // remove loading style
    slot.style.cssText = '';
    slot.textContent = '';
    slot.appendChild(div);
  }
}

async function _renderTrackDetailPanel(t) {
  const runs = await _getRunsForTrack(t.id);
  const sorted = [...runs].sort((a,b)=>a.totalMs-b.totalMs);
  const startPts = t.startPt ? [t.startPt] : _getGpxPoints(t.gpxLayer, t.gpxString);
  const gmUrl = startPts.length
    ? `https://www.google.com/maps/dir/?api=1&destination=${startPts[0].lat},${startPts[0].lng}&travelmode=bicycling`
    : '#';

  const div = document.createElement('div');
  div.className = 'trk-detail';

  window._tddRuns = sorted.slice(0, 5);
  const lbHtml = sorted.length === 0
    ? `<div class="tdd-lb-empty">Noch keine Zeiten — erste Fahrt starten!</div>`
    : window._tddRuns.map((r, i) => {
        const dateStr = new Date(r.date).toLocaleDateString('de-DE', {day:'2-digit', month:'2-digit', year:'2-digit'});
        const nameHtml = r.riderName
          ? `<span class="tdd-lb-name">${escHtml(r.riderName)}</span><span class="tdd-lb-date" style="font-size:9px">${dateStr}</span>`
          : `<span class="tdd-lb-date">${dateStr}</span>`;
        return `
      <div class="tdd-lb-row${i===0?' gold-lb':''} cursor-ptr" onclick="_openTddRun(${i})" title="Lauf-Details anzeigen">
        <span class="tdd-lb-rank${i===0?' gold':''}">${i===0?'🥇':i+1}</span>
        ${nameHtml}
        <span class="tdd-lb-time">${_fmtTime(r.totalMs)}</span>
      </div>`;
      }).join('');

  div.innerHTML = `
    <div class="tdd-head">
      <div class="tdd-dot" style="background:${t.color}"></div>
      <div class="tdd-name">${escHtml(t.name)}</div>
      <button class="tdd-close" onclick="closeTrackDetail()" aria-label="Schließen">×</button>
    </div>
    <div class="tdd-stats">
      <div class="tdd-stat"><div class="tdd-stat-val">${t.stats.dist}</div><div class="tdd-stat-lbl">km</div></div>
      <div class="tdd-stat"><div class="tdd-stat-val">${t.stats.dur||'—'}</div><div class="tdd-stat-lbl">Zeit</div></div>
      <div class="tdd-stat"><div class="tdd-stat-val">${sorted.length}</div><div class="tdd-stat-lbl">Runs</div></div>
    </div>
    <div class="tdd-btns">
      <button class="tdd-btn race" onclick="closeTrackDetail();beginPreRace('${t.id}')">
        <svg width="13" height="13" viewBox="0 0 13 13" fill="none"><polygon points="2,1 12,6.5 2,12" fill="currentColor"/></svg>
        Strecke starten &amp; Zeit messen
      </button>
      <button class="tdd-btn navi" onclick="closeTrackDetail();startNavigation('${t.id}')">
        <svg width="13" height="13" viewBox="0 0 13 13" fill="none"><path d="M6.5 1L12 6.5 6.5 12M1 6.5H11.5" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/></svg>
        Zur Startlinie navigieren
      </button>
      <button class="tdd-btn" style="background:transparent;color:var(--td);border:1px solid var(--bd2)" onclick="closeTrackDetail();zoomTrackFull('${t.id}');showElevProfile('${t.id}')">
        <svg width="13" height="13" viewBox="0 0 13 13" fill="none"><circle cx="5.5" cy="5.5" r="4" stroke="currentColor" stroke-width="1.5"/><path d="M9 9L12 12" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>
        Gesamte Strecke anzeigen
      </button>
      <a class="tdd-btn gmaps" href="${gmUrl}" target="_blank" rel="noopener">
        <svg width="11" height="13" viewBox="0 0 11 13" fill="none"><path d="M5.5 0C2.46 0 0 2.46 0 5.5 0 9.63 5.5 13 5.5 13s5.5-3.37 5.5-7.5C11 2.46 8.54 0 5.5 0zm0 7.5a2 2 0 110-4 2 2 0 010 4z" fill="currentColor"/></svg>
        Start in Google Maps öffnen
      </a>
    </div>
    <div class="tdd-lb">
      <div class="tdd-lb-head">🏆 Bestenliste</div>
      ${lbHtml}
      ${sorted.length > 0 ? `<button class="tdd-lb-export" onclick="exportTrackRunsJson('${t.id}')">⬇ Alle Zeiten als JSON</button>` : ''}
    </div>`;
  return div;
}

async function exportTrackRunsJson(trackId) {
  const runs = await _getRunsForTrack(trackId);
  const t = trackStore.tracks.find(t=>t.id===trackId);
  const name = (t?.name||trackId).replace(/[^a-zA-Z0-9_-]/g,'_');
  dlFile(`${name}_zeiten.json`, JSON.stringify({trackId,trackName:t?.name,runs},null,2), 'application/json');
  toast('⬇ Zeiten exportiert');
}

// ══════════════════════════════════════════════════════════════
// ── RUN CACHE — keeps renderTrackList() sync-safe ─────────────
// ══════════════════════════════════════════════════════════════
async function _initRunCache() {
  _cachedRuns = await _getAllRuns();
  renderTrackList();
}

// ══════════════════════════════════════════════════════════════
// ── SETTINGS PANEL ────────────────────────────────────────────
// ══════════════════════════════════════════════════════════════

const SP_EMOJIS = ['🦄','🚵','⛺','📍','🏔','🌲','🎯','💡','⭐','🔥','🏁','🚩','🎪','🦅','🏕','🗺'];

function openSettings() {
  const p = document.getElementById('settings-panel');
  p.classList.add('open');
  _loadSettingsForm();
  _applyA11yUi();
  _applyLangButtons();
  updateStorageInfo();
  renderAllMarkersList();
  _loadProfileForm();
  _renderSettingsProjList();
  speak('Einstellungen geöffnet. Profil, Allgemein, Strecken, Backup, Marker, QR-Scan, App.', false);
  _ariaAnnounce('Einstellungen geöffnet');
  setTimeout(()=>{ if(map) map.invalidateSize(); },300);
}

function closeSettings() {
  document.getElementById('settings-panel').classList.remove('open');
  // Kamera freigeben wenn Settings geschlossen werden
  stopQrScanner();
  speak('Einstellungen geschlossen.', false);
  _ariaAnnounce('Einstellungen geschlossen');
  setTimeout(()=>{ if(map) map.invalidateSize(); },300);
}

const _SP_TAB_LABELS = {
  general:  'Allgemein',
  tracks:   'Strecken',
  backup:   'Backup',
  markers:  'Marker',
  qr:       'QR-Scanner',
  app:      'App-Installation',
  profile:  'Fahrerprofil',
};
function switchSpTab(name, btn) {
  document.querySelectorAll('.sp-tab').forEach(t => t.classList.remove('active'));
  document.querySelectorAll('.sp-content').forEach(c => c.classList.remove('on'));
  btn.classList.add('active');
  const tab = document.getElementById('sp-tab-' + name);
  if (tab) tab.classList.add('on');
  // Tab-spezifische Initialisierung
  if (name === 'general') _renderSettingsProjList();
  if (name === 'qr')      _initQrTab();
  if (name === 'tracks')  _initTracksTab();
  if (name === 'backup')  updateStorageInfo();
  if (name === 'markers') renderAllMarkersList();
  if (name === 'app')     _initAppInstallTab();
  if (name === 'profile') { _loadProfileForm(); _applyLangButtons(); }
  // A11Y: Tab-Name vorlesen
  const label = _SP_TAB_LABELS[name] || name;
  speak(`Tab ${label} geöffnet.`, false);
  _ariaAnnounce(`Tab ${label}`);
}

// Emoji-Grid befüllen
function _buildEmojiGrid() {
  const grid = document.getElementById('emoji-grid');
  if (!grid || grid.children.length > 0) return;
  const cur = LS.get(LS.K.GPS_EMOJI, '🦄');
  SP_EMOJIS.forEach(em => {
    const btn = document.createElement('button');
    btn.className = 'emoji-opt' + (em === cur ? ' selected' : '');
    btn.textContent = em;
    btn.setAttribute('aria-label', em);
    btn.onclick = () => {
      document.querySelectorAll('.emoji-opt').forEach(e => e.classList.remove('selected'));
      btn.classList.add('selected');
      document.getElementById('sp-emoji-custom').value = em;
    };
    grid.appendChild(btn);
  });
}

function _loadSettingsForm() {
  _buildEmojiGrid();
  const cur = LS.get(LS.K.GPS_EMOJI, '🦄');
  document.getElementById('sp-emoji-custom').value = cur;
  // Mark selected in grid
  document.querySelectorAll('.emoji-opt').forEach(e => {
    e.classList.toggle('selected', e.textContent === cur);
  });
  // Home region
  const hr = LS.get(LS.K.HOME_REGION);
  if (hr) {
    document.getElementById('sp-home-lat').value = hr.lat || '';
    document.getElementById('sp-home-lng').value = hr.lng || '';
  }
  // Marker-Größen-Slider initialisieren
  const slider = document.getElementById('mk-scale-slider');
  const sliderVal = document.getElementById('mk-scale-val');
  if (slider) {
    const pct = Math.round(_markerScale * 100);
    slider.value = pct;
    if (sliderVal) sliderVal.textContent = pct + '%';
  }
}

// ══════════════════════════════════════════════════════════════
// ── PROFIL SYSTEM ──────────────────────────────────────────────
// ══════════════════════════════════════════════════════════════

// ── Avatar-Picker ──────────────────────────────────────────────
const PF_AVATAR_EMOJIS = ['🦄','🚵','🤸','🏂','🧗','🦸','🐉','🦊','🐺','🐻','🏔','🌲','⚡','🔥','💎','🎯','🚀','🌊','🐲','🦅'];
const PF_AVATAR_COLORS = ['#c8ff00','#38bdf8','#f59e0b','#ef4444','#a855f7','#ec4899','#22c55e','#64748b'];
let _pfAvatarEmoji = '🦄';
let _pfAvatarBg    = '#c8ff00';

function _renderAvatarPicker(p) {
  _pfAvatarEmoji = p.avatarEmoji || '🦄';
  _pfAvatarBg    = p.avatarBg    || '#c8ff00';
  const emojiRow = document.getElementById('pf-av-emoji-row');
  const colorRow = document.getElementById('pf-av-color-row');
  if (!emojiRow || !colorRow) return;
  emojiRow.innerHTML = PF_AVATAR_EMOJIS.map(em =>
    `<button class="pf-av-em${em === _pfAvatarEmoji ? ' sel' : ''}" onclick="_pfPickEmoji('${em}')">${em}</button>`
  ).join('');
  colorRow.innerHTML = PF_AVATAR_COLORS.map(col =>
    `<button class="pf-av-col${col === _pfAvatarBg ? ' sel' : ''}" style="background:${col}" onclick="_pfPickColor('${col}')" aria-label="${col}"></button>`
  ).join('');
}

function _pfPickEmoji(em) {
  _pfAvatarEmoji = em;
  document.querySelectorAll('.pf-av-em').forEach(b => b.classList.toggle('sel', b.textContent === em));
  const av = document.getElementById('profile-avatar');
  if (av) av.textContent = em;
}

function _pfPickColor(col) {
  _pfAvatarBg = col;
  document.querySelectorAll('.pf-av-col').forEach(b => {
    b.classList.toggle('sel', b.style.backgroundColor === col || b.getAttribute('onclick') === `_pfPickColor('${col}')`);
  });
  const av = document.getElementById('profile-avatar');
  if (av) { av.style.background = col; av.style.boxShadow = `0 0 16px ${col}88`; }
}

function loadProfile() {
  try { return JSON.parse(localStorage.getItem(LS.K.PROFILE) || '{}'); }
  catch(e) { return {}; }
}

function saveProfile() {
  const p = {
    name:           (document.getElementById('pf-input-name')?.value      || '').trim(),
    muniName:       (document.getElementById('pf-input-muni')?.value      || '').trim(),
    wheelSize:      (document.getElementById('pf-input-wheel')?.value     || '').trim(),
    color:          (document.getElementById('pf-input-color')?.value     || '').trim(),
    brake:          (document.getElementById('pf-input-brake')?.value     || '').trim(),
    seatClampColor: (document.getElementById('pf-input-seatclamp')?.value || '').trim(),
    special:        (document.getElementById('pf-input-special')?.value   || '').trim(),
    avatarEmoji:    _pfAvatarEmoji || '🦄',
    avatarBg:       _pfAvatarBg    || '#c8ff00',
    lang:           _appLang   // Aktuelle App-Sprache im Profil mitpersistieren
  };
  LS.set(LS.K.PROFILE, p);
  _refreshProfileDisplay(p);
  // Sprach-Buttons aktualisieren
  document.querySelectorAll('.lang-btn').forEach(b => {
    b.classList.toggle('active', b.dataset.lang === _appLang);
  });
  toast('✅ Profil gespeichert');
}

function _refreshProfileDisplay(p) {
  p = p || loadProfile();
  const nameEl   = document.getElementById('pf-name-display');
  const muniEl   = document.getElementById('pf-muni-display');
  const avatarEl = document.getElementById('profile-avatar');
  if (nameEl) nameEl.textContent = p.name || 'Kein Name gesetzt';
  if (muniEl) muniEl.textContent = p.muniName || 'Kein Muni-Name';
  if (avatarEl) {
    avatarEl.textContent = p.avatarEmoji || '🦄';
    const bg = p.avatarBg || '#c8ff00';
    avatarEl.style.background  = bg;
    avatarEl.style.boxShadow   = `0 0 16px ${bg}88`;
  }
}

function _loadProfileForm() {
  const p = loadProfile();
  const set = (id, val) => { const el=document.getElementById(id); if(el) el.value = val||''; };
  set('pf-input-name',      p.name);
  set('pf-input-muni',      p.muniName);
  set('pf-input-wheel',     p.wheelSize);
  set('pf-input-color',     p.color);
  set('pf-input-brake',     p.brake);
  set('pf-input-seatclamp', p.seatClampColor);
  set('pf-input-special',   p.special);
  // Sprache aus gespeichertem Profil laden
  if (p.lang && ['de','en','fr','es'].includes(p.lang)) _appLang = p.lang;
  _refreshProfileDisplay(p);
  _renderAvatarPicker(p);
  _applyLangButtons();
}

// ── RUN DETAIL MODAL ───────────────────────────────────────────
let _rdmCurrentRun = null; // run being viewed in the modal

function openRunDetail(run) {
  if (!run) return;
  _rdmCurrentRun = run;
  const body = document.getElementById('rdm-body');
  if (!body) return;

  const slabels = ['Split 1','Split 2','Split 3','Ziel'];
  const hasName = run.riderName && run.riderName.trim();
  const hasGpx  = run.gpsTrack && run.gpsTrack.length >= 2;

  // GPX-Button visibility
  const gpxBtn = document.getElementById('rdm-gpx-btn');
  if (gpxBtn) gpxBtn.style.display = hasGpx ? '' : 'none';

  // ── Muni detail chips ──────────────────────────────────────
  const md = run.muniDetails || {};
  const chips = [
    md.wheelSize ? `<span class="rdm-chip accent">${escHtml(md.wheelSize)}</span>` : '',
    md.color     ? `<span class="rdm-chip">${escHtml(md.color)}</span>`            : '',
    md.brake     ? `<span class="rdm-chip">${escHtml(md.brake)}</span>`            : '',
    md.seatClampColor ? `<span class="rdm-chip">${escHtml(md.seatClampColor)} Klemme</span>` : '',
    md.special   ? `<span class="rdm-chip accent">${escHtml(md.special)}</span>`  : '',
  ].filter(Boolean).join('');

  // ── Splits grid ────────────────────────────────────────────
  const splits = (run.splits || []).map((ms, i) =>
    `<div class="rdm-split-card">
      <div class="rdm-split-lbl">${slabels[i]||`S${i+1}`}</div>
      <div class="rdm-split-val">${_fmtTime(ms)}</div>
    </div>`
  ).join('');

  // ── Fall events ───────────────────────────────────────────
  const falls = (run.fallEvents || []);
  const fallsHtml = falls.length ? `
    <div class="rdm-section-lbl">💥 Ereignisse (${falls.length})</div>
    <div class="rdm-falls-row">
      ${falls.map(f => `<span class="rdm-fall-badge">${f.type==='fall'?'💥 Sturz':'🚶 Absteigen'} ${_fmtTime(f.ts)}</span>`).join('')}
    </div>` : '';

  // ── Signature ─────────────────────────────────────────────
  const sigHtml = (run.signature && run.signature !== 'unsigned') ? `
    <div class="rdm-sig-box">
      <div class="rdm-sig-lbl">🔐 Signatur (fälschungssicher)</div>
      <div class="rdm-sig-val">${escHtml(run.signature)}</div>
    </div>` : '';

  // ── Date ──────────────────────────────────────────────────
  const dateStr = new Date(run.date).toLocaleDateString('de-DE', {
    day:'2-digit', month:'2-digit', year:'numeric',
    hour:'2-digit', minute:'2-digit'
  });

  body.innerHTML = `
    <div class="rdm-rider-card">
      <div class="profile-avatar" style="width:44px;height:44px;font-size:20px;flex-shrink:0">${hasName?'🏆':'🦄'}</div>
      <div class="rdm-rider-info">
        <div class="rdm-rider-name">${hasName ? escHtml(run.riderName) : 'Unbekannter Fahrer'}</div>
        ${run.muniName ? `<div class="rdm-muni-name">🦄 ${escHtml(run.muniName)}</div>` : ''}
        ${chips ? `<div class="rdm-muni-chips">${chips}</div>` : ''}
      </div>
    </div>
    <div class="rdm-time-section">
      <div class="rdm-time-big">${_fmtTime(run.totalMs)}</div>
      <div class="rdm-time-lbl">Gesamtzeit</div>
    </div>
    <div class="rdm-track-meta">${escHtml(run.trackName || '—')} · ${dateStr}</div>
    ${splits ? `<div class="rdm-section-lbl">⏱ Zwischenzeiten</div><div class="rdm-splits-grid">${splits}</div>` : ''}
    ${fallsHtml}
    ${sigHtml}
  `;

  document.getElementById('run-detail-modal').classList.add('show');
}

function closeRunDetail() {
  document.getElementById('run-detail-modal').classList.remove('show');
  _rdmCurrentRun = null;
}

function exportCurrentRunDetailGpx() {
  if (!_rdmCurrentRun) return;
  if (!_rdmCurrentRun.gpsTrack || _rdmCurrentRun.gpsTrack.length < 2) {
    toast('⚠️ Kein GPS-Track in diesem Lauf'); return;
  }
  const gpx = _buildRaceGpx(_rdmCurrentRun);
  if (!gpx) { toast('⚠️ GPX-Export fehlgeschlagen'); return; }
  const nm = (_rdmCurrentRun.trackName || 'lauf').replace(/[^a-zA-Z0-9_-]/g, '_');
  dlFile(`${nm}_lauf_${new Date(_rdmCurrentRun.date).toISOString().slice(0,10)}.gpx`, gpx, 'application/gpx+xml');
  toast('⬇ Lauf-GPX exportiert');
}

function saveSettings() {
  // GPS Emoji
  const emojiInput = document.getElementById('sp-emoji-custom').value.trim();
  const emoji = emojiInput || '🦄';
  LS.set(LS.K.GPS_EMOJI, emoji);

  // Home Region — Validierung
  const latRaw = document.getElementById('sp-home-lat').value.trim();
  const lngRaw = document.getElementById('sp-home-lng').value.trim();
  if (latRaw && lngRaw) {
    const lat = parseFloat(latRaw), lng = parseFloat(lngRaw);
    if (!isNaN(lat) && !isNaN(lng) && lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180) {
      LS.set(LS.K.HOME_REGION, { lat, lng });
      toast('✅ Einstellungen gespeichert · Home: ' + lat.toFixed(4) + ', ' + lng.toFixed(4));
    } else {
      toast('⚠️ Ungültige Koordinaten — Home nicht gespeichert');
      LS.del(LS.K.HOME_REGION);
    }
  } else if (!latRaw && !lngRaw) {
    // beide leer = löschen
    LS.del(LS.K.HOME_REGION);
    toast('✅ Einstellungen gespeichert');
  } else {
    toast('⚠️ Bitte beide Koordinaten eingeben oder beide leer lassen');
    return;
  }

  closeSettings();
}

function useCurrentMapCenter() {
  const c = map.getCenter();
  document.getElementById('sp-home-lat').value = c.lat.toFixed(6);
  document.getElementById('sp-home-lng').value = c.lng.toFixed(6);
  toast('📍 Aktuelle Mitte übernommen');
}

function clearHomeRegion() {
  document.getElementById('sp-home-lat').value = '';
  document.getElementById('sp-home-lng').value = '';
  LS.del(LS.K.HOME_REGION);
  toast('🗑 Home-Fokus gelöscht');
}

async function updateStorageInfo() {
  const el = document.getElementById('sp-storage-info');
  if (!el) return;
  const lsBytes = LS.usedBytes();
  let idbInfo = '–';
  try {
    // localforage keys zählen
    const keys = await localforage.keys();
    idbInfo = `${keys.length} IndexedDB-Einträge`;
  } catch(e) {}

  let persistText = '';
  if (navigator.storage && navigator.storage.persisted) {
    try {
      const persisted = await navigator.storage.persisted();
      persistText = persisted
        ? '<span style="color:var(--ac)">● Dauerhaft gesichert</span>'
        : '<span style="color:var(--tm)">○ Nicht dauerhaft (kann gelöscht werden)</span>';
    } catch(e) {}
  }

  el.innerHTML = `
    LocalStorage: <strong>${Math.round(lsBytes/1024)} KB</strong> (GMTW-Daten)<br>
    IndexedDB: <strong>${idbInfo}</strong><br>
    ${persistText ? 'Speicherstatus: ' + persistText : ''}
  `;
}

async function requestPersistentStorage() {
  if (!navigator.storage || !navigator.storage.persist) {
    toast('⚠️ Persistenter Speicher nicht unterstützt');
    return;
  }
  try {
    const granted = await navigator.storage.persist();
    if (granted) {
      toast('🔒 Dauerhafter Speicher gewährt! Daten bleiben erhalten.');
    } else {
      toast('⚠️ Browser hat dauerhaften Speicher abgelehnt');
    }
    updateStorageInfo();
  } catch(e) {
    toast('❌ Fehler: ' + e.message);
  }
}

// ══════════════════════════════════════════════════════════════
// ── VOLLSTÄNDIGES BACKUP EXPORT / IMPORT ──────────────────────
// ══════════════════════════════════════════════════════════════

async function exportFullBackup() {
  try {
    toast('⏳ Backup wird erstellt…');

    // Alle Daten aus IndexedDB
    const tracks  = await localforage.getItem(LS.K.TRACKS)         || [];
    const runs    = await localforage.getItem(LS.K.RUNS)            || {};
    const markers = await localforage.getItem(LS.K.CUSTOM_MARKERS)  || [];

    // Vollständige Einstellungen (alle localStorage-Keys inkl. Marker-Konfiguration)
    const settings = {
      gpsEmoji:       LS.get(LS.K.GPS_EMOJI,      '🦄'),
      homeRegion:     LS.get(LS.K.HOME_REGION,    null),
      theme:          LS.get(LS.K.THEME,          'dark'),
      lastView:       LS.get(LS.K.VIEW,           null),
      installDecline: LS.get(LS.K.INSTALL_DECLINE, null),
      // Marker-Einstellungen (v4)
      markerScale:    parseFloat(localStorage.getItem('gmtw_marker_scale') || '1.0'),
      locsHidden:     JSON.parse(localStorage.getItem('gmtw_locs_hidden')    || '[]'),
      locsOverrides:  JSON.parse(localStorage.getItem('gmtw_locs_overrides') || '{}'),
      // Fahrerprofil (v5)
      profile:        LS.get(LS.K.PROFILE, {}),
      // Barrierefreiheit (v6)
      a11y:           LS.get(LS.K.A11Y, {}),
      // Strecken-Daten (v7)
      trkFeatures:    JSON.parse(localStorage.getItem('gmtw_trk_features_v1') || '{}'),
      trkRatings:     JSON.parse(localStorage.getItem('gmtw_trk_ratings_v1')  || '{}'),
      trkEdits:       JSON.parse(localStorage.getItem('gmtw_trk_edits_v1')    || '{}'),
      // Projekte (v8)
      projects:       _projects,
      activeProject:  _activeProjectId,
    };

    // Aktuell geladene Tracks mit vollständigen GPX-Daten sichern
    // (in-memory Tracks könnten neuere gpxString haben als IndexedDB)
    const liveTracksMap = {};
    trackStore.tracks.forEach(t => {
      if (t.gpxString) liveTracksMap[t.id] = t.gpxString;
    });
    const mergedTracks = tracks.map(t => ({
      ...t,
      gpxString: liveTracksMap[t.id] || t.gpxString || null
    }));

    const backup = {
      _version:  8,
      _app:      'GMTW Trail Map',
      _exported: new Date().toISOString(),
      tracks:    mergedTracks,
      runs,
      customMarkers: markers,
      settings,
    };

    const json  = JSON.stringify(backup, null, 2);
    const fname = `GMTW_Backup_${new Date().toISOString().slice(0,10)}.json`;
    const kb    = Math.round(json.length / 1024);

    // File System Access API (Chrome 86+) — mit Fallback auf Blob-Download
    if (window.showSaveFilePicker) {
      try {
        const fh = await window.showSaveFilePicker({
          suggestedName: fname,
          types: [{ description: 'JSON Backup', accept: { 'application/json': ['.json'] } }]
        });
        const writable = await fh.createWritable();
        await writable.write(json);
        await writable.close();
        toast(`✅ Backup gespeichert (${kb} KB · ${mergedTracks.length} Tracks · ${markers.length} Marker)`);
        return;
      } catch(e) {
        if (e.name === 'AbortError') return;
        console.warn('[backup] showSaveFilePicker fehlgeschlagen, Blob-Fallback:', e);
      }
    }

    // Fallback: klassischer Blob-Download (iOS Safari, Firefox, PWA)
    dlFile(fname, json, 'application/json');
    toast(`✅ Backup exportiert (${kb} KB · ${mergedTracks.length} Tracks · ${markers.length} Marker)`);
  } catch(e) {
    toast('❌ Export fehlgeschlagen: ' + e.message);
    console.error('exportFullBackup:', e);
  }
}

async function importFullBackup(input) {
  // Unterstützt sowohl <input type="file"> (file) als auch Blob (QR-Import)
  let file = null;
  if (input && input.files && input.files[0]) {
    file = input.files[0];
    input.value = '';
  } else if (input instanceof Blob) {
    file = input;
  }
  if (!file) return;

  const reader = new FileReader();
  reader.onload = async (ev) => {
    try {
      const raw  = ev.target.result;
      const data = JSON.parse(raw);

      // Validierung
      if (!data._app || !data._app.includes('GMTW')) {
        toast('❌ Ungültige Backup-Datei (kein GMTW-Backup)');
        return;
      }

      const dateStr = data._exported ? new Date(data._exported).toLocaleDateString('de') : '?';
      const tracksN  = Array.isArray(data.tracks) ? data.tracks.length : 0;
      const markersN = Array.isArray(data.customMarkers) ? data.customMarkers.length : 0;
      const version  = data._version || 1;

      if (!confirm(
        `GMTW Backup vom ${dateStr} importieren?\n` +
        `• ${tracksN} Strecken · ${markersN} eigene Marker\n` +
        `• Version ${version} · Alle bestehenden Daten werden ersetzt.\n\n` +
        `Fortfahren?`
      )) return;

      toast('⏳ Importiere…');

      // Tracks in IndexedDB (ohne nicht-serialisierbare Leaflet-Objekte)
      if (tracksN > 0) {
        const stripped = data.tracks.map(t => {
          const { gpxLayer, _startMkr, _finishMkr, ...rest } = t;
          return rest;
        });
        await localforage.setItem(LS.K.TRACKS, stripped);
      }

      // Runs / Zeiten
      if (data.runs && typeof data.runs === 'object') {
        await localforage.setItem(LS.K.RUNS, data.runs);
      }

      // Custom Markers
      if (markersN > 0) {
        await localforage.setItem(LS.K.CUSTOM_MARKERS, data.customMarkers);
      }

      // Einstellungen in localStorage (vollständig)
      if (data.settings) {
        const s = data.settings;
        if (s.gpsEmoji)       LS.set(LS.K.GPS_EMOJI,      s.gpsEmoji);
        if (s.homeRegion)     LS.set(LS.K.HOME_REGION,    s.homeRegion);
        if (s.theme)          LS.set(LS.K.THEME,          s.theme);
        if (s.lastView)       LS.set(LS.K.VIEW,           s.lastView);
        // Explizit null/false erlauben für installDecline
        if ('installDecline' in s) LS.set(LS.K.INSTALL_DECLINE, s.installDecline);
        // Marker-Einstellungen (v4+)
        if (typeof s.markerScale === 'number' && s.markerScale > 0) {
          localStorage.setItem('gmtw_marker_scale', String(s.markerScale));
        }
        if (Array.isArray(s.locsHidden)) {
          localStorage.setItem('gmtw_locs_hidden', JSON.stringify(s.locsHidden));
        }
        if (s.locsOverrides && typeof s.locsOverrides === 'object') {
          localStorage.setItem('gmtw_locs_overrides', JSON.stringify(s.locsOverrides));
        }
        // Fahrerprofil (v5+)
        if (s.profile && typeof s.profile === 'object') LS.set(LS.K.PROFILE, s.profile);
        // Barrierefreiheit (v6+)
        if (s.a11y && typeof s.a11y === 'object') LS.set(LS.K.A11Y, s.a11y);
        // Strecken-Zusatzdaten (v7+)
        if (s.trkFeatures && typeof s.trkFeatures === 'object') {
          localStorage.setItem('gmtw_trk_features_v1', JSON.stringify(s.trkFeatures));
        }
        if (s.trkRatings && typeof s.trkRatings === 'object') {
          localStorage.setItem('gmtw_trk_ratings_v1', JSON.stringify(s.trkRatings));
        }
        if (s.trkEdits && typeof s.trkEdits === 'object') {
          localStorage.setItem('gmtw_trk_edits_v1', JSON.stringify(s.trkEdits));
        }
        // Projekte (v8+)
        if (Array.isArray(s.projects) && s.projects.length) {
          LS.set(LS.K.PROJECTS, s.projects);
        }
        if (s.activeProject) {
          LS.set(LS.K.ACTIVE_PROJECT, s.activeProject);
        }
      }

      const imported = `${tracksN} Strecken · ${markersN} Marker`;
      toast(`✅ Backup v${version} importiert (${imported}) — Seite wird neu geladen…`);
      setTimeout(() => location.reload(), 1800);

    } catch(e) {
      toast('❌ Import fehlgeschlagen: ' + e.message);
      console.error('importFullBackup:', e);
    }
  };
  reader.onerror = () => toast('❌ Datei nicht lesbar');
  reader.readAsText(file, 'utf-8');
}

// ══════════════════════════════════════════════════════════════
// ── PROJEKT EXPORT / IMPORT ───────────────────────────────────
// ══════════════════════════════════════════════════════════════

async function exportProjectJson(projectId) {
  try {
    projectId = projectId || _activeProjectId;
    const proj = _projects.find(p => p.id === projectId);
    if (!proj) { toast('❌ Projekt nicht gefunden'); return; }

    toast('⏳ Projekt-Export wird erstellt…');

    const projTracks  = trackStore.tracks.filter(t => t.projectId === projectId);
    const projMarkers = (_cmMarkers || []).filter(m => m.projectId === projectId);

    // GPX-Strings aus IndexedDB ergänzen (in-memory kann null sein für ältere Tracks)
    const savedTracks = await localforage.getItem(LS.K.TRACKS) || [];
    const dbGpxMap = {};
    savedTracks.forEach(t => { if (t.gpxString) dbGpxMap[t.id] = t.gpxString; });

    const allFeats = JSON.parse(localStorage.getItem('gmtw_trk_features_v1') || '{}');
    const allRats  = JSON.parse(localStorage.getItem('gmtw_trk_ratings_v1')  || '{}');
    const allEds   = JSON.parse(localStorage.getItem('gmtw_trk_edits_v1')    || '{}');

    const ids = new Set(projTracks.map(t => t.id));
    const feats = {}, rats = {}, eds = {};
    ids.forEach(id => {
      if (allFeats[id])           feats[id]           = allFeats[id];
      if (allFeats[id + '_meta']) feats[id + '_meta'] = allFeats[id + '_meta'];
      if (allRats[id])            rats[id]             = allRats[id];
      if (allEds[id])             eds[id]              = allEds[id];
    });

    let tracksWithGpx = 0;
    const exportTracks = projTracks.map(t => {
      const gpxString = t.gpxString || dbGpxMap[t.id] || null;
      if (gpxString) tracksWithGpx++;
      return {
        id: t.id, name: t.name, cat: t.cat, color: t.color,
        visible: t.visible, stats: t.stats,
        gpxString,
        sourceUrl: t.sourceUrl || null,
        projectId: t.projectId
      };
    });

    const payload = {
      _app: 'gmtw-project', _version: 1,
      _exported: new Date().toISOString(),
      project: proj,
      tracks: exportTracks,
      customMarkers: projMarkers,
      trkFeatures: feats, trkRatings: rats, trkEdits: eds
    };

    const json  = JSON.stringify(payload, null, 2);
    const kb    = Math.round(json.length / 1024);
    const safe  = proj.name.replace(/[^a-zA-Z0-9äöüÄÖÜ_\-]/g, '-').replace(/-+/g, '-');
    const fname = `gmtw-projekt-${safe}-${new Date().toISOString().slice(0, 10)}.json`;

    // File System Access API (Chrome 86+) mit Fallback
    if (window.showSaveFilePicker) {
      try {
        const fh = await window.showSaveFilePicker({
          suggestedName: fname,
          types: [{ description: 'GMTW Projekt JSON', accept: { 'application/json': ['.json'] } }]
        });
        const writable = await fh.createWritable();
        await writable.write(json);
        await writable.close();
        toast(`✅ "${proj.name}" exportiert — ${tracksWithGpx} Strecken, ${projMarkers.length} Marker, ${kb} KB`);
        return;
      } catch(e) { if (e.name === 'AbortError') return; }
    }

    dlFile(fname, json, 'application/json');
    toast(`✅ "${proj.name}" exportiert — ${tracksWithGpx} Strecken, ${projMarkers.length} Marker, ${kb} KB`);
  } catch(e) {
    toast('❌ Export fehlgeschlagen: ' + e.message);
    console.error('exportProjectJson:', e);
  }
}

async function importProjectJson(input) {
  let file = null;
  if (input && input.files && input.files[0]) { file = input.files[0]; input.value = ''; }
  else if (input instanceof Blob) { file = input; }
  if (!file) return;

  let s;
  try { s = JSON.parse(await file.text()); }
  catch(e) { toast('❌ Ungültige JSON-Datei: ' + e.message); return; }

  if (s._app !== 'gmtw-project') { toast('❌ Kein GMTW-Projekt-Export (falsches Format)'); return; }

  const tracksToImport = (s.tracks || []).filter(t => t.gpxString);
  const markersToImport = s.customMarkers || [];

  if (!confirm(
    `Projekt "${escHtml(s.project?.name || '?')}" importieren?\n` +
    `• ${tracksToImport.length} Strecken  •  ${markersToImport.length} Marker\n\n` +
    `Ein neues Projekt wird erstellt. Fortfahren?`
  )) return;

  toast('⏳ Projekt wird importiert…');

  // ── Kollisionsfreier Projektname ─────────────────────────────
  const baseName = s.project?.name || 'Import';
  let name = baseName;
  let sfx = 1;
  const existing = _projects.map(p => p.name);
  while (existing.includes(name)) name = `${baseName} (${++sfx})`;

  const newProjId = 'proj_' + Date.now();
  const newProj = {
    id: newProjId, name,
    centerLat: s.project?.centerLat ?? null,
    centerLng: s.project?.centerLng ?? null,
    zoom: s.project?.zoom ?? 15,
    enabled: true,
    createdAt: new Date().toISOString()
  };
  _projects.push(newProj);
  LS.set(LS.K.PROJECTS, _projects);

  // ── Tracks sequenziell parsen ────────────────────────────────
  // WICHTIG: L.GPX callback liefert ein Event-Objekt (e), nicht den Layer.
  //          Der Layer ist e.target. addTo(map) startet das Parsen.
  const idMap = {};
  let importedTracks = 0;

  for (let idx = 0; idx < tracksToImport.length; idx++) {
    const t = tracksToImport[idx];
    // Kollisionsfreie ID: Timestamp + Index + Zufall
    const newId = `trk_${Date.now()}_${idx}_${Math.random().toString(36).slice(2, 6)}`;
    idMap[t.id] = newId;

    const ok = await new Promise((resolve) => {
      const timeoutId = setTimeout(() => {
        console.warn('[importProject] Timeout bei Track:', t.name);
        resolve(false);
      }, 30000);

      // Neue L.GPX-Instanz mit GPX-String
      const layer = new L.GPX(t.gpxString, {
        async: true,
        polyline_options: { color: t.color || '#c8ff00', weight: 3, opacity: 0.9 },
        marker_options: { startIconUrl: null, endIconUrl: null, shadowUrl: null }
      });

      // KORREKTE Event-Syntax: Parameter ist das Event-Objekt e, Layer = e.target
      layer.on('loaded', function(e) {
        clearTimeout(timeoutId);
        const gl = e.target; // ← das ist der GPX-Layer
        try {
          const pts  = _getGpxPoints(gl, t.gpxString);
          const braw = (() => {
            try { const b = gl.getBounds(); return (b && b.isValid && b.isValid()) ? b : null; }
            catch { return null; }
          })();
          let dist = t.stats?.dist || '?', dur = t.stats?.dur || '—';
          try { dist = (gl.get_distance() / 1000).toFixed(2); } catch {}
          try {
            const ms = gl.get_total_time();
            if (ms) { const m = Math.round(ms / 60000); dur = m >= 60 ? `${Math.floor(m/60)}h ${m%60}min` : `${m} min`; }
          } catch {}

          const track = {
            id: newId,
            name: t.name || `Track ${idx + 1}`,
            cat: t.cat || 'mittel',
            color: t.color || '#c8ff00',
            gpxLayer: gl,
            visible: true,
            sourceUrl: t.sourceUrl || null,
            gpxString: t.gpxString,
            bounds: braw,
            stats: { dist, dur },
            elevData: extractElevData(gl),
            startPt:  pts.length > 0 ? pts[0]               : null,
            finishPt: pts.length > 1 ? pts[pts.length - 1]  : null,
            projectId: newProjId
          };

          trackStore.tracks.push(track);
          // Layer ist bereits auf Karte (addTo unten), Start/Ziel-Marker hinzufügen
          _addStartMarker(track);
          _addFinishMarker(track);
          _renderTrackFeatures(track);
          importedTracks++;
          resolve(true);
        } catch(ex) {
          console.warn('[importProject] Track-Verarbeitung fehlgeschlagen:', t.name, ex);
          resolve(false);
        }
      });

      layer.on('error', function(e) {
        clearTimeout(timeoutId);
        console.warn('[importProject] GPX parse error:', t.name, e);
        resolve(false);
      });

      // KRITISCH: addTo(map) startet das asynchrone Parsen des GPX-Strings!
      layer.addTo(map);
    });

    if (!ok) console.warn('[importProject] Track übersprungen:', t.name);
  }

  // ── Custom Marker mit neuen IDs ──────────────────────────────
  const rawCm = Array.isArray(_cmMarkers) ? [..._cmMarkers] : [];
  markersToImport.forEach((m, idx) => {
    rawCm.push({
      ...m,
      id: `cm_${Date.now()}_${idx}_${Math.random().toString(36).slice(2, 6)}`,
      projectId: newProjId
    });
  });
  _cmMarkers = rawCm;
  await _saveCustomMarkers();

  // ── Features / Ratings / Edits auf neue Track-IDs remappen ──
  const feats = JSON.parse(localStorage.getItem('gmtw_trk_features_v1') || '{}');
  const rats  = JSON.parse(localStorage.getItem('gmtw_trk_ratings_v1')  || '{}');
  const eds   = JSON.parse(localStorage.getItem('gmtw_trk_edits_v1')    || '{}');
  Object.entries(s.trkFeatures || {}).forEach(([k, v]) => {
    const isMeta = k.endsWith('_meta');
    const origId = isMeta ? k.slice(0, -5) : k;
    const newKey = idMap[origId];
    if (newKey) feats[newKey + (isMeta ? '_meta' : '')] = v;
  });
  Object.entries(s.trkRatings || {}).forEach(([k, v]) => { if (idMap[k]) rats[idMap[k]] = v; });
  Object.entries(s.trkEdits   || {}).forEach(([k, v]) => { if (idMap[k]) eds[idMap[k]] = v; });
  localStorage.setItem('gmtw_trk_features_v1', JSON.stringify(feats));
  localStorage.setItem('gmtw_trk_ratings_v1',  JSON.stringify(rats));
  localStorage.setItem('gmtw_trk_edits_v1',    JSON.stringify(eds));

  // ── Alles persistieren und zum neuen Projekt wechseln ───────
  await persistTracks();
  switchProject(newProjId);
  renderTrackList();
  buildList();
  _renderSettingsProjList();

  const msg = `✅ Projekt "${name}" importiert — ${importedTracks} Strecken, ${markersToImport.length} Marker`;
  toast(msg);
  speak(`Projekt ${name} importiert. ${importedTracks} Strecken geladen.`, true);
}

// ══════════════════════════════════════════════════════════════
// ── RUN EXPORTS ─────────────────────────────────────────────────
// ══════════════════════════════════════════════════════════════

// Öffnet Run-Detail aus Track-Detail-Bestenliste (via window._tddRuns Index)
function _openTddRun(i) {
  if (window._tddRuns && window._tddRuns[i]) openRunDetail(window._tddRuns[i]);
}

// Gibt alle Zeiten aller Strecken als flaches Array zurück
async function _getAllRunsFlat() {
  const allRuns   = await localforage.getItem(LS.K.RUNS)   || {};
  const allTracks = await localforage.getItem(LS.K.TRACKS) || [];
  const trackNames = {};
  allTracks.forEach(t => { trackNames[t.id] = t.name || t.id; });
  trackStore.tracks.forEach(t => { trackNames[t.id] = t.name || t.id; });

  const flat = [];
  for (const [trackId, runs] of Object.entries(allRuns)) {
    if (!Array.isArray(runs)) continue;
    for (const r of runs) {
      flat.push({
        trackId,
        trackName:  trackNames[trackId] || trackId,
        date:       r.date       || '',
        riderName:  r.riderName  || '',
        muniName:   r.muniName   || '',
        wheelSize:  (r.muniDetails && r.muniDetails.wheelSize) || '',
        totalMs:    r.totalMs    || 0,
        totalTime:  _fmtTime(r.totalMs || 0),
        splits:     r.splits     || [],
        falls:      r.fallEvents ? r.fallEvents.length : 0,
        signature:  r.signature  || ''
      });
    }
  }
  flat.sort((a, b) => new Date(b.date) - new Date(a.date));
  return flat;
}

// Export aller Zeiten als JSON
async function exportAllRunsJson() {
  try {
    toast('⏳ Erstelle JSON-Export…');
    const runs = await _getAllRunsFlat();
    if (!runs.length) { toast('ℹ️ Noch keine Zeiten vorhanden'); return; }

    const data = {
      _app:      'GMTW Trail Map',
      _exported: new Date().toISOString(),
      _total:    runs.length,
      runs
    };
    const json  = JSON.stringify(data, null, 2);
    const fname = `GMTW_Zeiten_${new Date().toISOString().slice(0,10)}.json`;
    dlFile(fname, json, 'application/json');
    toast(`✅ ${runs.length} Zeiten exportiert`);
  } catch(e) {
    toast('❌ Export fehlgeschlagen: ' + e.message);
    console.error('exportAllRunsJson:', e);
  }
}

// Export aller Zeiten als CSV (Excel-kompatibel mit BOM)
async function exportAllRunsCsv() {
  try {
    toast('⏳ Erstelle CSV-Export…');
    const runs = await _getAllRunsFlat();
    if (!runs.length) { toast('ℹ️ Noch keine Zeiten vorhanden'); return; }

    const maxSplits = Math.max(...runs.map(r => r.splits.length), 0);
    const splitHeaders = [];
    for (let i = 0; i < maxSplits; i++) {
      splitHeaders.push(i < maxSplits - 1 ? `Split ${i+1}` : 'Ziel');
    }
    const headers = ['Strecke','Datum','Fahrer','Muni','Rad','Gesamtzeit',
                     ...splitHeaders, 'Stürze','Signatur'];

    const csvEsc = v => {
      const s = String(v == null ? '' : v);
      if (s.includes(',') || s.includes('"') || s.includes('\n')) return `"${s.replace(/"/g,'""')}"`;
      return s;
    };

    const rows = [headers.join(',')];
    for (const r of runs) {
      const dateStr = r.date ? new Date(r.date).toLocaleDateString('de-DE') : '';
      const splitVals = [];
      for (let i = 0; i < maxSplits; i++) {
        splitVals.push(r.splits[i] != null ? _fmtTime(r.splits[i]) : '');
      }
      rows.push([
        csvEsc(r.trackName),
        csvEsc(dateStr),
        csvEsc(r.riderName),
        csvEsc(r.muniName),
        csvEsc(r.wheelSize),
        csvEsc(r.totalTime),
        ...splitVals.map(csvEsc),
        csvEsc(r.falls),
        csvEsc(r.signature)
      ].join(','));
    }

    const csv   = '\uFEFF' + rows.join('\r\n'); // BOM für Excel-Kompatibilität
    const fname = `GMTW_Zeiten_${new Date().toISOString().slice(0,10)}.csv`;
    dlFile(fname, csv, 'text/csv;charset=utf-8');
    toast(`✅ ${runs.length} Zeiten als CSV exportiert`);
  } catch(e) {
    toast('❌ Export fehlgeschlagen: ' + e.message);
    console.error('exportAllRunsCsv:', e);
  }
}

// ══════════════════════════════════════════════════════════════
// ── CUSTOM MARKERS ─────────────────────────────────────────────
// ══════════════════════════════════════════════════════════════

// Kategorie → Farbe (passend zu CATS)
const CM_CAT_COLORS = {
  beginner: '#22c55e',
  mittel:   '#f59e0b',
  expert:   '#ef4444',
  logistik: '#38bdf8',
};

let _cmMarkers = [];        // In-Memory-Liste aller eigenen Marker
let _cmLeafletLayers = {};  // id → Leaflet Marker Objekt
let _markerModeActive = false;

// Beim Doppelklick auf Karte Marker setzen (statt Zoom)
map.on('dblclick', function(e) {
  if (!_markerModeActive) return;
  L.DomEvent.stop(e); // verhindert Zoom
  openMdModal(null, e.latlng.lat, e.latlng.lng);
});

function toggleMarkerMode(on) {
  _markerModeActive = (on === undefined) ? !_markerModeActive : !!on;
  const bar = document.getElementById('marker-mode-bar');
  if (bar) bar.style.display = _markerModeActive ? 'block' : 'none';
  // Doppelklick-Zoom deaktivieren wenn Modus aktiv
  if (_markerModeActive) {
    map.doubleClickZoom.disable();
    toast('📍 Marker-Modus aktiv — Doppelklick auf Karte');
  } else {
    map.doubleClickZoom.enable();
  }
}

// Emoji-Liste für Marker-Symbol-Picker
const CM_EMOJIS = ['📍','📌','⭐','🔥','🏔','🌲','🏁','🚩','🎯','💡','⚡','🏕','🦅','🚵','⛺','🏆','🛤','🌄','💎','🔵'];

// Ermittelt den Maps-Link basierend auf Gerät (Apple → Apple Maps, sonst Google Maps)
function _buildMapsLink(lat, lng) {
  const isApple = /iphone|ipad|ipod|macintosh/i.test(navigator.userAgent) && 'ontouchend' in document;
  if (isApple) {
    return `https://maps.apple.com/?ll=${lat},${lng}&q=GMTW+Marker`;
  }
  return `https://www.google.com/maps?q=${lat},${lng}`;
}

// Symbol-Picker aufbauen
function _buildMdEmojiPicker(selected) {
  const grid = document.getElementById('md-emoji-grid');
  if (!grid) return;
  grid.innerHTML = '';
  CM_EMOJIS.forEach(em => {
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'md-emoji-btn' + (em === selected ? ' selected' : '');
    btn.textContent = em;
    btn.title = em;
    btn.onclick = () => {
      document.querySelectorAll('.md-emoji-btn').forEach(b => b.classList.remove('selected'));
      btn.classList.add('selected');
      document.getElementById('md-emoji').value = em;
    };
    grid.appendChild(btn);
  });
}

// Modal öffnen: editId = null → neu, sonst Bearbeiten
function openMdModal(editId, lat, lng) {
  const overlay = document.getElementById('md-overlay');
  overlay.style.display = 'flex';
  // Sheet-Animation
  setTimeout(() => overlay.classList.add('show'), 10);

  document.getElementById('md-title').textContent = editId ? 'Marker bearbeiten' : 'Marker erstellen';
  document.getElementById('md-edit-id').value = editId || '';

  if (editId) {
    const cm = _cmMarkers.find(m => m.id === editId);
    if (cm) {
      document.getElementById('md-name').value = cm.name;
      document.getElementById('md-cat').value = cm.cat;
      document.getElementById('md-desc').value = cm.desc || '';
      document.getElementById('md-emoji').value = cm.emoji || '📍';
      const mapsUrl = cm.gmapsUrl || _buildMapsLink(cm.lat, cm.lng);
      document.getElementById('md-gmaps').value = mapsUrl;
      document.getElementById('md-lat').value = cm.lat;
      document.getElementById('md-lng').value = cm.lng;
      document.getElementById('md-lat-disp').textContent = cm.lat.toFixed(6);
      document.getElementById('md-lng-disp').textContent = cm.lng.toFixed(6);
      _buildMdEmojiPicker(cm.emoji || '📍');
      _updateMdMapsLink(cm.lat, cm.lng);
      _updateMdShareQr(cm.lat, cm.lng, cm.name);
    }
  } else {
    document.getElementById('md-name').value = '';
    document.getElementById('md-cat').value = 'mittel';
    document.getElementById('md-desc').value = '';
    document.getElementById('md-emoji').value = '📍';
    document.getElementById('md-gmaps').value = '';
    document.getElementById('md-lat').value = lat !== undefined ? lat : '';
    document.getElementById('md-lng').value = lng !== undefined ? lng : '';
    document.getElementById('md-lat-disp').textContent = lat !== undefined ? lat.toFixed(6) : '—';
    document.getElementById('md-lng-disp').textContent = lng !== undefined ? lng.toFixed(6) : '—';
    _buildMdEmojiPicker('📍');
    if (lat !== undefined && lng !== undefined) {
      _updateMdMapsLink(lat, lng);
      _updateMdShareQr(lat, lng, '');
    } else {
      _clearMdMapsLink();
      _clearMdShareQr();
    }
  }
}

// Maps-Link Auto-generieren und in Feld eintragen
function _updateMdMapsLink(lat, lng) {
  const url = _buildMapsLink(lat, lng);
  const el = document.getElementById('md-gmaps');
  if (el && !el.dataset.userEdited) el.value = url;
  const lbl = document.getElementById('md-maps-lbl');
  const isApple = /iphone|ipad|ipod|macintosh/i.test(navigator.userAgent) && 'ontouchend' in document;
  if (lbl) lbl.textContent = isApple ? 'Apple Maps Link (auto)' : 'Google Maps Link (auto)';
}

function _clearMdMapsLink() {
  const el = document.getElementById('md-gmaps');
  if (el) { el.value = ''; delete el.dataset.userEdited; }
}

// QR-Code für die Position im Modal rendern
// Speichert aktuelle Position für Share-Button
let _mdQrLat = 0, _mdQrLng = 0, _mdQrMapsUrl = '';

function _updateMdShareQr(lat, lng, name) {
  const wrap = document.getElementById('md-share-qr-wrap');
  const canvas = document.getElementById('md-share-qr-canvas');
  if (!wrap || !canvas) return;
  _mdQrLat = lat; _mdQrLng = lng;
  _mdQrMapsUrl = _buildMapsLink(lat, lng);
  try {
    const qr = qrcode(0, 'M');
    qr.addData(_mdQrMapsUrl);
    qr.make();
    const size = 148; // Größerer QR-Code für bessere Lesbarkeit
    canvas.width = size; canvas.height = size;
    const ctx = canvas.getContext('2d');
    const mod = qr.getModuleCount();
    const cell = size / mod;
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, size, size);
    ctx.fillStyle = '#000000';
    for (let r = 0; r < mod; r++) {
      for (let c = 0; c < mod; c++) {
        if (qr.isDark(r, c)) ctx.fillRect(Math.floor(c * cell), Math.floor(r * cell), Math.ceil(cell), Math.ceil(cell));
      }
    }
    wrap.style.display = 'block';
    // Download-Button
    const dlBtn = document.getElementById('md-share-qr-dl');
    if (dlBtn) dlBtn.onclick = () => {
      const nm = document.getElementById('md-name').value.trim() || 'marker';
      downloadCanvas(canvas, `GMTW_Pos_${nm.replace(/\s+/g,'_')}.png`);
    };
    // Web Share-Button anzeigen wenn verfügbar
    const shrBtn = document.getElementById('md-share-qr-share');
    if (shrBtn) shrBtn.style.display = (navigator.share || navigator.canShare) ? '' : 'none';
  } catch(e) {
    wrap.style.display = 'none';
  }
}

// Position via Web Share teilen (Karte-Link)
async function _mdShareQrPos() {
  const nm = document.getElementById('md-name')?.value.trim() || 'Marker';
  if (navigator.share) {
    try {
      await navigator.share({ title: `GMTW – ${nm}`, url: _mdQrMapsUrl });
      return;
    } catch(e) { if (e.name === 'AbortError') return; }
  }
  // Fallback: in Zwischenablage
  if (navigator.clipboard) {
    navigator.clipboard.writeText(_mdQrMapsUrl).then(() => toast('📋 Link kopiert!'));
  }
}

function _clearMdShareQr() {
  const wrap = document.getElementById('md-share-qr-wrap');
  if (wrap) wrap.style.display = 'none';
}

function closeMdModal() {
  const overlay = document.getElementById('md-overlay');
  overlay.classList.remove('show');
  setTimeout(() => { overlay.style.display = 'none'; }, 300);
}

async function saveMdMarker() {
  const name = document.getElementById('md-name').value.trim();
  if (!name) { toast('⚠️ Name ist pflicht!'); return; }

  const lat  = parseFloat(document.getElementById('md-lat').value);
  const lng  = parseFloat(document.getElementById('md-lng').value);
  if (isNaN(lat) || isNaN(lng)) { toast('⚠️ Koordinaten fehlen'); return; }

  const editId   = document.getElementById('md-edit-id').value;
  const emoji    = document.getElementById('md-emoji').value.trim() || '📍';
  const gmapsRaw = document.getElementById('md-gmaps').value.trim();
  const gmapsUrl = gmapsRaw || _buildMapsLink(lat, lng);
  const desc     = document.getElementById('md-desc').value.trim();
  const cat      = document.getElementById('md-cat').value;

  // ── LOCS-Marker bearbeiten (Überschreibung speichern, kein custom marker) ──
  if (_pendingLocsEditId) {
    const locId = _pendingLocsEditId;
    _pendingLocsEditId = null;
    _locsOverrides[locId] = { name, emoji, desc, gmapsUrl };
    _saveLocsState();
    reloadLocsMarkers();
    closeMdModal();
    toast(`✅ "${escHtml(name)}" aktualisiert`);
    renderAllMarkersList();
    return;
  }

  const existingMarker = editId ? _cmMarkers.find(m=>m.id===editId) : null;
  const marker = {
    id:        editId || ('cm_' + Date.now()),
    name, cat, emoji, desc, gmapsUrl, lat, lng,
    projectId: existingMarker?.projectId || _activeProjectId || (_projects[0]?.id || ''),
    createdAt: existingMarker?.createdAt || new Date().toISOString()
  };

  if (editId) {
    const idx = _cmMarkers.findIndex(m => m.id === editId);
    if (idx >= 0) _cmMarkers[idx] = marker;
    else _cmMarkers.push(marker);
  } else {
    _cmMarkers.push(marker);
  }

  await _saveCustomMarkers();
  closeMdModal();

  // Bestehenden Leaflet-Layer entfernen und neu zeichnen
  _renderOneCmMarker(marker);
  toast(`✅ Marker "${escHtml(name)}" gespeichert`);

  // Wenn Marker-Modus, nach dem Speichern weitermachen
  if (!editId) {
    map.setView([lat, lng], Math.max(map.getZoom(), 17), { animate: true });
  }
}

async function deleteCmMarker(id) {
  const cm = _cmMarkers.find(m => m.id === id);
  if (!cm) return;
  if (!confirm(`Marker "${cm.name}" wirklich löschen?`)) return;

  // Leaflet-Layer entfernen
  if (_cmLeafletLayers[id]) {
    map.removeLayer(_cmLeafletLayers[id]);
    delete _cmLeafletLayers[id];
  }

  _cmMarkers = _cmMarkers.filter(m => m.id !== id);
  await _saveCustomMarkers();
  renderAllMarkersList();
  toast('🗑 Marker gelöscht');
}

async function _saveCustomMarkers() {
  try {
    await localforage.setItem(LS.K.CUSTOM_MARKERS, _cmMarkers);
  } catch(e) {
    console.warn('Custom Markers speichern fehlgeschlagen:', e);
  }
}

async function _loadAndRenderCustomMarkers() {
  try {
    const saved = await localforage.getItem(LS.K.CUSTOM_MARKERS);
    _cmMarkers = Array.isArray(saved) ? saved : [];
  } catch(e) {
    _cmMarkers = [];
  }
  // Migration: bestehende Marker dem Standard-Projekt zuweisen
  const defaultId = _projects[0]?.id || '';
  let cmChanged = false;
  _cmMarkers = _cmMarkers.map(m => {
    if (!m.projectId) { cmChanged = true; return { ...m, projectId: defaultId }; }
    return m;
  });
  if (cmChanged) await _saveCustomMarkers();
  // Marker aller aktivierten Projekte auf der Karte zeigen
  _cmMarkers.forEach(cm => {
    const projEnabled = _projects.find(p => p.id === cm.projectId)?.enabled !== false;
    if (projEnabled) _renderOneCmMarker(cm);
  });
}

// Einen einzelnen Custom-Marker auf der Karte zeichnen
function _renderOneCmMarker(cm) {
  // Alten Layer sauber entfernen (kein Memory-Leak)
  if (_cmLeafletLayers[cm.id]) {
    try { map.removeLayer(_cmLeafletLayers[cm.id]); } catch(e) {}
    delete _cmLeafletLayers[cm.id];
  }

  const color    = CM_CAT_COLORS[cm.cat] || '#888';
  const catLabel = CATS[cm.cat]?.label || cm.cat;
  const emoji    = cm.emoji || '📍';

  // Custom Pin Icon mit individuellem Emoji + Skalierung
  const sc  = _markerScale;
  const w   = Math.round(34 * sc);
  const h   = Math.round(40 * sc);
  const fs  = Math.round(16 * sc);
  const tip = Math.round(10 * sc);
  const tw  = Math.round(7 * sc);
  const totalW = w + 2;
  const totalH = h + tip;
  const html = `<div style="position:relative;width:${totalW}px;height:${totalH}px">
    <div style="width:${w}px;height:${h}px;background:${color};border-radius:50% 50% 50% 0;transform:rotate(-45deg);display:flex;align-items:center;justify-content:center;box-shadow:0 4px 14px rgba(0,0,0,.65)">
      <span style="transform:rotate(45deg);font-size:${fs}px;line-height:1">${emoji}</span>
    </div>
    <div style="position:absolute;bottom:0;left:50%;transform:translateX(-50%);width:0;height:0;border-left:${tw}px solid transparent;border-right:${tw}px solid transparent;border-top:${tip}px solid ${color}"></div>
  </div>`;

  const icon = L.divIcon({ className: '', html, iconSize: [totalW, totalH], iconAnchor: [totalW/2, totalH], popupAnchor: [0, -(totalH+4)] });

  // Popup-Inhalt (XSS-safe)
  const nm  = escHtml(cm.name);
  const ds  = escHtml(cm.desc || '');
  const cl  = escHtml(catLabel);
  const mapsUrl = cm.gmapsUrl || _buildMapsLink(cm.lat, cm.lng);
  const isApple = /iphone|ipad|ipod|macintosh/i.test(navigator.userAgent) && 'ontouchend' in document;
  const mapsLabel = isApple ? 'Apple Maps öffnen' : 'Google Maps öffnen';
  const mapsLink = `<a href="${escHtml(mapsUrl)}" target="_blank" rel="noopener" style="color:var(--ac);font-size:11px;display:block;margin-top:6px">↗ ${mapsLabel}</a>`;

  const popup = `<div style="background:var(--s1)">
    <div class="p-top">
      <div class="p-badge" style="background:${color}">${cl}</div>
      <div class="p-name">${nm}</div>
      <div class="p-crds">${cm.lat.toFixed(5)}, ${cm.lng.toFixed(5)}</div>
      ${ds ? `<div class="p-desc">${ds}</div>` : ''}
      ${mapsLink}
    </div>
    <div class="p-acts" style="flex-wrap:wrap;gap:6px">
      <button class="pbtn nav" onclick="navTo(${cm.lat},${cm.lng},'${esc(cm.name)}')">Navigation</button>
      <button class="pbtn shr" onclick="openCmShareQr('${cm.id}')">📤 Teilen</button>
      <button class="pbtn shr" onclick="openMdModal('${cm.id}');map.closePopup()">✏ Bearbeiten</button>
      <button class="pbtn" style="background:rgba(239,68,68,.15);color:#ef4444;border:1px solid rgba(239,68,68,.3)" onclick="deleteCmMarker('${cm.id}');map.closePopup()">🗑 Löschen</button>
    </div>
  </div>`;

  const mkr = L.marker([cm.lat, cm.lng], { icon, zIndexOffset: 700 })
    .addTo(map)
    .bindPopup(popup, { maxWidth: 292, minWidth: 250 })
    .bindTooltip(cm.name, { permanent: false, direction: 'top', className: 'map-label' });

  _cmLeafletLayers[cm.id] = mkr;
}

// QR-Code für einen Custom-Marker im bestehenden QR-Modal anzeigen
function openCmShareQr(id) {
  const cm = _cmMarkers.find(m => m.id === id);
  if (!cm) return;
  map.closePopup();

  // Marker-Payload als GMTW-Marker-QR-Code
  const payload = JSON.stringify({
    type:  'gmtw-marker',
    name:  cm.name,
    cat:   cm.cat,
    emoji: cm.emoji || '📍',
    desc:  cm.desc || '',
    lat:   cm.lat,
    lng:   cm.lng,
  });
  // Falls zu lang: Maps-URL als Fallback
  const mapsUrl = cm.gmapsUrl || _buildMapsLink(cm.lat, cm.lng);
  const qrData  = payload.length <= 800 ? payload : mapsUrl;

  // Bestehendes QR-Modal befüllen und öffnen
  curQrUrl   = qrData;
  curQrLocId = 'marker_' + cm.id;
  document.getElementById('qr-nm').textContent   = (cm.emoji || '📍') + ' ' + cm.name;
  document.getElementById('qr-hint').textContent = 'QR scannen → Marker importieren oder Position öffnen';
  const inpEl = document.getElementById('qr-inp');
  if (inpEl) inpEl.value = mapsUrl; // Link-Feld zeigt Maps-URL
  const canvas = document.getElementById('qr-canvas');
  drawQR(canvas, qrData, 160, '#0b0e14', '#ffffff');
  closeAll();
  document.getElementById('qrm').classList.add('show');
  document.getElementById('backdrop').classList.add('show');
}

// Alle Marker (LOCS + Custom) im Settings-Panel rendern
function renderAllMarkersList() {
  const container = document.getElementById('cm-list-container');
  if (!container) return;

  container.innerHTML = '';

  // ── Abschnitt 1: Karten-Marker (LOCS) ────────────────────────
  const locsHdr = document.createElement('div');
  locsHdr.className = 'cm-section-hdr';
  locsHdr.innerHTML = `<span class="cm-section-title">Karten-Marker</span><span class="cm-section-count">${LOCS.length}</span>`;
  container.appendChild(locsHdr);

  // Deduplizierte LOCS-Liste (sam-mit taucht 2x auf → einmalig anzeigen)
  const seenLocs = new Set();
  LOCS.forEach(loc => {
    if (seenLocs.has(loc.id)) return;
    seenLocs.add(loc.id);

    const ov      = _locsOverrides[loc.id] || {};
    const effName = ov.name  || loc.name;
    const effEmoji= ov.emoji || loc.emoji;
    const hidden  = _locsHidden.has(loc.id);
    const hasOv   = Object.keys(ov).length > 0;
    const catLabel= CATS[loc.cat]?.label || loc.cat;

    const item = document.createElement('div');
    item.className = 'cm-item';
    item.style.opacity = hidden ? '0.45' : '1';
    item.innerHTML = `
      <div class="cm-emoji" style="background:${loc.color}22;border-radius:8px">${effEmoji}</div>
      <div class="cm-info">
        <div class="cm-name">${escHtml(effName)}${hasOv ? ' <span style="font-size:9px;color:var(--ac);font-weight:700;letter-spacing:.5px;vertical-align:middle">GEÄ</span>' : ''}</div>
        <div class="cm-cat">${escHtml(catLabel)} · ${loc.lat.toFixed(4)}, ${loc.lng.toFixed(4)}</div>
      </div>
      <div class="cm-actions">
        <button class="cm-act-btn" title="${hidden ? 'Einblenden' : 'Ausblenden'}"
          onclick="toggleLocsVisibility('${loc.id}')">${hidden ? '👁' : '🙈'}</button>
        <button class="cm-act-btn" title="Auf Karte zeigen"
          onclick="closeSettings();map.setView([${loc.lat},${loc.lng}],17);setTimeout(()=>{ if(MKR['${loc.id}']) MKR['${loc.id}'].m.openPopup(); },300)">📍</button>
        <button class="cm-act-btn" title="Bearbeiten"
          onclick="editLocsMarker('${loc.id}')">✏</button>
        ${hasOv ? `<button class="cm-act-btn reset" title="Zurücksetzen" onclick="resetLocsMarker('${loc.id}')">↺</button>` : ''}
      </div>`;
    container.appendChild(item);
  });

  // ── Abschnitt 2: Strecken-Marker (Start/Ziel der geladenen GPX-Tracks) ─
  const trkMarkers = [];
  trackStore.tracks.forEach(t => {
    if (t._startMkr)  trkMarkers.push({ track: t, type: 'start',  mkr: t._startMkr,  emoji: '▶',  label: 'Start' });
    if (t._finishMkr) trkMarkers.push({ track: t, type: 'finish', mkr: t._finishMkr, emoji: '🏁', label: 'Ziel'  });
  });

  if (trkMarkers.length > 0) {
    const trkHdr = document.createElement('div');
    trkHdr.className = 'cm-section-hdr';
    trkHdr.style.marginTop = '12px';
    trkHdr.innerHTML = `<span class="cm-section-title">Strecken-Marker</span><span class="cm-section-count">${trkMarkers.length}</span>`;
    container.appendChild(trkHdr);

    trkMarkers.forEach(({ track, type, mkr, emoji, label }) => {
      const color = track.color || '#888';
      const catLabel = CATS[track.cat]?.label || track.cat;
      const hidden = !map.hasLayer(mkr);
      const pos = mkr.getLatLng();
      const item = document.createElement('div');
      item.className = 'cm-item';
      item.style.opacity = hidden ? '0.45' : '1';
      item.innerHTML = `
        <div class="cm-emoji" style="background:${color}22;border-radius:8px;font-size:20px">${emoji}</div>
        <div class="cm-info">
          <div class="cm-name">${escHtml(label + ': ' + track.name)}</div>
          <div class="cm-cat">${escHtml(catLabel)} · ${pos.lat.toFixed(4)}, ${pos.lng.toFixed(4)}</div>
        </div>
        <div class="cm-actions">
          <button class="cm-act-btn" title="Auf Karte zeigen"
            onclick="closeSettings();map.setView([${pos.lat},${pos.lng}],17);setTimeout(()=>{const m=trackStore.tracks.find(t=>t.id==='${track.id}');if(m&&m._${type}Mkr)m._${type}Mkr.openPopup();},300)">📍</button>
          <button class="cm-act-btn" title="Zu Strecke zoomen"
            onclick="closeSettings();zoomTrack('${track.id}')">↗</button>
        </div>`;
      container.appendChild(item);
    });
  }

  // ── Abschnitt 3: Eigene Marker ────────────────────────────────
  const cmHdr = document.createElement('div');
  cmHdr.className = 'cm-section-hdr';
  cmHdr.style.marginTop = '12px';
  cmHdr.innerHTML = `<span class="cm-section-title">Eigene Marker</span><span class="cm-section-count">${_cmMarkers.length}</span>`;
  container.appendChild(cmHdr);

  if (!_cmMarkers.length) {
    const empty = document.createElement('div');
    empty.className = 'cm-empty';
    empty.innerHTML = 'Noch keine eigenen Marker<br><span style="font-size:11px">Aktiviere den Marker-Modus und tippe auf der Karte</span>';
    container.appendChild(empty);
  } else {
    _cmMarkers.forEach(cm => {
      const color    = CM_CAT_COLORS[cm.cat] || '#888';
      const catLabel = CATS[cm.cat]?.label || cm.cat;
      const emoji    = cm.emoji || '📍';
      const item = document.createElement('div');
      item.className = 'cm-item';
      item.innerHTML = `
        <div class="cm-emoji" style="background:${color}22;border-radius:8px">${emoji}</div>
        <div class="cm-info">
          <div class="cm-name">${escHtml(cm.name)}</div>
          <div class="cm-cat">${escHtml(catLabel)} · ${cm.lat.toFixed(4)}, ${cm.lng.toFixed(4)}</div>
          ${cm.desc ? `<div class="cm-desc">${escHtml(cm.desc.substring(0, 60))}${cm.desc.length > 60 ? '…' : ''}</div>` : ''}
        </div>
        <div class="cm-actions">
          <button class="cm-act-btn" title="Auf Karte zeigen"
            onclick="closeSettings();map.setView([${cm.lat},${cm.lng}],17);setTimeout(()=>{ if(_cmLeafletLayers['${cm.id}']) _cmLeafletLayers['${cm.id}'].openPopup(); },300)">${emoji}</button>
          <button class="cm-act-btn" title="Teilen" onclick="openCmShareQr('${cm.id}')">📤</button>
          <button class="cm-act-btn" title="Bearbeiten" onclick="openMdModal('${cm.id}')">✏</button>
          <button class="cm-act-btn del" title="Löschen" onclick="deleteCmMarker('${cm.id}')">🗑</button>
        </div>`;
      container.appendChild(item);
    });
  }
}

// Rückwärts-kompatibler Alias
function renderCmList() { renderAllMarkersList(); }

// LOCS-Überschreibung zurücksetzen
function resetLocsMarker(id) {
  if (!confirm('Marker auf Standardwerte zurücksetzen?')) return;
  delete _locsOverrides[id];
  _saveLocsState();
  reloadLocsMarkers();
  renderAllMarkersList();
  toast('↺ Marker zurückgesetzt');
}

// Marker als JSON exportieren
function exportMarkersJson() {
  if (!_cmMarkers.length) { toast('⚠️ Keine Marker vorhanden'); return; }
  const json  = JSON.stringify({ type: 'gmtw-markers', markers: _cmMarkers }, null, 2);
  const fname = `GMTW_Marker_${new Date().toISOString().slice(0,10)}.json`;
  dlFile(fname, json, 'application/json');
  toast(`✅ ${_cmMarkers.length} Marker exportiert`);
}

// Marker aus JSON importieren (Merge)
function importMarkersJson(input) {
  const file = input.files && input.files[0];
  if (!file) return;
  input.value = '';
  const reader = new FileReader();
  reader.onload = async (ev) => {
    try {
      const data = JSON.parse(ev.target.result);
      let list = [];
      if (Array.isArray(data)) list = data;
      else if (Array.isArray(data.markers)) list = data.markers;
      else if (data.type === 'gmtw-marker') list = [data];
      if (!list.length) { toast('⚠️ Keine Marker in der Datei gefunden'); return; }
      // Merge: keine Duplikate (per id)
      let added = 0;
      list.forEach(cm => {
        if (!cm.lat || !cm.lng || !cm.name) return;
        if (!cm.id) cm.id = 'cm_' + Date.now() + '_' + Math.random().toString(36).slice(2);
        const exists = _cmMarkers.findIndex(m => m.id === cm.id);
        if (exists >= 0) _cmMarkers[exists] = { ...cm };
        else { _cmMarkers.push({ ...cm }); added++; }
      });
      await _saveCustomMarkers();
      // Karte neu rendern
      _cmMarkers.forEach(cm => _renderOneCmMarker(cm));
      renderAllMarkersList();
      toast(`✅ ${added} Marker importiert`);
    } catch(e) {
      toast('❌ Import fehlgeschlagen: ' + e.message);
    }
  };
  reader.onerror = () => toast('❌ Datei nicht lesbar');
  reader.readAsText(file, 'utf-8');
}

// Marker manuell erstellen (ohne Karten-Klick)
function openMdModalManual() {
  // Aktuelle Kartenposition als Standard
  const c = map.getCenter();
  openMdModal(null, c.lat, c.lng);
}

// ══════════════════════════════════════════════════════════════
// ── GPS EMOJI — dynamisches Icon mit Zoom-Skalierung ──────────
// ══════════════════════════════════════════════════════════════

// Berechne Icon-Größe relativ zum Zoom-Level UND Marker-Skalierung
// Zoom-Basis: 20px (zoom 10) bis 52px (zoom 20), dann mit _markerScale multipliziert
function _calcGpsIconSize(zoom) {
  const minZ = 10, maxZ = 20, minS = 20, maxS = 52;
  const base = Math.round(minS + (maxS - minS) * Math.max(0, Math.min(1, (zoom - minZ) / (maxZ - minZ))));
  return Math.round(base * _markerScale);
}

function _buildGpsEmojiIcon(emoji, zoom) {
  const size = _calcGpsIconSize(zoom);
  const half = size / 2;
  const html = `<div style="
    position:relative;width:${size}px;height:${size}px;
    display:flex;align-items:center;justify-content:center">
    <div style="position:absolute;width:${size*1.6}px;height:${size*1.6}px;
      border-radius:50%;background:rgba(56,189,248,.12);border:1.5px solid rgba(56,189,248,.3);
      top:50%;left:50%;transform:translate(-50%,-50%)"></div>
    <span style="font-size:${size*0.7}px;line-height:1;position:relative;z-index:1;
      filter:drop-shadow(0 2px 4px rgba(0,0,0,.6))">${emoji}</span>
  </div>`;
  return L.divIcon({
    className: '', html,
    iconSize:   [size, size],
    iconAnchor: [half, half]
  });
}

// Skalierung wenn Zoom-Level sich ändert
map.on('zoomend', function() {
  if (!userMkr || !gpsOn) return;
  const emoji = LS.get(LS.K.GPS_EMOJI, '🦄');
  userMkr.setIcon(_buildGpsEmojiIcon(emoji, map.getZoom()));
});

// _onGpsPos — vollständige Neuimplementierung mit Emoji-Icon und Zoom-Skalierung
// (überschreibt die frühere einfache Version weiter oben via JS-Function-Hoisting)
function _onGpsPos(pos) {
  const {latitude:lat, longitude:lng, accuracy:acc, speed} = pos.coords;
  const fab = document.getElementById('gps-fab');
  const emoji = LS.get(LS.K.GPS_EMOJI, '🦄');
  const zoom  = map.getZoom();

  if (!gpsOn) {
    gpsOn = true;
    fab.classList.remove('spin');
    fab.style.borderColor = 'var(--log)';
    fab.style.borderWidth = '2px';
    if (_gpsAutoFollow) map.flyTo([lat,lng], 17, {animate:true, duration:1});
    toast(`✅ Standort (±${Math.round(acc)}m)`);
  }

  // Emoji-Icon (zoom-skaliert)
  const icon = _buildGpsEmojiIcon(emoji, zoom);
  if (userMkr) map.removeLayer(userMkr);
  userMkr = L.marker([lat,lng], {icon, zIndexOffset:1000})
    .addTo(map)
    .bindPopup(`<div class="p-top"><div class="p-name">Dein Standort</div><div class="p-crds">${lat.toFixed(5)}, ${lng.toFixed(5)}</div><div class="p-desc">Genauigkeit: ±${Math.round(acc)} m${speed!=null&&!isNaN(speed)?' · '+Math.round(speed*3.6)+' km/h':''}</div></div>`);

  if (userAccCircle) userAccCircle.setLatLng([lat,lng]).setRadius(acc);
  else userAccCircle = L.circle([lat,lng],{radius:acc,color:'#38bdf8',fillColor:'#38bdf8',fillOpacity:.06,weight:1,opacity:.4}).addTo(map);

  if (_gpsAutoFollow) map.setView([lat,lng], map.getZoom(), {animate:true, duration:.5});

  if (typeof _onNavGpsUpdate === 'function') _onNavGpsUpdate(lat, lng, acc);
  if (typeof _onRaceGpsUpdate === 'function') _onRaceGpsUpdate(lat, lng, acc, speed);
}

// ══════════════════════════════════════════════════════════════
// ══════════════════════════════════════════════════════════════
// ── PWA INSTALL SYSTEM v3 — Aggressiv & Gerätespezifisch ──────
// ══════════════════════════════════════════════════════════════

const PWA_DECLINE_KEY  = 'gmtw_install_decline_ts';  // Letztes Ablehnen (Timestamp)
const PWA_DECLINE_PERM = 'gmtw_install_decline_perm'; // Permanent abgelehnt
const PWA_REASK_MS     = 24 * 60 * 60 * 1000;         // 1 Tag — täglich erneut fragen

let _deferredInstallPrompt = null;

// ── Detaillierte Geräteerkennung ────────────────────────────
function _detectDevice() {
  const ua  = navigator.userAgent || '';
  // Plattform
  const isIOS     = /ipad|iphone|ipod/i.test(ua) && !window.MSStream;
  const isAndroid = /android/i.test(ua);
  const isDesktop = !isIOS && !isAndroid;
  // Browser (Reihenfolge wichtig: spezifischste zuerst)
  const isSamsung = /samsungbrowser/i.test(ua);
  const isEdge    = /edg\//i.test(ua);
  const isOpera   = /opr\/|opera/i.test(ua);
  const isFirefox = /firefox/i.test(ua);
  const isBrave   = (typeof navigator.brave !== 'undefined');
  const isSafari  = /safari/i.test(ua) && !/chrome/i.test(ua) && !isSamsung;
  const isChrome  = /chrome/i.test(ua) && !isSamsung && !isEdge && !isOpera && !isBrave;
  // Android-Gerätemarke
  let brand = 'android', brandLabel = 'Android';
  if (isAndroid) {
    if      (/samsung|sm-[a-z]/i.test(ua))          { brand='samsung';  brandLabel='Samsung'; }
    else if (/huawei|honor|hms/i.test(ua))           { brand='huawei';   brandLabel='Huawei'; }
    else if (/xiaomi|miui|redmi|poco/i.test(ua))     { brand='xiaomi';   brandLabel='Xiaomi'; }
    else if (/pixel/i.test(ua))                      { brand='google';   brandLabel='Google Pixel'; }
    else if (/oneplus/i.test(ua))                    { brand='oneplus';  brandLabel='OnePlus'; }
    else if (/motorola|moto\s/i.test(ua))            { brand='motorola'; brandLabel='Motorola'; }
    else if (/sony|xperia/i.test(ua))                { brand='sony';     brandLabel='Sony'; }
    else if (/oppo/i.test(ua))                       { brand='oppo';     brandLabel='OPPO'; }
    else if (/realme/i.test(ua))                     { brand='realme';   brandLabel='Realme'; }
    else if (/vivo/i.test(ua))                       { brand='vivo';     brandLabel='Vivo'; }
  }
  // Browser-Name + Icon
  let browserName='Browser', browserIcon='🌐';
  if      (isSamsung)  { browserName='Samsung Internet'; browserIcon='🌐'; }
  else if (isEdge)     { browserName='Edge';    browserIcon='🔵'; }
  else if (isOpera)    { browserName='Opera';   browserIcon='🔴'; }
  else if (isFirefox)  { browserName='Firefox'; browserIcon='🦊'; }
  else if (isBrave)    { browserName='Brave';   browserIcon='🦁'; }
  else if (isChrome)   { browserName='Chrome';  browserIcon='🟢'; }
  else if (isSafari)   { browserName='Safari';  browserIcon='🔵'; }
  // Bereits installiert?
  const isStandalone = window.matchMedia('(display-mode: standalone)').matches
    || (typeof navigator.standalone !== 'undefined' && navigator.standalone === true)
    || document.referrer.startsWith('android-app://');
  return {
    isIOS, isAndroid, isDesktop,
    isSamsung, isEdge, isOpera, isFirefox, isBrave, isChrome, isSafari,
    brand, brandLabel, browserName, browserIcon,
    isStandalone, canDirectInstall: !!_deferredInstallPrompt,
  };
}

// ── Gerätespezifische Schritt-Anleitung ──────────────────────
function _getInstallSteps(dev) {
  const { isIOS, isAndroid, isDesktop, isSamsung, isFirefox, isEdge, isChrome, isSafari } = dev;
  if (isIOS && isSafari) return `<strong>Safari auf iPhone / iPad:</strong><br>
    1️⃣ Tippe das <strong>Teilen-Symbol ⎙</strong> unten in der Leiste<br>
    2️⃣ Scrolle → wähle <strong>„Zum Home-Bildschirm"</strong><br>
    3️⃣ Tippe <strong>„Hinzufügen"</strong> — fertig! 🎉`;
  if (isIOS) return `<strong>iOS Browser:</strong><br>
    1️⃣ Öffne diese Seite in <strong>Safari</strong><br>
    2️⃣ Tippe Teilen <strong>⎙</strong> → <strong>„Zum Home-Bildschirm"</strong><br>
    3️⃣ Tippe <strong>„Hinzufügen"</strong> — fertig! 🎉`;
  if (isSamsung) return `<strong>Samsung Internet:</strong><br>
    1️⃣ Tippe das <strong>Menü ≡</strong> unten rechts<br>
    2️⃣ Wähle <strong>„Seite hinzufügen zu"</strong><br>
    3️⃣ Wähle <strong>„Startseite"</strong> — fertig! 🎉`;
  if (isFirefox && isAndroid) return `<strong>Firefox auf Android:</strong><br>
    1️⃣ Tippe das <strong>Menü ⋮</strong> oben rechts<br>
    2️⃣ Wähle <strong>„Zum Startbildschirm hinzufügen"</strong><br>
    3️⃣ Tippe <strong>„Hinzufügen"</strong> — fertig! 🎉`;
  if (isFirefox && isDesktop) return `<strong>Firefox Desktop:</strong><br>
    Für beste PWA-Erfahrung öffne diese Seite in <strong>Chrome</strong> oder <strong>Edge</strong>.<br>
    Dort erscheint ein Install-Symbol in der Adressleiste.`;
  if (isEdge && isDesktop) return `<strong>Microsoft Edge:</strong><br>
    1️⃣ Klicke das <strong>Install-Symbol ⊕</strong> in der Adressleiste<br>
    2️⃣ Oder: Menü <strong>···</strong> → <strong>Apps</strong> → <strong>„Diese Seite als App installieren"</strong><br>
    3️⃣ Klicke <strong>„Installieren"</strong> — fertig! 🎉`;
  if (isChrome && isDesktop) return `<strong>Chrome auf Desktop:</strong><br>
    1️⃣ Klicke das <strong>Install-Symbol ⊕</strong> rechts in der Adressleiste<br>
    2️⃣ Oder: Menü <strong>⋮</strong> → <strong>„GMTW Map installieren"</strong><br>
    3️⃣ Klicke <strong>„Installieren"</strong> — fertig! 🎉`;
  if (isChrome && isAndroid) return `<strong>Chrome auf Android:</strong><br>
    1️⃣ Tippe das <strong>Menü ⋮</strong> oben rechts<br>
    2️⃣ Wähle <strong>„App installieren"</strong> oder <strong>„Zum Startbildschirm"</strong><br>
    3️⃣ Tippe <strong>„Installieren"</strong> — fertig! 🎉`;
  // Fallback
  return `<strong>Browser-Menü öffnen:</strong><br>
    Tippe <strong>⋮</strong> oder <strong>≡</strong> und suche nach<br>
    <strong>„App installieren"</strong> oder <strong>„Zum Startbildschirm"</strong>`;
}

// ── Banner-Anzeige (gerätespezifisch) ──────────────────────
function _showPwaInstall() {
  const panel = document.getElementById('pwa-install');
  if (!panel) return;
  const dev = _detectDevice();
  if (dev.isStandalone) return; // Bereits installiert
  // Badge befüllen
  const badge = document.getElementById('pi-device-badge');
  if (badge) {
    const platform = dev.isIOS ? '🍎 iOS' : dev.isAndroid ? '🤖 ' + dev.brandLabel : '🖥️ Desktop';
    badge.textContent = `${dev.browserIcon} ${dev.browserName} · ${platform}`;
  }
  // Installations-Schritte befüllen
  const steps = document.getElementById('pi-steps');
  if (steps) steps.innerHTML = _getInstallSteps(dev);
  // Install-Button konfigurieren
  const btn = document.getElementById('pi-install-btn');
  if (btn) {
    if (dev.canDirectInstall) {
      btn.textContent = '📲 Jetzt installieren';
      btn.onclick = triggerPwaInstall;
      btn.style.display = '';
    } else if (dev.isIOS || (dev.isFirefox && dev.isDesktop)) {
      btn.style.display = 'none'; // Nur Anleitung, kein direkter Install
    } else {
      btn.textContent = '📖 Anleitung anzeigen';
      btn.onclick = () => { /* Anleitung bereits sichtbar */ };
      btn.style.display = '';
    }
  }
  panel.classList.add('show');
}

function _hidePwaInstall() {
  const p = document.getElementById('pwa-install');
  if (p) p.classList.remove('show');
}

// ── Banner ablehnen ──────────────────────────────────────────
function dismissPwaInstall(permanent) {
  _hidePwaInstall();
  if (permanent) {
    localStorage.setItem(PWA_DECLINE_PERM, '1');
  } else {
    localStorage.setItem(PWA_DECLINE_KEY, String(Date.now()));
  }
}

// ── Direkter Install-Prompt (Chrome/Edge/Samsung) ───────────
async function triggerPwaInstall() {
  if (!_deferredInstallPrompt) {
    // Kein direkter Prompt → Anleitung im Banner zeigen
    _showPwaInstall();
    return;
  }
  try {
    _deferredInstallPrompt.prompt();
    const choice = await _deferredInstallPrompt.userChoice;
    _deferredInstallPrompt = null;
    _hidePwaInstall();
    if (choice.outcome === 'accepted') {
      toast('🎉 App wird installiert…');
    } else {
      localStorage.setItem(PWA_DECLINE_KEY, String(Date.now()));
    }
  } catch(e) {
    _hidePwaInstall();
    console.warn('[PWA] Install prompt error:', e);
  }
}

// ── Prüfen ob Banner gezeigt werden darf (Sperre) ───────────
function _canShowInstall() {
  if (localStorage.getItem(PWA_DECLINE_PERM)) return false;
  const ts = parseInt(localStorage.getItem(PWA_DECLINE_KEY) || '0', 10);
  return !ts || (Date.now() - ts) > PWA_REASK_MS;
}

// ── beforeinstallprompt: Chrome/Edge/Samsung abfangen ────────
window.addEventListener('beforeinstallprompt', (e) => {
  e.preventDefault();
  _deferredInstallPrompt = e;
  if (_canShowInstall()) {
    setTimeout(_showPwaInstall, 2000); // 2s nach Seitenload
  }
});

// ── App erfolgreich installiert ──────────────────────────────
window.addEventListener('appinstalled', () => {
  _hidePwaInstall();
  toast('🎉 App installiert! Genieße die Trails offline.');
  _deferredInstallPrompt = null;
  localStorage.setItem(PWA_DECLINE_PERM, '1');
  // App-Tab aktualisieren
  const tab = document.getElementById('sp-tab-app');
  if (tab && tab.classList.contains('on')) _initAppInstallTab();
});

// ── iOS / Firefox: kein beforeinstallprompt → Anleitung ──────
function _checkIosInstall() {
  const dev = _detectDevice();
  if (dev.isStandalone || !_canShowInstall()) return;
  // iOS Safari
  if (dev.isIOS && dev.isSafari) {
    setTimeout(_showPwaInstall, 4000);
    return;
  }
  // Firefox Mobile
  if (dev.isFirefox && dev.isAndroid) {
    setTimeout(_showPwaInstall, 5000);
    return;
  }
}

// ── openInstallGuide: aus Einstellungen heraus ───────────────
function openInstallGuide() {
  closeSettings();
  const dev = _detectDevice();
  if (dev.isStandalone) { toast('✅ App ist bereits installiert!'); return; }
  if (dev.canDirectInstall) { triggerPwaInstall(); return; }
  setTimeout(_showPwaInstall, 250);
}

// ── App-Install-Tab Initialisierung ─────────────────────────
function _initAppInstallTab() {
  const dev = _detectDevice();
  // Status-Karte
  const statusEl = document.getElementById('ai-status-card');
  if (statusEl) {
    if (dev.isStandalone) {
      statusEl.className = 'ai-status-card installed';
      statusEl.innerHTML = `<div class="ai-status-icon">✅</div>
        <div><div class="ai-status-label">App installiert</div>
        <div class="ai-status-sub">Läuft als eigenständige PWA</div></div>`;
    } else {
      statusEl.className = 'ai-status-card not-installed';
      statusEl.innerHTML = `<div class="ai-status-icon">📲</div>
        <div><div class="ai-status-label">Nicht installiert</div>
        <div class="ai-status-sub">Als App auf diesem Gerät installierbar</div></div>`;
    }
  }
  // Geräte-Info
  const infoEl = document.getElementById('ai-device-info');
  if (infoEl) {
    const swOk = 'serviceWorker' in navigator && navigator.serviceWorker.controller;
    const platform = dev.isIOS ? '🍎 Apple iOS' : dev.isAndroid ? ('🤖 ' + dev.brandLabel + ' Android') : '🖥️ Desktop';
    infoEl.innerHTML =
      `<strong>Gerät:</strong> ${platform} &nbsp;·&nbsp; <strong>Browser:</strong> ${dev.browserIcon} ${dev.browserName}<br>` +
      `<strong>Direct-Install:</strong> ${dev.canDirectInstall ? '✅ Verfügbar' : '❌ Anleitung nötig'} &nbsp;·&nbsp; ` +
      `<strong>Service Worker:</strong> ${swOk ? '✅ Aktiv (Offline OK)' : '⏳ Noch nicht aktiv'}`;
  }
  // Install-Button
  const instBtn = document.getElementById('ai-install-btn');
  if (instBtn) {
    if (dev.isStandalone) {
      instBtn.textContent = '✅ Bereits installiert';
      instBtn.disabled = true; instBtn.style.opacity = '.5';
    } else if (dev.canDirectInstall) {
      instBtn.textContent = '📲 App jetzt installieren';
      instBtn.disabled = false; instBtn.style.opacity = '';
      instBtn.onclick = () => { closeSettings(); setTimeout(triggerPwaInstall, 200); };
    } else {
      instBtn.textContent = '📖 Installationsanleitung öffnen';
      instBtn.disabled = false; instBtn.style.opacity = '';
      instBtn.onclick = () => { closeSettings(); setTimeout(_showPwaInstall, 300); };
    }
  }
  // Anleitung befüllen
  const stepsEl = document.getElementById('ai-steps-box');
  if (stepsEl) stepsEl.innerHTML = _getInstallSteps(dev);
  // Cache-Infos
  _updateAiCacheInfo();
}

// ── Cache-Statistik für App-Tab ──────────────────────────────
function _updateAiCacheInfo() {
  if (!navigator.serviceWorker || !navigator.serviceWorker.controller) {
    const tot = document.getElementById('ai-cache-total');
    if (tot) tot.textContent = '–';
    return;
  }
  const ch = new MessageChannel();
  ch.port1.onmessage = (e) => {
    const d = e.data || {};
    const set = (id, val) => { const el = document.getElementById(id); if (el) el.textContent = val; };
    set('ai-cache-total', d.total || 0);
    set('ai-cache-tiles', d.tileCount || 0);
    set('ai-cache-shell', d.shellCount || 0);
    set('ai-cache-gpx',   d.gpxCount  || 0);
    set('ai-cache-fonts', d.fontCount || 0);
    const bar = document.getElementById('ai-tile-bar');
    if (bar) bar.style.width = Math.min(100, ((d.tileCount || 0) / 3000 * 100)) + '%';
  };
  navigator.serviceWorker.controller.postMessage({ type: 'GET_CACHE_SIZE' }, [ch.port2]);
}

// ── Karten-Bereich für Offline vorab cachen ──────────────────
function cacheCurrentMapArea() {
  if (!map) { toast('⚠️ Karte noch nicht geladen'); return; }
  const zoom = map.getZoom();
  if (zoom < 12) { toast('⚠️ Bitte zuerst auf das Trail-Gebiet zoomen (min. Zoom 12)!', 3500); return; }
  const bounds = map.getBounds();
  const urls = [];
  const subdomains = ['a','b','c'];
  for (let z = Math.max(12, zoom - 1); z <= Math.min(18, zoom + 2); z++) {
    const nw = L.CRS.EPSG3857.latLngToPoint(bounds.getNorthWest(), z).divideBy(256);
    const se = L.CRS.EPSG3857.latLngToPoint(bounds.getSouthEast(), z).divideBy(256);
    const x0 = Math.floor(nw.x), x1 = Math.floor(se.x);
    const y0 = Math.floor(nw.y), y1 = Math.floor(se.y);
    for (let x = x0; x <= x1; x++) {
      for (let y = y0; y <= y1; y++) {
        const s = subdomains[Math.abs(x + y) % 3];
        urls.push(`https://${s}.tile.openstreetmap.org/${z}/${x}/${y}.png`);
        urls.push(`https://tile.opentopomap.org/${z}/${x}/${y}.png`);
      }
    }
  }
  if (urls.length > 800) {
    toast(`⚠️ ${urls.length} Tiles — bitte weiter einzoomen!`, 3500);
    return;
  }
  if (!navigator.serviceWorker || !navigator.serviceWorker.controller) {
    toast('⚠️ Service Worker noch nicht bereit — kurz warten'); return;
  }
  toast(`⏳ Lade ${urls.length} Karten-Tiles für Offline-Betrieb…`, 4000);
  const ch = new MessageChannel();
  ch.port1.onmessage = (e) => {
    if (e.data?.success) {
      toast(`✅ ${e.data.count} Tiles gecacht — Karte nun offline verfügbar!`);
      _updateAiCacheInfo();
    }
  };
  navigator.serviceWorker.controller.postMessage({ type: 'PREFETCH_TILES', urls }, [ch.port2]);
}

// ══════════════════════════════════════════════════════════════
// ── QR-CODE SCANNER ────────────────────────────────────────────
// Verarbeitet QR-Codes von anderen GMTW-Geräten:
//   • Einzelner GPX-URL-Link → Track laden
//   • GMTW-GPX-Bündel {type:"gmtw-gpx-bundle", tracks:[...]} → Mehrere laden
//   • GMTW-Backup {_app:"GMTW Trail Map",...} → Import
//   • GMTW-Marker {type:"gmtw-marker",...} → Marker importieren
// ══════════════════════════════════════════════════════════════

const LS_QR_ENABLED = 'gmtw_qr_scanner_enabled';
let _qrVideoStream   = null;   // MediaStream
let _qrScanInterval  = null;   // setInterval handle
let _qrLastResult    = '';     // Letztes erkanntes QR-Ergebnis (Deduplizierung)
let _qrPendingData   = null;   // Geparster Payload für onclick-Handler (kein JSON.stringify in HTML-Attr)
// Multi-QR Chunk-Puffer: { [chunkId]: { chunks: string[], total: number, received: Set } }
const _qrChunkBuffer = {};

function onQrScanToggle(enabled) {
  LS.set(LS_QR_ENABLED, enabled);
  _updateQrToggleUI(enabled);
  if (enabled) {
    document.getElementById('sp-qr-scanner-area').style.display = '';
    startQrScanner();
  } else {
    stopQrScanner();
    document.getElementById('sp-qr-scanner-area').style.display = 'none';
  }
}

function _updateQrToggleUI(enabled) {
  const track = document.getElementById('sp-qr-toggle-track');
  const thumb = document.getElementById('sp-qr-toggle-thumb');
  const chk   = document.getElementById('sp-qr-enabled');
  if (chk) chk.checked = enabled;
  if (track) track.style.background = enabled ? 'var(--ac)' : 'var(--bd2)';
  if (thumb) thumb.style.transform  = enabled ? 'translateX(18px)' : 'translateX(0)';
}

async function startQrScanner() {
  if (!window.jsQR) { toast('⚠️ QR-Bibliothek nicht geladen'); return; }
  const video = document.getElementById('qr-video');
  if (!video) return;
  // Bereits aktiv → nicht neu starten (verhindert doppelten Stream)
  if (_qrVideoStream) return;

  // Kamera anfordern (rear-facing bevorzugen)
  try {
    _qrVideoStream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: { ideal: 'environment' }, width: { ideal: 640 }, height: { ideal: 640 } }
    });
    video.srcObject = _qrVideoStream;
    await video.play();
    _qrLastResult = '';

    // Alle 200ms einen Frame prüfen
    _qrScanInterval = setInterval(_scanQrFrame, 200);
    document.getElementById('qr-scan-status').textContent = 'QR-Code in den Rahmen halten…';

  } catch(e) {
    const msg = e.name === 'NotAllowedError' ? 'Kamerazugriff verweigert — bitte in Browser-Einstellungen erlauben.' : e.message;
    toast('❌ Kamera: ' + msg);
    document.getElementById('qr-scan-status').textContent = '❌ ' + msg;
    // Toggle zurücksetzen
    onQrScanToggle(false);
  }
}

function stopQrScanner() {
  if (_qrScanInterval) { clearInterval(_qrScanInterval); _qrScanInterval = null; }
  if (_qrVideoStream)  { _qrVideoStream.getTracks().forEach(t => t.stop()); _qrVideoStream = null; }
  const video = document.getElementById('qr-video');
  if (video) { video.srcObject = null; }
  _qrLastResult = '';
}

function _scanQrFrame() {
  const video  = document.getElementById('qr-video');
  const canvas = document.getElementById('qr-canvas-scan');
  if (!video || !canvas || video.readyState < 2) return;

  const W = video.videoWidth, H = video.videoHeight;
  if (!W || !H) return;

  canvas.width  = W;
  canvas.height = H;
  const ctx = canvas.getContext('2d');
  ctx.drawImage(video, 0, 0, W, H);
  const imgData = ctx.getImageData(0, 0, W, H);

  const result = jsQR(imgData.data, W, H, { inversionAttempts: 'dontInvert' });
  if (!result || result.data === _qrLastResult) return;

  _qrLastResult = result.data;
  document.getElementById('qr-scan-status').textContent = '✅ QR erkannt!';
  _processQrPayload(result.data);
}

// QR-Inhalt verarbeiten
// WICHTIG: JSON.stringify nie direkt in onclick-Attributen verwenden (bricht HTML).
// Stattdessen: _qrPendingData als Brücke zwischen Scan und Import-Button nutzen.
async function _processQrPayload(raw) {
  const resultEl = document.getElementById('qr-scan-result');
  if (resultEl) { resultEl.style.display = ''; resultEl.textContent = '⏳ Verarbeite…'; }

  try {
    // Versuche JSON-Parse
    let data = null;
    try { data = JSON.parse(raw); } catch(e) {}

    // Geparsten Payload sichern (für onclick-Handler — kein JSON.stringify im HTML-Attribut!)
    _qrPendingData = data || raw;

    // ── Fall 0: GMTW Multi-QR Chunk ─────────────────────────────
    if (data && data.T === 'gmtw-chunk' && data.v === 1) {
      await _handleQrChunk(data, resultEl);
      return;
    }

    // ── Fall 1: GMTW Vollständiges Backup ───────────────────────
    if (data && data._app && data._app.includes('GMTW')) {
      const exported = data._exported ? new Date(data._exported).toLocaleDateString('de') : '?';
      if (resultEl) resultEl.innerHTML =
        `<strong>📦 GMTW Backup erkannt</strong><br>Exportiert: ${exported}<br>
         <button class="sp-btn prim" onclick="importFullBackup_fromObj()"
           style="margin-top:8px;width:100%;justify-content:center">⬇ Backup importieren</button>`;
      return;
    }

    // ── Fall 2: GPX-Bündel (mehrere Tracks via URL) ─────────────
    if (data && data.type === 'gmtw-gpx-bundle' && Array.isArray(data.tracks)) {
      const count = data.tracks.length;
      const list  = data.tracks.map(t => `<div>• ${escHtml(t.name || t.url)}</div>`).join('');
      if (resultEl) resultEl.innerHTML =
        `<strong>📦 GPX-Bündel: ${count} Track${count>1?'s':''}</strong><br>${list}<br>
         <button class="sp-btn prim" onclick="importGpxBundle()"
           style="margin-top:8px;width:100%;justify-content:center">⬇ Alle ${count} importieren</button>`;
      return;
    }

    // ── Fall 3: Einzel-Custom-Marker ────────────────────────────
    if (data && data.type === 'gmtw-marker') {
      const latStr = typeof data.lat === 'number' ? data.lat.toFixed(5) : String(data.lat);
      const lngStr = typeof data.lng === 'number' ? data.lng.toFixed(5) : String(data.lng);
      if (resultEl) resultEl.innerHTML =
        `<strong>📍 Marker: ${escHtml(data.name)}</strong><br>${escHtml(data.cat||'')} · ${latStr}, ${lngStr}<br>
         <button class="sp-btn prim" onclick="importQrMarker()"
           style="margin-top:8px;width:100%;justify-content:center">📍 Marker hinzufügen</button>`;
      return;
    }

    // ── Fall 4: Direkte GPX-URL ──────────────────────────────────
    const url = raw.trim();
    if (url.startsWith('http') && url.toLowerCase().includes('.gpx')) {
      if (resultEl) resultEl.innerHTML =
        `<strong>📄 GPX-URL erkannt</strong><br>
         <code style="font-size:10px;word-break:break-all">${escHtml(url)}</code><br>
         <button class="sp-btn prim" onclick="loadGpxFromUrl_url()"
           style="margin-top:8px;width:100%;justify-content:center">⬇ Track laden</button>`;
      return;
    }

    // ── Fall 5: Unbekannter Inhalt ───────────────────────────────
    if (resultEl) resultEl.innerHTML =
      `<strong>QR-Inhalt:</strong><br>
       <code style="font-size:10px;word-break:break-all;color:var(--td)">${escHtml(raw.slice(0,200))}${raw.length>200?'…':''}</code>`;

  } catch(e) {
    if (resultEl) resultEl.innerHTML = `<div style="color:var(--tm)">❌ Fehler: ${escHtml(e.message)}</div>`;
  }
}

// ═══════════════════════════════════════════════════════════════
// EMPFÄNGER-SEITE: Chunk-Sammlung, Dekomprimierung, GPX-Import
// ═══════════════════════════════════════════════════════════════

// ── Chunk-Empfang (aufgerufen von _processQrPayload) ──────────
// buf-Struktur: { chunks[], total, received:Set, z, ts }
async function _handleQrChunk(data, resultEl) {
  const { id, i, n, d, z } = data;

  // Validierung aller Pflichtfelder
  if (typeof id !== 'string' || id.length < 1 ||
      typeof i  !== 'number' || i  < 0 ||
      typeof n  !== 'number' || n  < 1 ||
      typeof d  !== 'string' || !d.length) {
    if (resultEl) resultEl.innerHTML =
      `<div style="color:var(--tm)">❌ Ungültiger Chunk-Header</div>`;
    return;
  }

  // Puffer anlegen (bei erstem Chunk dieser Transfer-ID)
  if (!_qrChunkBuffer[id]) {
    _qrChunkBuffer[id] = {
      chunks:   new Array(n).fill(null),
      total:    n,
      received: new Set(),
      z:        typeof z === 'number' ? z : 1, // z-Flag: 1=pako, 0=raw
      ts:       Date.now()                     // Zeitstempel für Auto-Cleanup
    };
    // Auto-Cleanup nach 15 Minuten (verhindert Speicherlecks)
    setTimeout(() => { delete _qrChunkBuffer[id]; }, 15 * 60 * 1000);
  }

  const buf = _qrChunkBuffer[id];

  // Chunk einlagern — Set verhindert Duplikate
  if (!buf.received.has(i)) {
    buf.chunks[i] = d;
    buf.received.add(i);
  }

  const recv = buf.received.size;

  // ── Noch nicht vollständig: Fortschritt zeigen ────────────
  if (recv < n) {
    // Welche Chunks fehlen noch?
    const missing = [];
    for (let k = 0; k < n; k++) if (!buf.received.has(k)) missing.push(k + 1);
    const missingTxt = missing.length <= 5
      ? `Noch fehlen: Nr. ${missing.join(', ')}`
      : `Noch ${missing.length} fehlen`;

    // Segment-Balken: grün = erhalten, grau = ausstehend
    const bars = Array.from({length: n}, (_, j) =>
      `<div style="flex:1;height:8px;border-radius:3px;background:${
        buf.received.has(j) ? 'var(--ac)' : 'var(--bd2)'
      };transition:background .2s"></div>`
    ).join('');

    if (resultEl) resultEl.innerHTML =
      `<strong style="font-family:var(--fh)">📡 QR-Track Transfer</strong>`
      + `<div style="font-size:11px;color:var(--td);margin:4px 0">`
      +   `Transfer-ID: <code>${escHtml(id)}</code></div>`
      + `<div style="display:flex;gap:3px;margin:8px 0">${bars}</div>`
      + `<div style="font-size:13px;color:var(--tx);font-weight:700">`
      +   `${recv} / ${n} gescannt ✅</div>`
      + `<div style="font-size:11px;color:var(--td);margin-top:4px">${escHtml(missingTxt)}</div>`
      + `<div style="font-size:11px;color:var(--td);margin-top:6px">`
      +   `→ Nächsten QR-Code in die Kamera halten…</div>`;
    return;
  }

  // ── Alle Chunks empfangen: Import starten ─────────────────
  if (resultEl) resultEl.innerHTML =
    `<div style="color:var(--td);text-align:center;padding:8px 0">`
    + `<div style="font-size:20px">⏳</div>Dekomprimiere & importiere…</div>`;

  const fullData = buf.chunks.join('');
  const compressionFlag = buf.z;
  delete _qrChunkBuffer[id]; // Puffer sofort freigeben

  await _importGmtwTrackData(fullData, compressionFlag, resultEl);
}

// ── Vollständige Daten dekodieren und als Track importieren ───
// b64uData: zusammengesetzter base64url-String
// z:        1 = pako DEFLATE, 0 = plain UTF-8
async function _importGmtwTrackData(b64uData, z, resultEl) {
  try {
    if (!b64uData || !b64uData.length) throw new Error('Leere Daten empfangen');

    // ── Schritt 1: Dekomprimieren / Dekodieren ─────────────
    let jsonStr = null;
    const bytes = _b64uDecode(b64uData);

    if (z === 1 && window.pako) {
      // Primärer Pfad: pako DEFLATE
      try { jsonStr = pako.inflate(bytes, { to: 'string' }); }
      catch(e) { /* Fehler → Fallbacks unten */ }
    }

    if (!jsonStr && window.pako) {
      // Fallback 1: Vielleicht doch DEFLATE trotz z=0?
      try { jsonStr = pako.inflate(bytes, { to: 'string' }); } catch(e) {}
    }

    if (!jsonStr) {
      // Fallback 2: plain UTF-8 (z=0 oder kein pako)
      try { jsonStr = new TextDecoder('utf-8', { fatal: true }).decode(bytes); }
      catch(e) {}
    }

    if (!jsonStr) {
      // Fallback 3: legacy decodeURIComponent-Methode
      try {
        const b64std = b64uData.replace(/-/g,'+').replace(/_/g,'/');
        jsonStr = decodeURIComponent(escape(atob(b64std)));
      } catch(e) {}
    }

    if (!jsonStr) throw new Error('Dekomprimierung fehlgeschlagen (alle Methoden)');

    // ── Schritt 2: JSON parsen ────────────────────────────
    let payload;
    try { payload = JSON.parse(jsonStr); }
    catch(e) { throw new Error('JSON ungültig: ' + e.message.slice(0, 60)); }

    // ── Schritt 3: Payload-Typ erkennen und verarbeiten ───
    if (payload && payload.type === 'gmtw-track' && Array.isArray(payload.p)) {
      await _finishTrackImport(payload, resultEl);
    } else if (payload && payload._app && payload._app.includes('GMTW')) {
      // Vollständiges Backup im Chunk (selten, aber möglich)
      _qrPendingData = payload;
      if (resultEl) resultEl.innerHTML =
        `<button class="sp-btn prim" onclick="importFullBackup_fromObj()"
           style="width:100%;margin-top:8px;justify-content:center">⬇ Backup importieren</button>`;
    } else {
      throw new Error('Unbekanntes Payload-Format (type=' + (payload && payload.type || '?') + ')');
    }

  } catch(e) {
    console.error('_importGmtwTrackData:', e);
    if (resultEl) resultEl.innerHTML =
      `<div style="color:var(--tm);padding:8px 0">❌ Import fehlgeschlagen<br>`
      + `<small style="font-size:10px">${escHtml(e.message)}</small></div>`;
    toast('❌ QR-Import: ' + e.message.slice(0, 80));
  }
}

// ── GPX aus kompaktem Payload aufbauen und in App laden ───────
async function _finishTrackImport(payload, resultEl) {
  const name = String(payload.n || 'QR-Track').slice(0, 200);
  const cat  = ['beginner','mittel','expert'].includes(payload.c) ? payload.c : 'mittel';

  // GPX rekonstruieren
  const gpxStr = _decodeTrackCompactToGpx(payload);
  if (!gpxStr) throw new Error(`Leere Strecke (0 gültige Punkte in ${payload.p.length} Einträgen)`);

  // GPX sanity-check (wie beim normalen Import)
  const san = sanitizeGpx(gpxStr);
  if (!san || !san.startsWith('<')) throw new Error('Rekonstruiertes GPX ungültig');

  // Settings schließen → Map wird sichtbar
  closeSettings();

  // Kurze Verzögerung damit Map den Close-Übergang rendern kann
  await new Promise(r => setTimeout(r, 120));

  // In App importieren — silent=false → Toast + Karte zoomed
  loadGpxXml(san, name, cat, null, null, false);

  // Erfolgs-Feedback im (jetzt geschlossenen) resultEl
  if (resultEl) resultEl.innerHTML =
    `<div style="text-align:center;padding:8px 0">`
    + `<div style="font-size:26px">✅</div>`
    + `<strong style="color:var(--ac);font-family:var(--fh)">${escHtml(name)}</strong><br>`
    + `<span style="font-size:11px;color:var(--td)">`
    +   `${payload.p.length} Punkte · ${escHtml(cat)}</span></div>`;
}

// Import-Helper für QR-Inhalte
// Werden ohne Argument aufgerufen → lesen aus _qrPendingData
async function importGpxBundle(tracks) {
  if (tracks === undefined) {
    // Aufruf über onclick-Button — Daten aus _qrPendingData lesen
    if (!_qrPendingData || !Array.isArray(_qrPendingData.tracks)) { toast('❌ Keine Bündel-Daten'); return; }
    tracks = _qrPendingData.tracks;
  }
  let ok = 0;
  for (const t of tracks) {
    if (!t.url) continue;
    const cat = t.cat || 'mittel';
    const name = t.name || t.url.split('/').pop().replace('.gpx','');
    try {
      const resp = await fetch(t.url);
      if (!resp.ok) throw new Error('HTTP ' + resp.status);
      const txt  = await resp.text();
      const gpxStr = sanitizeGpx(txt);
      if (!gpxStr.startsWith('<')) throw new Error('Kein GPX');
      loadGpxXml(gpxStr, name, cat, null, t.url, true);
      ok++;
    } catch(e) { console.warn('GPX-Bündel Import Fehler:', t.url, e.message); }
  }
  toast(`✅ ${ok}/${tracks.length} Tracks aus QR-Bündel geladen`);
  const el = document.getElementById('qr-scan-result');
  if (el) el.innerHTML = `<div style="color:var(--ac)">✅ ${ok} Tracks importiert!</div>`;
}

function importQrMarker(data) {
  if (data === undefined) {
    if (!_qrPendingData || typeof _qrPendingData !== 'object') { toast('❌ Keine Marker-Daten'); return; }
    data = _qrPendingData;
  }
  const lat = parseFloat(data.lat);
  const lng = parseFloat(data.lng);
  if (isNaN(lat) || isNaN(lng)) { toast('❌ Ungültige Koordinaten im Marker-QR'); return; }
  const cm = {
    id: 'cm_qr_' + Date.now(),
    name:     data.name  || 'Unbekannter Marker',
    cat:      data.cat   || 'logistik',
    emoji:    data.emoji || '📍',
    desc:     data.desc  || '',
    gmapsUrl: data.gmapsUrl || _buildMapsLink(lat, lng),
    lat, lng,
    createdAt: new Date().toISOString()
  };
  _cmMarkers.push(cm);
  _saveCustomMarkers();
  _renderOneCmMarker(cm);
  toast(`📍 Marker "${escHtml(cm.name)}" hinzugefügt`);
  const el = document.getElementById('qr-scan-result');
  if (el) el.innerHTML = `<div style="color:var(--ac)">✅ Marker "${escHtml(cm.name)}" gespeichert!</div>`;
}

function importFullBackup_fromObj(data) {
  // Wie importFullBackup aber mit bereits geparsten Daten
  // Ohne Argument: Daten aus _qrPendingData lesen
  if (data === undefined) {
    if (!_qrPendingData || typeof _qrPendingData !== 'object') { toast('❌ Keine Backup-Daten'); return; }
    data = _qrPendingData;
  }
  if (!data._app || !data._app.includes('GMTW')) { toast('❌ Ungültiges Backup'); return; }
  if (!confirm(`GMTW-Backup importieren?\nAlle bestehenden Daten werden ersetzt.`)) return;
  // Nutze den regulären Import-Pfad als JSON-String
  const fakeFile = new Blob([JSON.stringify(data)], {type:'application/json'});
  const fakeInput = { files: [fakeFile] };
  importFullBackup(fakeInput);
}

function loadGpxFromUrl_url(url) {
  // Ohne Argument: URL aus _qrPendingData lesen
  if (url === undefined) {
    const raw = typeof _qrPendingData === 'string' ? _qrPendingData : '';
    if (!raw.startsWith('http')) { toast('❌ Keine gültige URL'); return; }
    url = raw.trim();
  }
  // Setzt das URL-Feld und lädt
  const inp = document.getElementById('gpx-url-inp');
  if (inp) inp.value = url;
  closeSettings();
  openGpxPanel('load');
  setTimeout(() => loadGpxFromUrl(), 300);
}

// Beim Öffnen des QR-Tabs: Toggle-Zustand aus LS laden
function _initQrTab() {
  const enabled = LS.get(LS_QR_ENABLED, false);
  _updateQrToggleUI(enabled);
  if (enabled) {
    document.getElementById('sp-qr-scanner-area').style.display = '';
    startQrScanner();
  }
}

// ── STRECKEN-TAB: Sub-Navigation ────────────────────────────────────────────
function switchTrkSubTab(name, btn) {
  ['load','notes','features'].forEach(n => {
    const p = document.getElementById('trk-pane-'+n);
    if (p) p.style.display = n === name ? 'block' : 'none';
  });
  document.querySelectorAll('.trk-sub-tab').forEach(b => {
    b.classList.toggle('active', b.dataset.st === name);
  });
  if (name === 'notes')    _buildTrkRatingPanel();
  if (name === 'features') _buildTrkFeaturesPanel();
}

// ── TRACK RATING SYSTEM ─────────────────────────────────────────────────────
const _TRK_RATINGS_KEY = 'gmtw_trk_ratings_v1';
let _trkRatings = {};

function _loadTrkRatings() {
  try { _trkRatings = JSON.parse(localStorage.getItem(_TRK_RATINGS_KEY)||'{}'); } catch(e) {}
}
function _saveTrkRatings() {
  localStorage.setItem(_TRK_RATINGS_KEY, JSON.stringify(_trkRatings));
}

function _buildTrkRatingPanel() {
  const el = document.getElementById('trk-rating-list');
  if (!el) return;
  _loadTrkRatings();
  const tracks = trackStore.tracks;
  if (!tracks.length) {
    el.innerHTML = `<div style="text-align:center;padding:20px;color:var(--td);font-size:13px">
      Keine Strecken geladen.<br>Lade zuerst eine Strecke im Tab "Strecken".
    </div>`;
    _buildTrkStatsSummary();
    return;
  }
  el.innerHTML = tracks.map(t => {
    const r = _trkRatings[t.id] || {};
    const myDiff   = r.diff   || 0;
    const myFun    = r.fun    || 0;
    const myFlow   = r.flow   || 0;
    const myStatus = r.status || 'unbefahren';
    const note     = r.note   || '';
    const catColor = t.color || '#888';
    const statuses = [
      { v:'unbefahren',  l:'🏁 Noch nicht',  c:'var(--td)' },
      { v:'inprogress',  l:'🔥 In Arbeit',   c:'#f59e0b'   },
      { v:'completed',   l:'✅ Geschafft',   c:'var(--ac)' },
      { v:'wip',         l:'🎯 Fast!',        c:'#38bdf8'   },
    ];
    const stHtml = statuses.map(s =>
      `<button onclick="_setTrkStatus('${t.id}','${s.v}',this)" data-status="${s.v}"
        style="padding:5px 8px;border-radius:8px;border:1.5px solid var(--bd2);background:${myStatus===s.v?s.c:'var(--s3)'};
        color:${myStatus===s.v?'#fff':'var(--td)'};font-size:10px;font-weight:700;cursor:pointer;transition:all .15s">${s.l}</button>`
    ).join('');
    const starRow = (label, key, cur) =>
      `<div style="display:flex;align-items:center;gap:6px;margin-bottom:5px">
        <span style="font-size:11px;color:var(--td);width:68px;flex-shrink:0">${label}</span>
        <div style="display:flex;gap:3px">${[1,2,3,4,5].map(i =>
          `<button onclick="_setTrkRating('${t.id}','${key}',${i})" data-k="${key}" data-v="${i}"
            style="font-size:16px;background:none;border:none;cursor:pointer;opacity:${i<=cur?'1':'.2'};transition:opacity .1s">⭐</button>`
        ).join('')}</div>
      </div>`;
    return `<div style="margin-bottom:12px;padding:12px;background:var(--s2);border-radius:12px;border:1px solid var(--bd2)" id="trk-r-${t.id}">
      <div style="display:flex;align-items:center;gap:8px;margin-bottom:10px">
        <span style="width:10px;height:10px;border-radius:50%;background:${catColor};flex-shrink:0;display:inline-block"></span>
        <span style="font-size:13px;font-weight:800;color:var(--tx)">${escHtml(t.name)}</span>
        <span style="font-size:10px;color:var(--td);margin-left:auto">${t.stats?.dist||'?'} km</span>
      </div>
      ${starRow('Schwierigkeit', 'diff', myDiff)}
      ${starRow('Spaßfaktor', 'fun', myFun)}
      ${starRow('Flow-Gefühl', 'flow', myFlow)}
      <div style="display:flex;gap:5px;flex-wrap:wrap;margin-top:8px">${stHtml}</div>
      <textarea data-trk="${t.id}" placeholder="Notizen (Beta, Schlüsselstellen, Ziele…)" maxlength="200"
        style="width:100%;box-sizing:border-box;margin-top:8px;padding:8px;border-radius:8px;
        border:1px solid var(--bd2);background:var(--s1);color:var(--tx);font-size:11px;
        min-height:48px;resize:vertical;font-family:var(--fb)"
        id="trk-note-${t.id}">${escHtml(note)}</textarea>
      <button class="sp-btn sec" style="margin-top:6px;width:100%;justify-content:center"
        onclick="(()=>{_setTrkNote('${t.id}',document.getElementById('trk-note-${t.id}').value);toast('✅ Notiz gespeichert')})()">
        ✓ Notiz speichern</button>
    </div>`;
  }).join('');
  _buildTrkStatsSummary();
}

function _setTrkRating(trackId, key, val) {
  _loadTrkRatings();
  if (!_trkRatings[trackId]) _trkRatings[trackId] = {};
  _trkRatings[trackId][key] = val;
  _saveTrkRatings();
  // Update star display
  const card = document.getElementById('trk-r-'+trackId);
  if (card) {
    card.querySelectorAll(`[data-k="${key}"]`).forEach(b => {
      b.style.opacity = parseInt(b.dataset.v) <= val ? '1' : '.2';
    });
  }
  _buildTrkStatsSummary();
}
function _setTrkStatus(trackId, status, clickedBtn) {
  _loadTrkRatings();
  if (!_trkRatings[trackId]) _trkRatings[trackId] = {};
  _trkRatings[trackId].status = status;
  _saveTrkRatings();
  const statColors = { unbefahren:'var(--td)',inprogress:'#f59e0b',completed:'var(--ac)',wip:'#38bdf8' };
  const card = document.getElementById('trk-r-'+trackId);
  if (card) {
    card.querySelectorAll('[data-status]').forEach(b => {
      const isThis = b.dataset.status === status;
      b.style.background = isThis ? (statColors[status]||'var(--td)') : 'var(--s3)';
      b.style.color = isThis ? '#fff' : 'var(--td)';
    });
  }
  _buildTrkStatsSummary();
}
function _setTrkNote(trackId, note) {
  _loadTrkRatings();
  if (!_trkRatings[trackId]) _trkRatings[trackId] = {};
  _trkRatings[trackId].note = note;
  _saveTrkRatings();
}

function _buildTrkStatsSummary() {
  const el = document.getElementById('trk-stats-summary');
  if (!el) return;
  _loadTrkRatings();
  const total = trackStore.tracks.length;
  const done  = trackStore.tracks.filter(t => _trkRatings[t.id]?.status === 'completed').length;
  const inprog= trackStore.tracks.filter(t => _trkRatings[t.id]?.status === 'inprogress').length;
  const allDiff = trackStore.tracks.map(t=>_trkRatings[t.id]?.diff||0).filter(v=>v>0);
  const avgDiff = allDiff.length ? (allDiff.reduce((a,b)=>a+b,0)/allDiff.length).toFixed(1) : '—';
  const allFun  = trackStore.tracks.map(t=>_trkRatings[t.id]?.fun||0).filter(v=>v>0);
  const avgFun  = allFun.length ? (allFun.reduce((a,b)=>a+b,0)/allFun.length).toFixed(1) : '—';
  const pct = total > 0 ? Math.round((done/total)*100) : 0;
  el.innerHTML = `
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px">
      <div style="padding:10px;background:var(--s2);border-radius:10px;border:1px solid var(--bd2);text-align:center">
        <div style="font-size:24px;font-weight:800;color:var(--ac)">${done}/${total}</div>
        <div style="font-size:10px;color:var(--td);margin-top:2px">Geschafft</div>
      </div>
      <div style="padding:10px;background:var(--s2);border-radius:10px;border:1px solid var(--bd2);text-align:center">
        <div style="font-size:24px;font-weight:800;color:#f59e0b">${inprog}</div>
        <div style="font-size:10px;color:var(--td);margin-top:2px">In Arbeit</div>
      </div>
      <div style="padding:10px;background:var(--s2);border-radius:10px;border:1px solid var(--bd2);text-align:center">
        <div style="font-size:20px;font-weight:800;color:var(--tx)">${avgDiff} ⭐</div>
        <div style="font-size:10px;color:var(--td);margin-top:2px">Ø Schwierigkeit</div>
      </div>
      <div style="padding:10px;background:var(--s2);border-radius:10px;border:1px solid var(--bd2);text-align:center">
        <div style="font-size:20px;font-weight:800;color:var(--tx)">${avgFun} ⭐</div>
        <div style="font-size:10px;color:var(--td);margin-top:2px">Ø Spaßfaktor</div>
      </div>
    </div>
    <div style="margin-top:10px;height:8px;background:var(--s3);border-radius:4px;overflow:hidden">
      <div style="height:100%;width:${pct}%;background:var(--ac);border-radius:4px;transition:width .5s"></div>
    </div>
    <div style="font-size:11px;color:var(--td);text-align:center;margin-top:4px">${pct}% aller Strecken gemeistert</div>
  `;
}

// ── TRAIL FEATURES (Sprünge, Drops, Stellen) ─────────────────────────────────
const _TRK_FEATURES_KEY = 'gmtw_trk_features_v1';
let _trkFeatures  = {};
let _featTrackId  = null;
let _featType     = 'drop';
let _featDiff     = 1;

function _loadTrkFeatures() {
  try { _trkFeatures = JSON.parse(localStorage.getItem(_TRK_FEATURES_KEY)||'{}'); } catch(e) {}
}
function _saveTrkFeatures() {
  localStorage.setItem(_TRK_FEATURES_KEY, JSON.stringify(_trkFeatures));
}

// ── Shared Feature Type Constants ────────────────────────────────
const FEAT_ICONS = {
  drop:'⬇️', steinfeld:'🪨', verblockt:'🪵', steil:'🏔',
  northshore:'🌉', sprung:'🦘', flow:'🌊', aussicht:'👁',
  goal:'🎯', pause:'⛺',
  // legacy aliases
  jump:'🦘', tech:'🪨', rest:'⛺'
};
const FEAT_NAMES = {
  drop:'Drop', steinfeld:'Steinfeld', verblockt:'Verblockt', steil:'Tech. Steil',
  northshore:'Northshore', sprung:'Sprung', flow:'Flow-Sektion', aussicht:'Aussichtspunkt',
  goal:'Ziel', pause:'Pause', jump:'Sprung', tech:'Technisch', rest:'Pause'
};

// ── Feature Location Picker State ────────────────────────────────
let _featPosMap       = null;   // Leaflet mini-map instance
let _featPosGpsWatch  = null;   // geolocation watchId for live GPS
let _featPosDiff      = 1;      // selected difficulty in picker
let _featPosType      = 'drop'; // selected type in picker
let _featPosTrackId   = null;   // track being edited in picker

/** Open the full-screen feature location picker for a track */
function openFeatPosPicker(trackId) {
  _featPosTrackId = trackId || _featTrackId;
  if (!_featPosTrackId) { toast('⚠️ Keine Strecke ausgewählt'); return; }
  const modal = document.getElementById('feat-pos-modal');
  if (!modal) return;
  modal.classList.add('open');
  // Reset state
  _featPosType = 'drop';
  _featPosDiff = 1;
  document.getElementById('feat-pos-name').value = '';
  _buildFeatPosTypeGrid();
  _buildFeatPosStars();
  // Init map after a short delay (modal must be visible for Leaflet size calc)
  setTimeout(() => _initFeatPosMap(_featPosTrackId), 80);
}

/** Build the type selection grid in the picker */
function _buildFeatPosTypeGrid() {
  const grid = document.getElementById('feat-pos-type-grid');
  if (!grid) return;
  const TYPES = ['drop','steinfeld','verblockt','steil','northshore','sprung','flow','aussicht','goal','pause'];
  grid.innerHTML = TYPES.map(t =>
    `<button class="feat-pos-type-btn${t === _featPosType ? ' selected' : ''}"
      onclick="_featPosPickType(this,'${t}')" aria-label="${FEAT_NAMES[t]||t}">
      <span class="type-icon">${FEAT_ICONS[t]||'📍'}</span>
      <span>${FEAT_NAMES[t]||t}</span>
    </button>`
  ).join('');
}

/** Highlight selected type button */
function _featPosPickType(btn, type) {
  _featPosType = type;
  document.querySelectorAll('.feat-pos-type-btn').forEach(b => b.classList.remove('selected'));
  btn.classList.add('selected');
}

/** Build star difficulty rating in the picker */
function _buildFeatPosStars() {
  const el = document.getElementById('feat-pos-stars');
  if (!el) return;
  el.innerHTML = [1,2,3,4,5].map(i =>
    `<span class="feat-pos-star${i <= _featPosDiff ? ' on' : ''}" onclick="_setFeatPosDiff(${i})">⭐</span>`
  ).join('');
}

/** Set difficulty rating in picker */
function _setFeatPosDiff(n) {
  _featPosDiff = n;
  document.querySelectorAll('.feat-pos-star').forEach((s, i) => {
    s.classList.toggle('on', i < n);
  });
}

/** Initialize Leaflet mini-map inside the picker modal */
function _initFeatPosMap(trackId) {
  // Destroy previous instance if any
  if (_featPosMap) { try { _featPosMap.remove(); } catch(e) {} _featPosMap = null; }

  const track = trackStore.tracks.find(t => t.id === trackId);
  const mapEl = document.getElementById('feat-pos-map');
  if (!mapEl) return;

  // Default center: track bounds center or map center
  let center = map.getCenter();
  let zoom   = Math.min(map.getZoom(), 17);
  if (track && track.bounds) {
    try { center = track.bounds.getCenter(); zoom = 16; } catch(e) {}
  }

  _featPosMap = L.map('feat-pos-map', {
    center, zoom,
    zoomControl: true,
    attributionControl: false,
    tap: true,
  });

  // Tile layer (same style as main map)
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19,
    attribution: '© OSM'
  }).addTo(_featPosMap);

  // GPX track overlay
  if (track && track.gpxLayer) {
    try {
      // Re-create polyline from track points
      const pts = [];
      track.gpxLayer.eachLayer(layer => {
        if (!layer.getLatLngs) return;
        const lls = layer.getLatLngs();
        const flat = (lls.length && Array.isArray(lls[0])) ? lls.flat() : lls;
        pts.push(...flat);
      });
      if (pts.length) {
        L.polyline(pts, { color: track.color || '#c8ff00', weight: 4, opacity: 0.9 }).addTo(_featPosMap);
        if (track.bounds) _featPosMap.fitBounds(track.bounds, { padding: [30,30] });
      }
    } catch(e) { console.warn('featPosMap track render:', e); }
  }

  // Existing feature markers
  _loadTrkFeatures();
  const feats = (_trkFeatures[trackId] || []);
  feats.forEach(f => {
    if (f.lat == null || f.lng == null) return;
    L.marker([f.lat, f.lng], {
      icon: L.divIcon({
        html: `<span style="font-size:20px;line-height:1">${FEAT_ICONS[f.type]||'📍'}</span>`,
        className: '', iconSize: [24,24], iconAnchor: [12,12]
      })
    }).bindPopup(`<b>${FEAT_ICONS[f.type]||'📍'} ${escHtml(FEAT_NAMES[f.type]||f.type)}</b><br>${escHtml(f.name||'')}`)
      .addTo(_featPosMap);
  });

  // Coordinate pill: update on every map move
  const coordEl = document.getElementById('feat-pos-coords');
  function _updateCoords() {
    const c = _featPosMap.getCenter();
    if (coordEl) coordEl.textContent = `${c.lat.toFixed(5)}, ${c.lng.toFixed(5)}`;
  }
  _featPosMap.on('move', _updateCoords);
  _updateCoords();
}

/** Toggle live GPS mode in the picker */
function featPosGpsMode() {
  const btn = document.getElementById('feat-pos-gps-btn');
  if (_featPosGpsWatch !== null) {
    // Deactivate
    navigator.geolocation.clearWatch(_featPosGpsWatch);
    _featPosGpsWatch = null;
    if (btn) btn.classList.remove('active');
    return;
  }
  if (!navigator.geolocation) { toast('⚠️ GPS nicht verfügbar'); return; }
  if (btn) btn.classList.add('active');
  _featPosGpsWatch = navigator.geolocation.watchPosition(
    pos => {
      const { latitude: lat, longitude: lng } = pos.coords;
      if (_featPosMap) _featPosMap.setView([lat, lng], Math.max(_featPosMap.getZoom(), 17));
    },
    () => { toast('⚠️ GPS-Fehler'); featPosGpsMode(); /* toggle off */ },
    { enableHighAccuracy: true, timeout: 15000, maximumAge: 2000 }
  );
}

/** Save the feature at the current crosshair center */
function saveFeatFromPicker() {
  if (!_featPosTrackId) { toast('⚠️ Keine Strecke gewählt'); return; }
  if (!_featPosMap) { toast('⚠️ Karte nicht bereit'); return; }
  const name = (document.getElementById('feat-pos-name')?.value || '').trim() || FEAT_NAMES[_featPosType] || _featPosType;
  const center = _featPosMap.getCenter();
  _loadTrkFeatures();
  if (!_trkFeatures[_featPosTrackId]) _trkFeatures[_featPosTrackId] = [];
  _trkFeatures[_featPosTrackId].push({
    type:  _featPosType,
    name,
    diff:  _featPosDiff,
    date:  Date.now(),
    lat:   parseFloat(center.lat.toFixed(6)),
    lng:   parseFloat(center.lng.toFixed(6))
  });
  _saveTrkFeatures();
  const icon = FEAT_ICONS[_featPosType] || '📍';
  _saveTrkEdit(_featPosTrackId, 'feature_add', `${icon} Hinzugefügt: ${name}`, '', name);
  // Render on main map
  const track = trackStore.tracks.find(t => t.id === _featPosTrackId);
  if (track) _renderTrackFeatures(track);
  closeFeatPosPicker();
  loadTrkFeatures(_featPosTrackId);
  toast(`✅ ${icon} ${name} gespeichert!`);
}

/** Close and clean up the picker */
function closeFeatPosPicker() {
  const modal = document.getElementById('feat-pos-modal');
  if (modal) modal.classList.remove('open');
  if (_featPosGpsWatch !== null) {
    navigator.geolocation.clearWatch(_featPosGpsWatch);
    _featPosGpsWatch = null;
    const btn = document.getElementById('feat-pos-gps-btn');
    if (btn) btn.classList.remove('active');
  }
  if (_featPosMap) {
    try { _featPosMap.remove(); } catch(e) {}
    _featPosMap = null;
  }
}

function _buildTrkFeaturesPanel() {
  _loadTrkFeatures();
  const sel = document.getElementById('trk-feat-select');
  if (sel) {
    sel.innerHTML = '<option value="">– Strecke auswählen –</option>'
      + trackStore.tracks.map(t => `<option value="${t.id}">${escHtml(t.name)}</option>`).join('');
    if (_featTrackId) sel.value = _featTrackId;
  }
  if (_featTrackId) openTrkEditor(_featTrackId);
  else {
    const empty = document.getElementById('trk-editor-empty');
    const body  = document.getElementById('trk-editor-body');
    if (empty) empty.style.display = 'block';
    if (body)  body.style.display  = 'none';
  }
}

function loadTrkFeatures(trackId) {
  _featTrackId = trackId;
  _loadTrkFeatures();
  const el    = document.getElementById('trk-feat-list');
  const addEl = document.getElementById('trk-feat-add');
  if (!el) return;
  if (!trackId) { el.innerHTML = ''; if (addEl) addEl.style.display = 'none'; return; }
  if (addEl) addEl.style.display = 'none';
  const feats = (_trkFeatures[trackId] || []);
  const ICONS = FEAT_ICONS;
  const NAMES = FEAT_NAMES;
  if (!feats.length) {
    el.innerHTML = `<div style="padding:16px;background:var(--s2);border-radius:12px;border:1px dashed var(--bd2);text-align:center;color:var(--td)">
      <div style="font-size:28px;margin-bottom:6px">📍</div>
      <div style="font-size:12px;font-weight:700;color:var(--tx);margin-bottom:4px">Noch keine Schlüsselstellen</div>
      <div style="font-size:10px;line-height:1.6;margin-bottom:10px">Drops, Steinfelder, Northshore-Elemente, Sprünge — alles was die Strecke ausmacht</div>
      <button onclick="openFeatPosPicker(_featTrackId)" class="sp-btn prim" style="width:100%;justify-content:center">➕ Schlüsselstelle hinzufügen</button>
    </div>`;
    return;
  }
  const geoFeats = feats.filter(f => f.lat != null && f.lng != null);
  const mapToggleBtn = geoFeats.length
    ? `<button onclick="_toggleFeatMarkers('${escHtml(trackId)}')" class="sp-btn sec" style="justify-content:center;margin-bottom:8px">👁 Karte ein/aus</button>`
    : '';
  el.innerHTML = `<div style="display:flex;gap:6px;margin-bottom:8px">
    <button onclick="openFeatPosPicker(_featTrackId)" class="sp-btn prim" style="flex:1;justify-content:center">➕ Schlüsselstelle hinzufügen</button>
    ${mapToggleBtn}
  </div>`
    + feats.map((f, idx) => {
      const hasPos = f.lat != null && f.lng != null;
      const posTag = hasPos ? `<span style="font-size:9px;padding:1px 5px;border-radius:4px;background:rgba(200,255,0,.15);color:var(--ac);font-weight:700;border:1px solid rgba(200,255,0,.25)">📍 GPS</span>` : '';
      const diff = f.diff || 1;
      const stars = [1,2,3,4,5].map(i => `<span style="opacity:${i<=diff?'1':'.15'};font-size:12px">⭐</span>`).join('');
      const ts = f.date ? new Date(f.date).toLocaleDateString('de-DE', {day:'2-digit', month:'2-digit'}) : '';
      return `<div style="display:flex;align-items:flex-start;gap:10px;padding:10px 12px;background:var(--s2);border-radius:11px;border:1px solid var(--bd2);margin-bottom:6px">
        <span style="font-size:24px;flex-shrink:0;line-height:1.1;margin-top:1px">${ICONS[f.type]||'📍'}</span>
        <div style="flex:1;min-width:0">
          <div style="font-size:12px;font-weight:700;color:var(--tx)">${escHtml(f.name)}</div>
          <div style="display:flex;align-items:center;gap:6px;margin-top:3px;flex-wrap:wrap">
            <span style="font-size:10px;padding:1px 5px;border-radius:4px;background:var(--s3);color:var(--td);font-weight:600">${NAMES[f.type]||f.type}</span>
            <span>${stars}</span>
            ${posTag}
            ${ts ? `<span style="font-size:9px;color:var(--td);margin-left:auto">${ts}</span>` : ''}
          </div>
        </div>
        <button onclick="_deleteFeat('${escHtml(trackId)}',${idx})"
          style="background:rgba(239,68,68,.1);border:1px solid rgba(239,68,68,.25);border-radius:7px;
          font-size:13px;cursor:pointer;color:#ef4444;flex-shrink:0;padding:5px 7px;line-height:1;transition:all .15s"
          title="Entfernen">🗑</button>
      </div>`;
    }).join('');
}

function showFeatAdd() {
  const el = document.getElementById('trk-feat-add');
  if (el) { el.style.display = 'block'; el.scrollIntoView({behavior:'smooth'}); }
}
function cancelFeatAdd() {
  const el = document.getElementById('trk-feat-add');
  if (el) el.style.display = 'none';
}
function selectFeatType(btn, type) {
  _featType = type;
  document.querySelectorAll('.trk-feat-type-btn').forEach(b => {
    const on = b === btn;
    b.style.background   = on ? 'var(--ac)18' : 'var(--s1)';
    b.style.borderColor  = on ? 'var(--ac)'   : 'var(--bd2)';
    b.style.color        = 'var(--tx)';
    b.style.fontWeight   = on ? '900' : '700';
  });
}
function setFeatDiff(val) {
  _featDiff = val;
  document.querySelectorAll('#trk-feat-diff-stars .feat-star').forEach(b => {
    b.style.opacity = parseInt(b.dataset.v) <= val ? '1' : '.35';
  });
}
function saveFeatAdd() {
  if (!_featTrackId) { toast('⚠️ Keine Strecke gewählt'); return; }
  const name = (document.getElementById('trk-feat-name')?.value||'').trim();
  if (!name) { toast('⚠️ Bitte Bezeichnung eingeben'); return; }
  _loadTrkFeatures();
  if (!_trkFeatures[_featTrackId]) _trkFeatures[_featTrackId] = [];
  const icon = FEAT_ICONS[_featType] || '📍';
  _trkFeatures[_featTrackId].push({ type:_featType, name, diff:_featDiff, date:Date.now() });
  _saveTrkFeatures();
  _saveTrkEdit(_featTrackId, 'feature_add', `${icon} Hinzugefügt: ${name}`, '', name);
  const inp = document.getElementById('trk-feat-name');
  if (inp) inp.value = '';
  cancelFeatAdd();
  loadTrkFeatures(_featTrackId);
  _buildTrkVersionHistory(_featTrackId);
  toast('✅ Schlüsselstelle gespeichert!');
}
function _deleteFeat(trackId, idx) {
  _loadTrkFeatures();
  if (_trkFeatures[trackId]) {
    const deleted = _trkFeatures[trackId][idx];
    const icon = FEAT_ICONS[deleted?.type] || '📍';
    _trkFeatures[trackId].splice(idx, 1);
    _saveTrkFeatures();
    if (deleted) _saveTrkEdit(trackId, 'feature_del', `${icon} Entfernt: ${deleted.name||'?'}`, deleted.name||'', '');
    // Re-render main map markers
    const track = trackStore.tracks.find(t => t.id === trackId);
    if (track) _renderTrackFeatures(track);
    loadTrkFeatures(trackId);
    _buildTrkVersionHistory(trackId);
  }
}

/**
 * Renders geo-tagged track features as emoji markers on the main map.
 * Removes old markers first, then adds fresh ones for features with lat/lng.
 * @param {Object} track - track object from trackStore.tracks
 */
function _renderTrackFeatures(track) {
  if (!track) return;
  // Remove old markers
  if (track._featMarkers) {
    track._featMarkers.forEach(m => { try { map.removeLayer(m); } catch(e) {} });
  }
  track._featMarkers = [];
  if (!track.visible) return;
  if (track._featMarkersVisible === false) return;
  _loadTrkFeatures();
  const feats = (_trkFeatures[track.id] || []).filter(f => f.lat != null && f.lng != null);
  feats.forEach(f => {
    const icon = FEAT_ICONS[f.type] || '📍';
    const stars = [1,2,3,4,5].map(i => `<span style="opacity:${i<=(f.diff||1)?1:.2}">⭐</span>`).join('');
    const marker = L.marker([f.lat, f.lng], {
      icon: L.divIcon({
        html: `<span style="font-size:18px;line-height:1;filter:drop-shadow(0 1px 2px rgba(0,0,0,.7))">${icon}</span>`,
        className: '',
        iconSize: [22, 22],
        iconAnchor: [11, 11]
      })
    }).bindPopup(`<b>${icon} ${escHtml(FEAT_NAMES[f.type]||f.type)}</b><br>${escHtml(f.name||'')}<br>${stars}`);
    marker.addTo(map);
    track._featMarkers.push(marker);
  });
}

/** Toggle feature marker visibility for a track */
function _toggleFeatMarkers(trackId) {
  const track = trackStore.tracks.find(t => t.id === trackId);
  if (!track) return;
  track._featMarkersVisible = (track._featMarkersVisible !== false) ? false : true;
  if (track._featMarkersVisible === false) {
    (track._featMarkers || []).forEach(m => { try { map.removeLayer(m); } catch(e) {} });
    toast('👁 Schlüsselstellen ausgeblendet');
  } else {
    _renderTrackFeatures(track);
    toast('👁 Schlüsselstellen eingeblendet');
  }
}

function _buildTrkConditionList() {
  const el = document.getElementById('trk-condition-list');
  if (!el) return;
  _loadTrkFeatures();
  const tracks = trackStore.tracks;
  if (!tracks.length) { el.innerHTML = '<div style="color:var(--td);font-size:12px">Keine Strecken geladen.</div>'; return; }
  const CONDITIONS = [
    { v:'unknown', l:'❓ Unbekannt', c:'var(--td)' },
    { v:'dry',     l:'☀️ Trocken',  c:'#22c55e'  },
    { v:'damp',    l:'💧 Feucht',   c:'#f59e0b'  },
    { v:'muddy',   l:'🌧 Matschig', c:'#ef4444'  },
    { v:'icy',     l:'❄️ Eisig',    c:'#38bdf8'  },
  ];
  el.innerHTML = tracks.map(t => {
    const cur = (_trkFeatures[t.id+'_cond'] || {}).condition || 'unknown';
    const condHtml = CONDITIONS.map(c =>
      `<button onclick="_setCondition('${t.id}','${c.v}',this)" data-cv="${c.v}"
        style="padding:5px 7px;border-radius:7px;border:1.5px solid var(--bd2);
        background:${cur===c.v?c.c:'var(--s3)'};color:${cur===c.v?'#fff':'var(--td)'};
        font-size:10px;font-weight:700;cursor:pointer;white-space:nowrap">${c.l}</button>`
    ).join('');
    return `<div style="padding:10px;background:var(--s2);border-radius:10px;border:1px solid var(--bd2);margin-bottom:8px">
      <div style="font-size:12px;font-weight:700;color:var(--tx);margin-bottom:8px">${escHtml(t.name)}</div>
      <div style="display:flex;gap:5px;flex-wrap:wrap">${condHtml}</div>
    </div>`;
  }).join('');
}
function _setCondition(trackId, condition, btn) {
  _loadTrkFeatures();
  _trkFeatures[trackId+'_cond'] = { condition, updated: Date.now() };
  _saveTrkFeatures();
  const wrap = btn?.closest('div[style]');
  if (wrap) {
    const CONDITIONS = { unknown:'var(--td)',dry:'#22c55e',damp:'#f59e0b',muddy:'#ef4444',icy:'#38bdf8' };
    wrap.querySelectorAll('[data-cv]').forEach(b => {
      const isThis = b.dataset.cv === condition;
      b.style.background = isThis ? (CONDITIONS[condition]||'var(--td)') : 'var(--s3)';
      b.style.color = isThis ? '#fff' : 'var(--td)';
    });
  }
  toast('✅ Zustand gespeichert');
}

// ── STRECKEN EINSTELLUNGEN — Editor & Version History ─────────────────────────
const _TRK_EDITS_KEY = 'gmtw_trk_edits_v1';
let _trkEdits     = {};
let _trkDescTimer = null;

function _loadTrkEdits() {
  try { _trkEdits = JSON.parse(localStorage.getItem(_TRK_EDITS_KEY)||'{}'); } catch(e) { _trkEdits = {}; }
}
function _saveTrkEditsStore() {
  localStorage.setItem(_TRK_EDITS_KEY, JSON.stringify(_trkEdits));
}
// Log an edit entry (unshifts to front, max 50 per track)
function _saveTrkEdit(trackId, field, desc, oldVal, newVal) {
  _loadTrkEdits();
  if (!_trkEdits[trackId]) _trkEdits[trackId] = [];
  _trkEdits[trackId].unshift({
    ts: Date.now(), field, desc,
    oldVal: String(oldVal||'').slice(0,80),
    newVal: String(newVal||'').slice(0,80)
  });
  if (_trkEdits[trackId].length > 50) _trkEdits[trackId].length = 50;
  _saveTrkEditsStore();
}

// Main entry point — called when user selects a track in the dropdown
function openTrkEditor(trackId) {
  _featTrackId = trackId;
  const sel   = document.getElementById('trk-feat-select');
  const empty = document.getElementById('trk-editor-empty');
  const body  = document.getElementById('trk-editor-body');
  if (sel) sel.value = trackId || '';
  if (!trackId) {
    if (empty) empty.style.display = 'block';
    if (body)  body.style.display  = 'none';
    return;
  }
  if (empty) empty.style.display = 'none';
  if (body)  body.style.display  = 'block';
  const track = trackStore.tracks.find(t => t.id === trackId);
  if (!track) return;

  // Header
  _buildTrkEditorHeader(track);

  // Description
  _loadTrkFeatures();
  const meta   = _trkFeatures[trackId + '_meta'] || {};
  const descEl = document.getElementById('trk-desc-inp');
  const lenEl  = document.getElementById('trk-desc-len');
  if (descEl) { descEl.value = meta.desc || ''; }
  if (lenEl)  { lenEl.textContent = `${(meta.desc||'').length}/400`; }

  // Features list
  loadTrkFeatures(trackId);

  // Condition
  _buildTrkEditorCondition(trackId);

  // Version history
  _buildTrkVersionHistory(trackId);
}

function _buildTrkEditorHeader(track) {
  const el = document.getElementById('trk-editor-header');
  if (!el) return;
  const CAT_COL   = { beginner:'#27AE60', mittel:'#D4A017', expert:'#ef4444' };
  const CAT_LABEL = { beginner:'Anfänger', mittel:'Mittel', expert:'Expert' };
  const col   = CAT_COL[track.cat] || track.color || '#888';
  const label = CAT_LABEL[track.cat] || track.cat || '';
  const dist  = track.stats?.dist || null;
  el.innerHTML = `
    <div style="display:flex;align-items:center;gap:10px">
      <span style="width:14px;height:14px;border-radius:5px;background:${col};flex-shrink:0;display:inline-block;
        box-shadow:0 0 0 3px ${col}33"></span>
      <div style="flex:1;min-width:0">
        <div style="font-size:14px;font-weight:900;color:var(--tx);font-family:var(--fh);
          white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${escHtml(track.name)}</div>
        <div style="display:flex;gap:6px;align-items:center;margin-top:3px;flex-wrap:wrap">
          <span style="font-size:10px;padding:2px 7px;border-radius:5px;background:${col}22;color:${col};font-weight:700">${label}</span>
          ${dist ? `<span style="font-size:10px;color:var(--td)">📏 ${dist} km</span>` : ''}
        </div>
      </div>
    </div>`;
}

// Debounced description save
function _onTrkDescChange(val) {
  const lenEl = document.getElementById('trk-desc-len');
  if (lenEl) lenEl.textContent = `${val.length}/400`;
  clearTimeout(_trkDescTimer);
  _trkDescTimer = setTimeout(() => {
    if (!_featTrackId) return;
    _loadTrkFeatures();
    const key = _featTrackId + '_meta';
    const oldDesc = (_trkFeatures[key] || {}).desc || '';
    if (!_trkFeatures[key]) _trkFeatures[key] = {};
    _trkFeatures[key].desc        = val;
    _trkFeatures[key].descUpdated = Date.now();
    _saveTrkFeatures();
    if (val.trim() !== oldDesc.trim()) {
      _saveTrkEdit(_featTrackId, 'desc', '📝 Beschreibung bearbeitet',
        oldDesc.slice(0,60) || '(leer)', val.slice(0,60) || '(leer)');
      _buildTrkVersionHistory(_featTrackId);
      toast('✅ Beschreibung gespeichert');
    }
  }, 900);
}

// Condition buttons for the editor (single track)
function _buildTrkEditorCondition(trackId) {
  const el = document.getElementById('trk-editor-condition');
  if (!el) return;
  _loadTrkFeatures();
  const cur = (_trkFeatures[trackId + '_cond'] || {}).condition || 'unknown';
  const CONDITIONS = [
    { v:'unknown', l:'❓ Unbekannt', c:'var(--td)' },
    { v:'dry',     l:'☀️ Trocken',  c:'#22c55e'   },
    { v:'damp',    l:'💧 Feucht',   c:'#f59e0b'   },
    { v:'muddy',   l:'🌧 Matschig', c:'#ef4444'   },
    { v:'icy',     l:'❄️ Eisig',    c:'#38bdf8'   },
  ];
  el.innerHTML = CONDITIONS.map(c =>
    `<button onclick="_setConditionEditor('${escHtml(trackId)}','${c.v}',this)" data-cv="${c.v}"
      style="padding:7px 10px;border-radius:9px;border:1.5px solid ${cur===c.v ? c.c : 'var(--bd2)'};
      background:${cur===c.v ? c.c : 'var(--s2)'};color:${cur===c.v ? '#fff' : 'var(--td)'};
      font-size:11px;font-weight:700;cursor:pointer;transition:all .15s;white-space:nowrap">${c.l}</button>`
  ).join('');
}

function _setConditionEditor(trackId, condition, btn) {
  _loadTrkFeatures();
  const CKEY = trackId + '_cond';
  const old  = (_trkFeatures[CKEY] || {}).condition || 'unknown';
  _trkFeatures[CKEY] = { condition, updated: Date.now() };
  _saveTrkFeatures();
  const COL   = { unknown:'var(--td)', dry:'#22c55e', damp:'#f59e0b', muddy:'#ef4444', icy:'#38bdf8' };
  const LABEL = { unknown:'Unbekannt', dry:'Trocken',  damp:'Feucht',  muddy:'Matschig', icy:'Eisig' };
  const wrap = document.getElementById('trk-editor-condition');
  if (wrap) {
    wrap.querySelectorAll('[data-cv]').forEach(b => {
      const on = b.dataset.cv === condition;
      b.style.background  = on ? (COL[condition]||'var(--td)') : 'var(--s2)';
      b.style.color       = on ? '#fff' : 'var(--td)';
      b.style.borderColor = on ? (COL[condition]||'var(--bd2)') : 'var(--bd2)';
    });
  }
  if (old !== condition) {
    _saveTrkEdit(trackId, 'condition',
      `🎽 Zustand: ${LABEL[old]||old} → ${LABEL[condition]||condition}`, old, condition);
    _buildTrkVersionHistory(trackId);
  }
  toast('✅ Streckenzustand gespeichert');
}

// Render version history for selected track
function _buildTrkVersionHistory(trackId) {
  const el = document.getElementById('trk-version-history');
  if (!el) return;
  _loadTrkEdits();
  const edits = (_trkEdits[trackId] || []);
  if (!edits.length) {
    el.innerHTML = `<div style="padding:14px 12px;background:var(--s2);border-radius:10px;border:1px solid var(--bd2);
      text-align:center;font-size:12px;color:var(--td)">
      <div style="font-size:20px;margin-bottom:5px">📋</div>
      Noch keine Änderungen protokolliert.<br>
      <span style="font-size:10px;opacity:.6">Jede Bearbeitung wird hier mit Zeitstempel geloggt.</span>
    </div>`;
    return;
  }
  el.innerHTML = edits.map((e, i) => {
    const d       = new Date(e.ts);
    const dateStr = d.toLocaleDateString('de-DE', { day:'2-digit', month:'2-digit', year:'2-digit' });
    const timeStr = d.toLocaleTimeString('de-DE', { hour:'2-digit', minute:'2-digit' });
    const isNew   = i === 0;
    const preview = (e.field === 'desc' && e.newVal)
      ? `<div style="font-size:10px;color:var(--td);margin-top:3px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;
          font-style:italic">"${escHtml(e.newVal.slice(0,55))}${e.newVal.length>55?'…':''}"</div>` : '';
    return `<div style="display:flex;gap:10px;align-items:flex-start;padding:9px 11px;margin-bottom:5px;border-radius:10px;
        ${isNew ? 'background:rgba(200,255,0,.06);border:1px solid rgba(200,255,0,.25)' : 'background:var(--s2);border:1px solid var(--bd2)'}">
      <div style="flex:1;min-width:0">
        <div style="font-size:12px;font-weight:700;color:var(--tx)">${escHtml(e.desc)}</div>
        ${preview}
      </div>
      <div style="text-align:right;flex-shrink:0">
        <div style="font-size:10px;font-weight:600;color:var(--td)">${timeStr}</div>
        <div style="font-size:9px;color:var(--td);opacity:.65">${dateStr}</div>
      </div>
    </div>`;
  }).join('');
}

function _clearTrkHistory() {
  if (!_featTrackId) return;
  _loadTrkEdits();
  _trkEdits[_featTrackId] = [];
  _saveTrkEditsStore();
  _buildTrkVersionHistory(_featTrackId);
  toast('🗑 Verlauf geleert');
}

// Strecken-Tab: Alle offiziellen + eigene Tracks anzeigen
function _initTracksTab() {
  const el = document.getElementById('sp-auto-tracks-list');
  if (!el) return;

  const btnStyle = 'font-size:10px;padding:4px 8px;border-radius:6px;cursor:pointer;border:1px solid var(--bd2);font-family:var(--fh);font-weight:700;line-height:1.4';

  // Offizielle Strecken
  const autoHtml = AUTO_TRACKS.map(t => {
    const tr    = trackStore.tracks.find(tr => tr.sourceUrl === t.url || tr.name === t.name);
    const loaded = !!tr;
    const catDot = { beginner:'#27AE60', mittel:'#D4A017', expert:'#ef4444' }[t.cat] || '#888';
    const btns = loaded
      ? `<button onclick="closeSettings();zoomTrack('${tr.id}')" title="Auf Karte" style="${btnStyle};background:var(--s3);color:var(--td)">📍</button>`
        + `<button onclick="closeSettings();setTimeout(()=>openTrackQR('${tr.id}'),280)" title="QR/Teilen" style="${btnStyle};background:var(--s3);color:var(--ac)">📤</button>`
        + `<button onclick="removeTrackFromSettings('${tr.id}')" title="Entfernen" style="${btnStyle};background:rgba(239,68,68,.12);color:#ef4444">🗑</button>`
      : `<button onclick="loadAutoTrack('${esc(t.url)}','${esc(t.name)}','${esc(t.cat)}')" style="${btnStyle};background:var(--ac);color:#000;border:none">⬇ Laden</button>`;
    return `<div style="display:flex;align-items:center;gap:6px;padding:7px 0;border-bottom:1px solid var(--bd2)">
      <span style="width:10px;height:10px;border-radius:50%;background:${catDot};flex-shrink:0;display:inline-block"></span>
      <div style="flex:1;min-width:0">
        <div style="font-size:12px;color:var(--tx);white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${escHtml(t.name)}</div>
        <div style="font-size:10px;color:${loaded?'var(--ac)':'var(--td)'};font-family:var(--fh);font-weight:700">${loaded?`✅ ${tr.stats?.dist||'?'} km`:'⬜ nicht geladen'}</div>
      </div>
      <div style="display:flex;gap:4px;flex-shrink:0">${btns}</div>
    </div>`;
  }).join('');

  // Eigene Tracks (nicht aus AUTO_TRACKS)
  const customTracks = trackStore.tracks.filter(t =>
    !AUTO_TRACKS.some(at => at.url === t.sourceUrl || at.name === t.name)
  );
  const customHtml = customTracks.length
    ? `<div style="margin-top:16px;margin-bottom:6px;font-size:10px;font-weight:800;color:var(--td);letter-spacing:.5px;text-transform:uppercase;display:flex;align-items:center;justify-content:space-between">
        <span>Eigene Strecken (${customTracks.length})</span>
      </div>`
      + customTracks.map(t => `<div style="display:flex;align-items:center;gap:6px;padding:6px 0;border-bottom:1px solid var(--bd2)">
          <span style="width:10px;height:10px;border-radius:50%;background:${t.color};flex-shrink:0;display:inline-block"></span>
          <div style="flex:1;min-width:0">
            <div style="font-size:12px;color:var(--tx);white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${escHtml(t.name)}</div>
            <div style="font-size:10px;color:var(--td);font-family:var(--fh);font-weight:700">${escHtml(t.cat)} · ${t.stats?.dist||'?'} km</div>
          </div>
          <div style="display:flex;gap:4px;flex-shrink:0">
            <button onclick="closeSettings();zoomTrack('${t.id}')" title="Auf Karte" style="${btnStyle};background:var(--s3);color:var(--td)">📍</button>
            <button onclick="closeSettings();setTimeout(()=>openTrackQR('${t.id}'),280)" title="QR/Teilen" style="${btnStyle};background:var(--s3);color:var(--ac)">📤</button>
            <button onclick="removeTrackFromSettings('${t.id}')" title="Entfernen" style="${btnStyle};background:rgba(239,68,68,.12);color:#ef4444">🗑</button>
          </div>
        </div>`).join('')
    : '';

  // Fehlende offizielle Strecken laden-Schaltfläche
  const missing = AUTO_TRACKS.filter(t => !trackStore.tracks.some(tr => tr.sourceUrl === t.url || tr.name === t.name));
  const loadAllBtn = missing.length > 0
    ? `<button onclick="loadAllMissingTracks()" style="margin-top:12px;width:100%;padding:10px;background:var(--ac);color:#000;border:none;border-radius:10px;font-family:var(--fh);font-size:13px;font-weight:800;cursor:pointer;letter-spacing:.5px">
        ⬇ Alle ${missing.length} fehlenden Strecken laden
      </button>`
    : `<div style="padding:8px 0;font-size:11px;color:var(--ac);font-family:var(--fh);font-weight:700">✅ Alle offiziellen Strecken geladen</div>`;

  el.innerHTML = autoHtml + customHtml + loadAllBtn;
}

// Track aus Settings-Tab entfernen (mit Bestätigung)
function removeTrackFromSettings(id) {
  const t = trackStore.tracks.find(t => t.id === id);
  if (!t) return;
  if (!confirm(`"${t.name}" wirklich aus der App entfernen?`)) return;
  removeTrack(id);
  setTimeout(_initTracksTab, 200);
}

// Einzelne Auto-Strecke aus Repository laden
async function loadAutoTrack(url, name, cat) {
  toast(`⏳ Lade ${escHtml(name)}…`);
  try {
    const resp = await fetch(url);
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    const txt = await resp.text();
    const gpxStr = sanitizeGpx(txt);
    if (!gpxStr.startsWith('<')) throw new Error('Kein gültiges GPX');
    loadGpxXml(gpxStr, name, cat, null, url, false); // nicht-silent: Zoom + Popup
    // Tab nach kurzer Verzögerung refreshen (nach loaded-Event)
    setTimeout(_initTracksTab, 1800);
    // GPX-URL aggressiv cachen
    setTimeout(swPrefetchGpxTracks, 500);
  } catch(e) {
    toast(`❌ Laden fehlgeschlagen: ${escHtml(e.message)}`);
  }
}

// Alle fehlenden offiziellen Strecken laden
async function loadAllMissingTracks() {
  const missing = AUTO_TRACKS.filter(t => !trackStore.tracks.some(tr => tr.sourceUrl === t.url || tr.name === t.name));
  if (!missing.length) { toast('✅ Alle Strecken bereits geladen'); return; }
  toast(`⏳ Lade ${missing.length} Strecken…`);
  let ok = 0;
  for (const def of missing) {
    try {
      const resp = await fetch(def.url);
      if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
      const txt = await resp.text();
      const gpxStr = sanitizeGpx(txt);
      if (!gpxStr.startsWith('<')) throw new Error('Kein GPX');
      loadGpxXml(gpxStr, def.name, def.cat, null, def.url, true); // silent
      ok++;
    } catch(e) { console.warn(`Laden fehlgeschlagen: ${def.name}`, e.message); }
  }
  setTimeout(() => {
    toast(`✅ ${ok}/${missing.length} Strecken geladen`);
    _initTracksTab();
  }, 1500);
}

// ══════════════════════════════════════════════════════════════
// ── LOCALFORAGE INITIALISIERUNG ────────────────────────────────
// ══════════════════════════════════════════════════════════════

localforage.config({
  driver:    [localforage.INDEXEDDB, localforage.WEBSQL, localforage.LOCALSTORAGE],
  name:      'gmtw-map',
  version:   1.0,
  storeName: 'gmtw_store',
  description:'GMTW Trail Map Offline-Speicher'
});

// Service Worker registrieren
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./service-worker.js')
      .then(reg => {
        console.log('[SW] Registriert:', reg.scope);
        // Dauerhaften Speicher beim ersten Start anfragen
        if (navigator.storage && navigator.storage.persist) {
          navigator.storage.persist().then(granted => {
            if (granted) console.log('[Storage] Persistenter Speicher gewährt');
          });
        }
        // GPX-Tracks aggressiv vorab cachen (nach kurzer Verzögerung)
        setTimeout(() => swPrefetchGpxTracks(), 3000);
      })
      .catch(err => console.warn('[SW] Registrierung fehlgeschlagen:', err));
  });
}

// GPX-Track-URLs an Service Worker zum Vorab-Cachen senden
function swPrefetchGpxTracks() {
  if (!navigator.serviceWorker || !navigator.serviceWorker.controller) return;
  // Alle bekannten GPX-URLs sammeln (Auto-Tracks + geladene Tracks mit Source-URL)
  const urls = new Set();
  AUTO_TRACKS.forEach(t => { if (t.url) urls.add(t.url); });
  trackStore.tracks.forEach(t => {
    if (t.sourceUrl && !t.sourceUrl.startsWith('blob:') && t.sourceUrl.startsWith('http')) {
      urls.add(t.sourceUrl);
    }
  });
  if (!urls.size) return;
  const channel = new MessageChannel();
  channel.port1.onmessage = (e) => {
    if (e.data?.success) console.log('[SW] GPX Prefetch abgeschlossen für', urls.size, 'URLs');
  };
  navigator.serviceWorker.controller.postMessage(
    { type: 'PREFETCH_GPX', urls: [...urls] },
    [channel.port2]
  );
}

// Hinweis: Initialisierung erfolgt im window-load-Event (siehe oben)

</script>

<!-- ══ NAVIGATION HUD ══════════════════════════════════════════ -->
<div id="nav-hud" role="status" aria-live="polite">
  <!-- Arrow: Big colored indicator -->
  <div class="nh-arrow-wrap" id="nh-arrow-wrap">
    <span class="nh-arrow" id="nh-arrow" aria-hidden="true">↑</span>
  </div>
  <!-- Info block -->
  <div class="nh-txt">
    <div class="nh-mode"><span class="nh-dot"></span><span id="nh-mode-txt">Navigiere zum Start</span></div>
    <div class="nh-title" id="nh-title">–</div>
    <div class="nh-dist" id="nh-dist">—</div>
    <div class="nh-sub" id="nh-sub">GPS wird aktiviert…</div>
    <div class="nh-offroute-warn" id="nh-offroute-warn">⚠️ Falsche Richtung!</div>
    <a class="nh-gmaps" id="nh-gmaps" href="#" target="_blank" rel="noopener noreferrer">
      <svg width="10" height="10" viewBox="0 0 11 11" fill="none"><path d="M5.5 1C3.29 1 1.5 2.79 1.5 5c0 3.07 4 7 4 7s4-3.93 4-7c0-2.21-1.79-4-4-4zm0 5.4a1.4 1.4 0 110-2.8 1.4 1.4 0 010 2.8z" fill="currentColor"/></svg>
      Google Maps
    </a>
  </div>
  <button class="nh-close" onclick="stopNavigation()" aria-label="Navigation beenden">
    <svg width="12" height="12" viewBox="0 0 12 12" fill="none"><path d="M1 1L11 11M11 1L1 11" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
  </button>
</div>

<!-- ══ RACE OVERLAY ════════════════════════════════════════════ -->
<!-- ══ RUN DETAIL MODAL ════════════════════════════════════════ -->
<div id="run-detail-modal" role="dialog" aria-modal="true" aria-label="Lauf-Details">
  <div class="rdm-header">
    <button onclick="closeRunDetail()"
      style="background:var(--s3);border:1px solid var(--bd2);border-radius:10px;color:var(--tx);width:34px;height:34px;display:flex;align-items:center;justify-content:center;cursor:pointer;font-size:18px;flex-shrink:0">←</button>
    <span class="rdm-header-title">Lauf-Details</span>
    <button id="rdm-gpx-btn" onclick="exportCurrentRunDetailGpx()"
      style="background:var(--s3);border:1px solid var(--bd2);border-radius:8px;color:var(--td);padding:6px 10px;font-family:var(--fh);font-size:10px;font-weight:700;letter-spacing:.5px;cursor:pointer">🗺 GPX</button>
  </div>
  <div class="rdm-body" id="rdm-body">
    <!-- dynamisch befüllt durch openRunDetail() -->
  </div>
</div>

<div id="race-overlay" role="dialog" aria-modal="true" aria-label="Rennen">
  <button class="race-overlay-x" id="race-x-btn" onclick="confirmAbortRace()" aria-label="Rennen abbrechen">×</button>

  <!-- Seite 1: Annäherung (> 5 m) — einfache Distanzanzeige -->
  <div class="race-approaching" id="rp-approaching" style="display:none">
    <div class="ra-icon">🚴</div>
    <div class="ra-title">Zum Startpunkt fahren</div>
    <div class="ra-track" id="ra-track-nm">—</div>
    <div class="ra-num" id="ra-dist-val">—</div>
    <div class="ra-unit">Meter bis Start</div>
    <div class="ra-acc" id="ra-gps-acc"></div>
    <div class="ra-hint">Nähere dich der Startlinie — bei ≤5 m erscheint die Start-Bestätigung</div>
    <div class="ra-sensors-row">
      <span class="ra-sensor-badge" id="ra-sensor-gps">📍 GPS –</span>
      <span class="ra-sensor-badge" id="ra-sensor-motion">📐 Sensor –</span>
      <span class="ra-sensor-badge" id="ra-sensor-bt">🔵 BT –</span>
    </div>
    <button class="ra-bt-btn" onclick="_connectSmartwatch()">🔵 Smartwatch / BLE-GPS verbinden (optional)</button>
    <button onclick="confirmAbortRace()"
      style="margin-top:14px;padding:10px 28px;background:var(--s3);color:var(--td);
             border:1px solid var(--bd2);border-radius:var(--r);font-family:var(--fh);
             font-size:13px;font-weight:700;letter-spacing:.5px;cursor:pointer">
      ✕ Rennen abbrechen
    </button>
  </div>

  <!-- Seite 2: Canvas-Annäherung (≤ 5 m) — Bitte vorwerts laufen wächst an -->
  <div id="rp-approach">
    <!-- Canvas füllt die gesamte Seite — wird via JS beschriftet -->
    <canvas id="approach-canvas"></canvas>
    <!-- Start-Bestätigung erscheint bei 2 m als Overlay über dem Canvas -->
    <div id="approach-confirm">
      <div class="approach-confirm-q">Strecke starten &amp;<br>Zeit messen?</div>
      <div class="approach-confirm-btns">
        <button class="approach-btn-yes" onclick="_confirmRaceStart(true)">
          ✓ Ja, Start!
        </button>
        <button class="approach-btn-no" onclick="_confirmRaceStart(false)">
          ↩ Nochmal anfahren
        </button>
      </div>
    </div>
  </div>

  <!-- Seite 3: GO! -->
  <div class="race-go-page" id="rp-go" style="display:none">
    <div class="rg-go">GO!</div>
    <div class="rg-sub">Zeitmessung läuft</div>
  </div>

  <!-- Seite 4: Rennen läuft -->
  <div class="race-running" id="rp-running" style="display:none">
    <div class="rr-name" id="rr-track-nm">—</div>
    <div class="rr-timer" id="rr-timer">00:00.0</div>
    <div class="rr-pause-lbl" id="rr-pause-lbl"></div>
    <div class="rr-fall-row" id="rr-fall-row"></div>
    <div class="rr-splits-grid" id="rr-splits-grid"><!-- dynamisch --></div>
    <div class="rr-speed-lbl" id="rr-speed-lbl"></div>
    <button class="rr-abort-btn" onclick="confirmAbortRace()">■ Abbrechen</button>
    <div class="rr-confirm-box" id="rr-confirm">
      <div class="rr-confirm-q">Rennen wirklich abbrechen?</div>
      <div class="rr-confirm-btns">
        <button onclick="abortRace()" style="background:var(--exp);color:#fff">Abbrechen</button>
        <button onclick="hideAbortConfirm()" style="background:var(--s3);color:var(--td)">Weiter!</button>
      </div>
    </div>
  </div>

  <!-- Seite 5: Ergebnisse -->
  <div class="race-results" id="rp-results" style="display:none">
    <div class="rres-crown">🏁</div>
    <div class="rres-title">Ziel erreicht!</div>
    <div class="rres-track" id="rres-track-nm">—</div>
    <div class="rres-total-time" id="rres-total">—</div>
    <div class="rres-total-lbl">Netto-Gesamtzeit</div>
    <div class="rres-splits-grid" id="rres-splits-grid"></div>
    <!-- Signatur-Box (tamper-evident) -->
    <div class="rres-sig-box" id="rres-sig-box" style="display:none">
      <div class="rres-sig-lbl">🔐 Signatur (fälschungssicher)</div>
      <div class="rres-sig-val" id="rres-sig-val">–</div>
    </div>
    <!-- QR-Code mit Zeiten + Zeitstempeln -->
    <div class="rres-qr-wrap">
      <canvas id="rres-qr-canvas" width="120" height="120" aria-label="Ergebnis QR-Code"></canvas>
    </div>
    <div style="font-size:10px;color:var(--td);text-align:center;margin-bottom:8px">QR scannen → Ergebnis teilen</div>
    <div class="rres-lb-head">🏆 Bestenliste</div>
    <div id="rres-lb"></div>
    <div class="rres-actions">
      <button class="rres-btn sec" onclick="exportRaceGpx()">🗺 GPX</button>
      <button class="rres-btn sec" onclick="shareRunQr()">🔄 QR</button>
      <button class="rres-btn prim" onclick="closeRaceOverlay()">Fertig</button>
    </div>
  </div>
</div>

<!-- ══ SETTINGS PANEL ══════════════════════════════════════════ -->
<div id="settings-panel" role="dialog" aria-modal="true" aria-label="Einstellungen">
  <!-- Header -->
  <div style="display:flex;align-items:center;padding:14px 16px 10px;gap:12px;flex-shrink:0;border-bottom:1px solid var(--bd2)">
    <button onclick="closeSettings()"
      style="background:var(--s2);border:1.5px solid var(--bd2);border-radius:11px;color:var(--tx);
             width:36px;height:36px;display:flex;align-items:center;justify-content:center;
             cursor:pointer;flex-shrink:0;transition:all .15s"
      aria-label="Schließen"
      onmousedown="this.style.transform='scale(.88)'" onmouseup="this.style.transform=''" ontouchstart="this.style.transform='scale(.88)'" ontouchend="this.style.transform=''">
      <svg width="14" height="14" viewBox="0 0 14 14" fill="none">
        <path d="M9 2L4 7L9 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    </button>
    <div style="display:flex;align-items:center;gap:8px;flex:1">
      <span style="font-family:var(--fh);font-size:17px;font-weight:900;letter-spacing:.8px;text-transform:uppercase;color:var(--tx)">Einstellungen</span>
    </div>
    <div class="logobadge" style="flex-shrink:0">MUNI</div>
  </div>

  <!-- Tabs -->
  <div class="sp-tabs">
    <button class="sp-tab active" data-t="profile" onclick="switchSpTab('profile',this)">👤 Profil</button>
    <button class="sp-tab" data-t="general" onclick="switchSpTab('general',this)">Allgemein</button>
    <button class="sp-tab" data-t="tracks"  onclick="switchSpTab('tracks',this)">Strecken</button>
    <button class="sp-tab" data-t="backup"  onclick="switchSpTab('backup',this)">Backup</button>
    <button class="sp-tab" data-t="markers" onclick="switchSpTab('markers',this)">Marker</button>
    <button class="sp-tab" data-t="qr"      onclick="switchSpTab('qr',this)">QR-Scan</button>
    <button class="sp-tab" data-t="app"     onclick="switchSpTab('app',this)">📲 App</button>
  </div>

  <!-- Tab: Allgemein -->
  <div class="sp-content" id="sp-tab-general">
    <div class="sp-section">
      <div class="sp-label">GPS-Position Emoji</div>
      <div class="sp-hint">Wird auf der Karte als dein Standort-Symbol angezeigt</div>
      <div id="emoji-grid" style="display:flex;flex-wrap:wrap;gap:6px;margin:10px 0">
        <!-- wird per JS befüllt -->
      </div>
      <div style="display:flex;gap:8px;align-items:center;margin-top:8px">
        <input class="sp-input" id="sp-emoji-custom" type="text" maxlength="4" placeholder="🦄" style="width:70px;text-align:center;font-size:20px">
        <span style="font-size:12px;color:var(--td)">Eigenes Emoji eingeben</span>
      </div>
    </div>
    <div class="sp-section">
      <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px">
        <div class="sp-label" style="margin:0">📁 Projekt Übersicht</div>
        <label class="sp-btn sec" style="padding:5px 10px;font-size:12px;cursor:pointer;margin:0" title="Projekt-JSON importieren">
          📥 Importieren
          <input type="file" accept=".json" style="display:none" onchange="importProjectJson(this);this.value=''">
        </label>
      </div>
      <div id="sp-proj-list" style="display:flex;flex-direction:column;gap:6px;margin-bottom:10px"></div>
      <button class="sp-btn prim" onclick="startNewProjMode()" style="width:100%;justify-content:center;gap:6px">
        <span style="font-size:16px">➕</span> Neues Projekt erstellen
      </button>
      <p style="font-size:11px;color:var(--td);margin:8px 0 0;line-height:1.5">
        Aktivierte Projekte zeigen ihre Strecken und Marker auf der Karte.
        Der <strong>Fokus</strong> bestimmt, wohin der Übersicht-Button zoomt und welches Projekt neue Inhalte erhält.
      </p>
    </div>
    <!-- Barrierefreiheit -->
    <div class="sp-section">
      <div class="sp-label">♿ Barrierefreiheit &amp; Vorlesen</div>
      <div class="sp-hint">Liest Karteninhalt, Toasts und Navigation laut vor — Steuerung über die Leiste am unteren Bildschirmrand</div>

      <!-- BIG TTS Toggle Button -->
      <button id="a11y-big-toggle" class="a11y-big-toggle" onclick="onA11yToggle(!_a11y.enabled)" aria-pressed="false">
        <span class="a11y-big-toggle-icon">🔊</span>
        <div class="a11y-big-toggle-text">
          <span class="a11y-big-toggle-label">Vorlesefunktion</span>
          <span id="a11y-toggle-state" class="a11y-big-toggle-state">AUS</span>
        </div>
        <div class="a11y-big-toggle-switch"></div>
      </button>

      <!-- Sprechrate -->
      <div style="margin-top:14px">
        <div style="display:flex;justify-content:space-between;font-size:12px;color:var(--td);margin-bottom:6px;font-weight:600">
          <span>🎚 Sprechgeschwindigkeit</span>
          <span id="a11y-rate-val" style="color:var(--tx);font-weight:800">1.0×</span>
        </div>
        <input type="range" id="a11y-rate" min="0.5" max="2" step="0.1" value="1.0"
          style="width:100%;accent-color:var(--ac)"
          oninput="document.getElementById('a11y-rate-val').textContent=parseFloat(this.value).toFixed(1)+'×'"
          onchange="onA11yRate(this.value)">
        <div style="display:flex;justify-content:space-between;font-size:10px;color:var(--td);margin-top:3px">
          <span>Langsam</span><span>Schnell</span>
        </div>
      </div>

      <!-- Hoher Kontrast -->
      <div style="display:flex;align-items:center;justify-content:space-between;margin-top:14px;padding:12px;background:var(--s2);border-radius:11px;border:1px solid var(--bd2)">
        <div>
          <div style="font-size:13px;font-weight:700;color:var(--tx)">🌓 Hoher Kontrast</div>
          <div style="font-size:11px;color:var(--td);margin-top:2px">Stärkere Kontraste für bessere Lesbarkeit</div>
        </div>
        <label style="cursor:pointer;display:flex;align-items:center;gap:6px" aria-label="Hoher Kontrast">
          <input type="checkbox" id="a11y-hc" onchange="onA11yHc(this.checked)"
            style="width:22px;height:22px;accent-color:var(--ac);cursor:pointer">
        </label>
      </div>

      <!-- Schnellzugriff Vorlesen-Buttons -->
      <div style="display:flex;gap:8px;margin-top:12px">
        <button class="sp-btn sec" onclick="speakMapOverview()" style="flex:1;justify-content:center">
          📢 Karte [V]
        </button>
        <button class="sp-btn sec" onclick="speakNearestPoint()" style="flex:1;justify-content:center">
          📍 Nächster [N]
        </button>
      </div>
      <div style="margin-top:6px;font-size:10px;color:var(--td);line-height:1.7;padding:8px;background:var(--s2);border-radius:8px">
        ⌨️ <b>V</b> = Karte · <b>N</b> = Nächster Punkt · <b>S</b> = Einstellungen · <b>Esc</b> = Schließen
      </div>
    </div>

    <div class="sp-section" style="border-bottom:none">
      <button class="sp-btn prim" onclick="saveSettings()" style="width:100%;justify-content:center">
        ✓ Einstellungen speichern
      </button>
    </div>
  </div>

  <!-- Tab: Backup -->
  <div class="sp-content" id="sp-tab-backup">
    <!-- Export -->
    <div class="sp-section">
      <div class="sp-label">📦 Vollständiges Backup exportieren</div>
      <div class="sp-hint">Sichert alle Daten vollständig als JSON-Datei</div>
      <div style="margin-top:8px;padding:8px 10px;background:var(--s3);border-radius:8px;font-size:11px;color:var(--td);line-height:1.8">
        ✅ GPX-Strecken &amp; Rennzeiten &nbsp;·&nbsp; ✅ Eigene Marker<br>
        ✅ Karten-Marker-Anpassungen &nbsp;·&nbsp; ✅ Marker-Größe<br>
        ✅ GPS-Emoji &nbsp;·&nbsp; ✅ Home-Position &nbsp;·&nbsp; ✅ Theme<br>
        ✅ Fahrerprofil (Name, Muni, Radgröße, …) &nbsp;·&nbsp; ✅ Barrierefreiheits-Einstellungen
      </div>
      <button class="sp-btn prim" onclick="exportFullBackup()" style="width:100%;margin-top:10px;justify-content:center">
        ⬇ GMTW_Backup.json erstellen
      </button>
    </div>
    <!-- Import -->
    <div class="sp-section">
      <div class="sp-label">⬆ Backup importieren</div>
      <div class="sp-hint">Wähle eine <code style="background:var(--s3);padding:1px 4px;border-radius:3px;font-family:monospace;font-size:11px">GMTW_Backup.json</code> — alle Daten werden ersetzt und die App neu geladen</div>
      <label style="display:flex;align-items:center;gap:10px;margin-top:10px;padding:14px 12px;background:var(--s2);border:2px dashed var(--bd2);border-radius:12px;cursor:pointer;font-family:var(--fh);font-size:13px;font-weight:700;letter-spacing:.4px;color:var(--ac);justify-content:center">
        📂 Backup-Datei auswählen
        <input type="file" id="backup-file-input" accept=".json,application/json" style="display:none" onchange="importFullBackup(this)">
      </label>
    </div>
    <!-- Nur Marker -->
    <div class="sp-section">
      <div class="sp-label">📍 Nur eigene Marker ex-/importieren</div>
      <div class="sp-hint">Teile eigene Marker mit anderen GMTW-Nutzern</div>
      <div style="display:flex;gap:8px;margin-top:8px">
        <button class="sp-btn sec" style="flex:1;justify-content:center" onclick="exportMarkersJson()">⬇ Exportieren</button>
        <label class="sp-btn sec" style="flex:1;justify-content:center;cursor:pointer;margin:0">
          ⬆ Importieren
          <input type="file" accept=".json,application/json" style="display:none" onchange="importMarkersJson(this)">
        </label>
      </div>
    </div>
    <!-- Alle Zeiten exportieren -->
    <div class="sp-section">
      <div class="sp-label">📊 Alle Zeiten exportieren</div>
      <div class="sp-hint">Alle gefahrenen Rennen auf allen Strecken — inkl. Fahrer, Muni, Splits &amp; Signatur</div>
      <div style="display:flex;gap:8px;margin-top:8px">
        <button onclick="exportAllRunsJson()" class="sp-btn sec" style="flex:1;justify-content:center">⬇ JSON</button>
        <button onclick="exportAllRunsCsv()"  class="sp-btn sec" style="flex:1;justify-content:center">⬇ CSV</button>
      </div>
    </div>
    <!-- Projekt Export / Import -->
    <div class="sp-section">
      <div class="sp-label">📁 Projekt Export / Import</div>
      <div class="sp-hint">Exportiert nur das aktive Projekt (Strecken, Marker, Bewertungen)</div>
      <button class="sp-btn sec" onclick="exportProjectJson()" style="width:100%;justify-content:center;margin-top:8px">
        📤 Aktives Projekt exportieren
      </button>
      <label class="sp-btn sec" style="width:100%;justify-content:center;margin-top:8px;cursor:pointer">
        📥 Projekt importieren
        <input type="file" accept=".json,application/json" style="display:none" onchange="importProjectJson(this)">
      </label>
    </div>
    <!-- Speicher -->
    <div class="sp-section">
      <div class="sp-label">💾 Speichernutzung</div>
      <div id="sp-storage-info" style="font-size:12px;color:var(--td);margin-top:6px;line-height:1.6">
        Wird berechnet…
      </div>
      <button class="sp-btn sec" onclick="requestPersistentStorage()" style="width:100%;margin-top:8px;justify-content:center">
        🔒 Dauerhaften Speicher anfragen
      </button>
    </div>
  </div>

  <!-- Tab: App Installation -->
  <div class="sp-content" id="sp-tab-app">

    <!-- Status-Karte: Installiert / Nicht installiert -->
    <div id="ai-status-card" class="ai-status-card not-installed">
      <div class="ai-status-icon">📲</div>
      <div>
        <div class="ai-status-label">Prüfe…</div>
        <div class="ai-status-sub">Installationsstatus wird geladen</div>
      </div>
    </div>

    <!-- Geräteinformationen -->
    <div class="sp-section">
      <div class="sp-label">📱 Gerät &amp; Browser</div>
      <div id="ai-device-info" class="ai-device-info">Wird erkannt…</div>

      <!-- Schritt-für-Schritt Anleitung -->
      <div class="sp-label" style="margin-top:10px">📖 Installationsanleitung</div>
      <div id="ai-steps-box" class="ai-steps-box">Wird geladen…</div>

      <!-- Install-Button -->
      <button id="ai-install-btn" class="sp-btn prim" style="width:100%;margin-top:12px;justify-content:center" onclick="openInstallGuide()">
        📲 App installieren
      </button>
    </div>

    <!-- Cache &amp; Offline-Status -->
    <div class="sp-section">
      <div class="sp-label">💾 Offline-Cache</div>
      <div style="font-size:11px;color:var(--td);margin-bottom:8px;line-height:1.6">
        Je mehr Tiles gecacht, desto besser funktioniert die App ohne Internet.
      </div>
      <div class="ai-cache-row"><span>Gesamt gecacht:</span><strong id="ai-cache-total">…</strong></div>
      <div class="ai-cache-row"><span>Karten-Tiles:</span><strong id="ai-cache-tiles">…</strong><span style="opacity:.5">&nbsp;/ 3000 max</span></div>
      <div class="ai-bar-wrap"><div class="ai-bar-fill" id="ai-tile-bar"></div></div>
      <div class="ai-cache-row"><span>App-Shell (JS/CSS):</span><strong id="ai-cache-shell">…</strong></div>
      <div class="ai-cache-row"><span>GPX-Strecken:</span><strong id="ai-cache-gpx">…</strong></div>
      <div class="ai-cache-row"><span>Schriftarten:</span><strong id="ai-cache-fonts">…</strong></div>

      <!-- Tile-Bereich cachen -->
      <div style="background:rgba(200,255,0,.07);border:1px solid rgba(200,255,0,.25);border-radius:10px;padding:11px 12px;margin-top:10px;font-size:11.5px;color:var(--td);line-height:1.7">
        🗺️ <strong style="color:var(--tx)">Karten-Bereich für Offline cachen:</strong><br>
        Zoome auf das Trail-Gebiet und tippe dann den Button unten. Die aktuell sichtbaren Karten-Tiles werden lokal gespeichert.
      </div>
      <button class="sp-btn prim" onclick="cacheCurrentMapArea()" style="width:100%;margin-top:8px;justify-content:center;background:var(--acd)">
        🗺️ Sichtbaren Kartenbereich cachen
      </button>
      <button class="sp-btn sec" onclick="swPrefetchGpxTracks();toast('⏳ GPX-Strecken werden gecacht…')" style="width:100%;margin-top:6px;justify-content:center">
        📥 Alle GPX-Strecken jetzt cachen
      </button>
      <button class="sp-btn sec" onclick="_updateAiCacheInfo();toast('🔄 Cache-Info aktualisiert')" style="width:100%;margin-top:6px;justify-content:center">
        🔄 Cache-Info aktualisieren
      </button>
    </div>

    <!-- Speicher -->
    <div class="sp-section">
      <div class="sp-label">🔒 Dauerhafter Speicher</div>
      <div class="sp-hint">Verhindert dass der Browser die Offline-Daten löscht</div>
      <button class="sp-btn sec" onclick="requestPersistentStorage()" style="width:100%;margin-top:8px;justify-content:center">
        🔒 Dauerhaften Speicher anfragen
      </button>
    </div>

  </div>

  <!-- Tab: Profil -->
  <div class="sp-content on" id="sp-tab-profile">

    <!-- Profil-Übersicht Karte -->
    <div class="sp-section">
      <div style="display:flex;align-items:center;gap:12px;margin-bottom:12px">
        <div class="profile-avatar" id="profile-avatar">🦄</div>
        <div style="flex:1;min-width:0">
          <div class="profile-name-display" id="pf-name-display">Kein Name gesetzt</div>
          <div class="profile-muni-display" id="pf-muni-display">Kein Muni-Name</div>
        </div>
      </div>

      <!-- Avatar-Anpassung -->
      <div class="sp-label" style="margin-bottom:6px">🎨 Avatar</div>
      <div class="pf-av-emoji-row" id="pf-av-emoji-row"></div>
      <div class="sp-hint" style="margin:4px 0 5px">Hintergrundfarbe</div>
      <div class="pf-av-color-row" id="pf-av-color-row"></div>
    </div>

    <!-- Fahrer-Name -->
    <div class="sp-section">
      <div class="sp-label">👤 Dein Name (Fahrer)</div>
      <div class="sp-hint">Erscheint in der Bestenliste bei deinen Zeiten</div>
      <input class="sp-input" id="pf-input-name" type="text" maxlength="32"
        placeholder="z.B. Max Muster" style="margin-top:8px;width:100%;box-sizing:border-box">
    </div>

    <!-- Muni-Daten -->
    <div class="sp-section">
      <div class="sp-label">🦄 Muni-Name</div>
      <div class="sp-hint">Wie heißt dein Einrad? (wird im QR-Code und der Signatur verwendet)</div>
      <input class="sp-input" id="pf-input-muni" type="text" maxlength="40"
        placeholder="z.B. The Beast, Fluffmaster 3000 …" style="margin-top:8px;width:100%;box-sizing:border-box">
    </div>

    <!-- Rad-Details -->
    <div class="sp-section">
      <div class="sp-label">⚙️ Rad-Details</div>

      <div class="sp-hint" style="margin-bottom:6px">Radgröße</div>
      <select class="sp-input" id="pf-input-wheel" style="width:100%;box-sizing:border-box">
        <option value="">– Bitte wählen –</option>
        <option value='19"'>19" (Trial)</option>
        <option value='20"'>20" (Freestyle)</option>
        <option value='24"'>24" (Muni Standard)</option>
        <option value='26"'>26"</option>
        <option value='27.5"'>27.5"</option>
        <option value='29"'>29" (Muni XL)</option>
        <option value='36"'>36" (Road)</option>
      </select>

      <div class="sp-hint" style="margin-top:10px;margin-bottom:6px">Farbe (Rahmen / Muni)</div>
      <input class="sp-input" id="pf-input-color" type="text" maxlength="40"
        placeholder="z.B. schwarz/grün, carbon …" style="width:100%;box-sizing:border-box">

      <div class="sp-hint" style="margin-top:10px;margin-bottom:6px">Bremse</div>
      <input class="sp-input" id="pf-input-brake" type="text" maxlength="40"
        placeholder="z.B. Magura MT5, KH Moment, keine …" style="width:100%;box-sizing:border-box">

      <div class="sp-hint" style="margin-top:10px;margin-bottom:6px">Sattelklemmen-Farbe</div>
      <input class="sp-input" id="pf-input-seatclamp" type="text" maxlength="30"
        placeholder="z.B. rot, blau, silber …" style="width:100%;box-sizing:border-box">

      <div class="sp-hint" style="margin-top:10px;margin-bottom:4px">Besonderheit / Nabe</div>
      <input class="sp-input" id="pf-input-special" type="text" maxlength="60"
        placeholder="z.B. Schlumpf-Nabe, Freewheel, Moment-Kurbeln …" style="width:100%;box-sizing:border-box">
      <div class="profile-quick-btns" style="margin-top:6px">
        <button class="profile-quick-btn" onclick="document.getElementById('pf-input-special').value='Schlumpf-Nabe'">Schlumpf-Nabe</button>
        <button class="profile-quick-btn" onclick="document.getElementById('pf-input-special').value='Freewheel'">Freewheel</button>
        <button class="profile-quick-btn" onclick="document.getElementById('pf-input-special').value='Standard'">Standard</button>
        <button class="profile-quick-btn" onclick="document.getElementById('pf-input-special').value=''">✕ Löschen</button>
      </div>
    </div>

    <!-- App-Sprache -->
    <div class="sp-section">
      <div class="sp-label">🌐 App-Sprache / Language</div>
      <div class="sp-hint">Bestimmt die Sprache der Vorlesefunktion (TTS) und zukünftiger Übersetzungen</div>
      <div class="lang-grid">
        <button class="lang-btn active" data-lang="de" onclick="setAppLang('de')">🇩🇪 Deutsch</button>
        <button class="lang-btn" data-lang="en" onclick="setAppLang('en')">🇬🇧 English</button>
        <button class="lang-btn" data-lang="fr" onclick="setAppLang('fr')">🇫🇷 Français</button>
        <button class="lang-btn" data-lang="es" onclick="setAppLang('es')">🇪🇸 Español</button>
      </div>
    </div>

    <!-- Speichern -->
    <div class="sp-section" style="border-bottom:none">
      <button class="sp-btn prim" onclick="saveProfile()" style="width:100%;justify-content:center">
        ✓ Profil speichern
      </button>
    </div>
  </div>

  <!-- Tab: Marker (LOCS + Eigene) -->
  <div class="sp-content sp-col" id="sp-tab-markers">
    <!-- Toolbar: Erstellen -->
    <div style="padding:10px 16px;display:flex;align-items:center;gap:8px;flex-shrink:0;border-bottom:1px solid var(--bd2);flex-wrap:wrap">
      <span style="font-family:var(--fh);font-size:11px;font-weight:700;letter-spacing:.6px;text-transform:uppercase;color:var(--td);flex:1">Marker verwalten</span>
      <button class="sp-btn sec" style="padding:6px 10px;font-size:11px" onclick="openMdModalManual()" title="Marker manuell erstellen">＋ Neu</button>
      <button class="sp-btn sec" style="padding:6px 10px;font-size:11px" onclick="closeSettings();toggleMarkerMode(true)" title="Marker per Kartenklick setzen">📍 Karte</button>
    </div>
    <!-- Marker-Größe -->
    <div class="mk-slider-row">
      <span style="font-size:12px;color:var(--td);flex-shrink:0">Marker-Größe</span>
      <input type="range" id="mk-scale-slider" min="50" max="200" step="5" value="100"
        oninput="onMkScaleInput(this.value)" onchange="onMkScaleChange(this.value)"
        style="flex:1;accent-color:var(--ac)">
      <span class="mk-slider-val" id="mk-scale-val">100%</span>
    </div>
    <!-- Import/Export eigener Marker -->
    <div style="padding:8px 16px;display:flex;gap:8px;flex-shrink:0;border-bottom:1px solid var(--bd2)">
      <button class="sp-btn sec" style="flex:1;justify-content:center;font-size:11px" onclick="exportMarkersJson()">⬇ Exportieren</button>
      <label class="sp-btn sec" style="flex:1;justify-content:center;font-size:11px;cursor:pointer;margin:0">
        ⬆ Importieren
        <input type="file" accept=".json,application/json" style="display:none" onchange="importMarkersJson(this)">
      </label>
    </div>
    <!-- Liste (LOCS + Eigene) -->
    <div style="overflow-y:auto;flex:1;padding:0 16px 16px" id="cm-list-container">
      <!-- wird per JS befüllt -->
    </div>
  </div>

  <!-- Tab: Strecken-Update + Muni Trail Settings -->
  <div class="sp-content" id="sp-tab-tracks" style="padding:0">

    <!-- Sub-Navigation -->
    <div style="display:flex;border-bottom:2px solid var(--bd2);flex-shrink:0;background:var(--s2)">
      <button class="trk-sub-tab active" data-st="load" onclick="switchTrkSubTab('load',this)" style="flex:1;padding:10px 4px;font-size:11px;font-family:var(--fh);font-weight:700;border:none;background:transparent;color:var(--tx);cursor:pointer;border-bottom:2px solid transparent;margin-bottom:-2px;transition:all .15s">📥 Strecken</button>
      <button class="trk-sub-tab" data-st="notes" onclick="switchTrkSubTab('notes',this)" style="flex:1;padding:10px 4px;font-size:11px;font-family:var(--fh);font-weight:700;border:none;background:transparent;color:var(--td);cursor:pointer;border-bottom:2px solid transparent;margin-bottom:-2px;transition:all .15s">📝 Mein Rating</button>
      <button class="trk-sub-tab" data-st="features" onclick="switchTrkSubTab('features',this)" style="flex:1;padding:10px 4px;font-size:11px;font-family:var(--fh);font-weight:700;border:none;background:transparent;color:var(--td);cursor:pointer;border-bottom:2px solid transparent;margin-bottom:-2px;transition:all .15s">⚙️ Einstellungen</button>
    </div>

    <!-- Pane: Strecken laden -->
    <div id="trk-pane-load" style="overflow-y:auto;flex:1;padding:0 16px">
      <div class="sp-section">
        <div class="sp-label">🗂 Offizielle GMTW 2026 Strecken</div>
        <div class="sp-hint">Quelle: <code style="background:var(--s3);padding:1px 4px;border-radius:3px;font-size:10px;font-family:monospace">munimap.github.io</code></div>
        <div id="sp-auto-tracks-list" style="margin-top:8px;font-size:12px;color:var(--td);display:flex;flex-direction:column;gap:4px">
          <!-- wird per JS befüllt -->
        </div>
      </div>
      <div class="sp-section" style="border-bottom:none">
        <div class="sp-label">🔄 Updates suchen</div>
        <div class="sp-hint">Prüft das Repository auf neue GPX-Dateien</div>
        <button class="sp-btn prim" id="sp-update-btn" onclick="checkForTrackUpdates()" style="width:100%;margin-top:10px;justify-content:center">
          🔄 Nach Updates suchen
        </button>
        <div id="sp-update-result" style="margin-top:10px"></div>
      </div>
    </div>

    <!-- Pane: Mein Rating (persönliches Strecken-Profil) -->
    <div id="trk-pane-notes" style="display:none;overflow-y:auto;flex:1;padding:0 16px">
      <div class="sp-section">
        <div class="sp-label">⭐ Mein persönliches Strecken-Rating</div>
        <div class="sp-hint">Deine eigene Einschätzung — unabhängig vom offiziellen Schwierigkeitsgrad</div>
        <div id="trk-rating-list" style="margin-top:10px">
          <!-- per JS befüllt -->
        </div>
        <div style="margin-top:10px;font-size:11px;color:var(--td);line-height:1.6;padding:8px;background:var(--s2);border-radius:8px">
          💡 Tip: Rate deine Strecken — du siehst auf einen Blick wo du noch Gas geben kannst!
        </div>
      </div>
      <div class="sp-section" style="border-bottom:none">
        <div class="sp-label">📊 Meine Statistik</div>
        <div id="trk-stats-summary" style="margin-top:8px"></div>
      </div>
    </div>

    <!-- Pane: Strecken Einstellungen (vollständig) -->
    <div id="trk-pane-features" style="display:none;overflow-y:auto;flex:1">

      <!-- Strecken-Auswahl (sticky header) -->
      <div style="padding:10px 16px;background:var(--s2);border-bottom:1px solid var(--bd2);position:sticky;top:0;z-index:10">
        <div style="font-size:10px;font-weight:700;color:var(--td);text-transform:uppercase;letter-spacing:.5px;margin-bottom:5px">Strecke auswählen</div>
        <select id="trk-feat-select" class="sp-input" style="width:100%;box-sizing:border-box" onchange="openTrkEditor(this.value)">
          <option value="">– Strecke auswählen –</option>
        </select>
      </div>

      <!-- Empty state -->
      <div id="trk-editor-empty" style="padding:40px 24px;text-align:center;color:var(--td)">
        <div style="font-size:48px;margin-bottom:14px">⚙️</div>
        <div style="font-size:15px;font-weight:800;color:var(--tx);font-family:var(--fh);margin-bottom:8px">Strecken Einstellungen</div>
        <div style="font-size:12px;line-height:1.7;max-width:260px;margin:0 auto">
          Wähle eine Strecke um sie zu bearbeiten, Schlüsselstellen zu markieren und alle Änderungen mit Zeitstempel zu protokollieren.
        </div>
      </div>

      <!-- Editor body (hidden until track selected) -->
      <div id="trk-editor-body" style="display:none">

        <!-- Track info header -->
        <div id="trk-editor-header" style="padding:12px 16px;border-bottom:1px solid var(--bd2);background:var(--s1)"></div>

        <!-- Section: Beschreibung -->
        <div class="sp-section">
          <div class="sp-label">📝 Streckenbeschreibung</div>
          <div class="sp-hint">Persönliche Notiz für dich und andere Fahrer — wird lokal gespeichert</div>
          <textarea id="trk-desc-inp" class="sp-input"
            style="width:100%;box-sizing:border-box;min-height:82px;resize:vertical;margin-top:8px;font-family:var(--fb);font-size:12px;line-height:1.6"
            placeholder="z.B. 'Flowige Expert-Linie mit großem Drop am Ende. Beste Zeit: trocken. Besonders anspruchsvoll: der Steinfeld-Abschnitt nach der ersten Kurve.'"
            maxlength="400"
            oninput="document.getElementById('trk-desc-len').textContent=this.value.length+'/400'"
            onchange="_onTrkDescChange(this.value)"></textarea>
          <div style="display:flex;justify-content:flex-end;margin-top:3px">
            <span id="trk-desc-len" style="font-size:10px;color:var(--td)">0/400</span>
          </div>
          <button class="sp-btn prim" style="margin-top:8px;width:100%;justify-content:center;box-sizing:border-box"
            onclick="(()=>{const v=document.getElementById('trk-desc-inp').value;clearTimeout(_trkDescTimer);_onTrkDescChange(v);toast('✅ Beschreibung gespeichert')})()">
            ✓ Beschreibung speichern
          </button>
        </div>

        <!-- Section: Schlüsselstellen -->
        <div class="sp-section">
          <div class="sp-label">📍 Schlüsselstellen & Hindernisse</div>
          <div class="sp-hint">Drops, Northshore, Steinfelder, technische Stellen — alles an einem Ort</div>
          <div id="trk-feat-list" style="margin-top:10px"></div>

          <!-- Add form -->
          <div id="trk-feat-add" style="display:none;margin-top:8px;padding:14px;background:var(--s2);border-radius:14px;border:1.5px solid var(--bd2)">
            <div style="font-size:12px;font-weight:800;color:var(--tx);font-family:var(--fh);margin-bottom:10px">➕ Schlüsselstelle hinzufügen</div>

            <!-- Type grid — 2 columns, 5 rows -->
            <div style="display:grid;grid-template-columns:1fr 1fr;gap:5px;margin-bottom:10px">
              <button class="trk-feat-type-btn active" data-type="drop"       onclick="selectFeatType(this,'drop')"       style="padding:8px 4px;border-radius:9px;border:1.5px solid var(--ac);background:var(--ac)18;color:var(--tx);font-size:11px;cursor:pointer;font-weight:700;transition:all .15s">⬇️ Drop</button>
              <button class="trk-feat-type-btn"        data-type="steinfeld"   onclick="selectFeatType(this,'steinfeld')"   style="padding:8px 4px;border-radius:9px;border:1.5px solid var(--bd2);background:var(--s1);color:var(--tx);font-size:11px;cursor:pointer;font-weight:700;transition:all .15s">🪨 Steinfeld</button>
              <button class="trk-feat-type-btn"        data-type="verblockt"   onclick="selectFeatType(this,'verblockt')"   style="padding:8px 4px;border-radius:9px;border:1.5px solid var(--bd2);background:var(--s1);color:var(--tx);font-size:11px;cursor:pointer;font-weight:700;transition:all .15s">🪵 Verblockt</button>
              <button class="trk-feat-type-btn"        data-type="steil"       onclick="selectFeatType(this,'steil')"       style="padding:8px 4px;border-radius:9px;border:1.5px solid var(--bd2);background:var(--s1);color:var(--tx);font-size:11px;cursor:pointer;font-weight:700;transition:all .15s">🏔 Tech.Steil</button>
              <button class="trk-feat-type-btn"        data-type="northshore"  onclick="selectFeatType(this,'northshore')"  style="padding:8px 4px;border-radius:9px;border:1.5px solid var(--bd2);background:var(--s1);color:var(--tx);font-size:11px;cursor:pointer;font-weight:700;transition:all .15s">🌉 Northshore</button>
              <button class="trk-feat-type-btn"        data-type="sprung"      onclick="selectFeatType(this,'sprung')"      style="padding:8px 4px;border-radius:9px;border:1.5px solid var(--bd2);background:var(--s1);color:var(--tx);font-size:11px;cursor:pointer;font-weight:700;transition:all .15s">🦘 Sprung</button>
              <button class="trk-feat-type-btn"        data-type="flow"        onclick="selectFeatType(this,'flow')"        style="padding:8px 4px;border-radius:9px;border:1.5px solid var(--bd2);background:var(--s1);color:var(--tx);font-size:11px;cursor:pointer;font-weight:700;transition:all .15s">🌊 Flow</button>
              <button class="trk-feat-type-btn"        data-type="aussicht"    onclick="selectFeatType(this,'aussicht')"    style="padding:8px 4px;border-radius:9px;border:1.5px solid var(--bd2);background:var(--s1);color:var(--tx);font-size:11px;cursor:pointer;font-weight:700;transition:all .15s">👁 Aussicht</button>
              <button class="trk-feat-type-btn"        data-type="goal"        onclick="selectFeatType(this,'goal')"        style="padding:8px 4px;border-radius:9px;border:1.5px solid var(--bd2);background:var(--s1);color:var(--tx);font-size:11px;cursor:pointer;font-weight:700;transition:all .15s">🎯 Ziel</button>
              <button class="trk-feat-type-btn"        data-type="pause"       onclick="selectFeatType(this,'pause')"       style="padding:8px 4px;border-radius:9px;border:1.5px solid var(--bd2);background:var(--s1);color:var(--tx);font-size:11px;cursor:pointer;font-weight:700;transition:all .15s">⛺ Pause</button>
            </div>

            <input id="trk-feat-name" class="sp-input" type="text"
              placeholder="Bezeichnung (z.B. 'Wurzel-Drop am Feldweg')"
              maxlength="60" style="width:100%;box-sizing:border-box;margin-bottom:8px">

            <div style="display:flex;align-items:center;gap:8px;margin-bottom:12px">
              <span style="font-size:11px;color:var(--td);white-space:nowrap;flex-shrink:0">Schwierigkeit:</span>
              <div style="display:flex;gap:2px" id="trk-feat-diff-stars">
                <button class="feat-star" data-v="1" onclick="setFeatDiff(1)" style="font-size:19px;background:none;border:none;cursor:pointer;opacity:1;padding:0">⭐</button>
                <button class="feat-star" data-v="2" onclick="setFeatDiff(2)" style="font-size:19px;background:none;border:none;cursor:pointer;opacity:.25;padding:0">⭐</button>
                <button class="feat-star" data-v="3" onclick="setFeatDiff(3)" style="font-size:19px;background:none;border:none;cursor:pointer;opacity:.25;padding:0">⭐</button>
                <button class="feat-star" data-v="4" onclick="setFeatDiff(4)" style="font-size:19px;background:none;border:none;cursor:pointer;opacity:.25;padding:0">⭐</button>
                <button class="feat-star" data-v="5" onclick="setFeatDiff(5)" style="font-size:19px;background:none;border:none;cursor:pointer;opacity:.25;padding:0">⭐</button>
              </div>
            </div>

            <div style="display:flex;gap:7px">
              <button class="sp-btn sec" style="flex:1;justify-content:center" onclick="cancelFeatAdd()">Abbrechen</button>
              <button class="sp-btn prim" style="flex:1;justify-content:center" onclick="saveFeatAdd()">✓ Speichern</button>
            </div>
          </div>
        </div>

        <!-- Section: Streckenzustand -->
        <div class="sp-section">
          <div class="sp-label">🎽 Aktueller Streckenzustand</div>
          <div class="sp-hint">Untergrundverhältnisse — hilft dir und anderen bei der Planung</div>
          <div id="trk-editor-condition" style="margin-top:10px;display:flex;gap:6px;flex-wrap:wrap"></div>
        </div>

        <!-- Section: Änderungshistorie -->
        <div class="sp-section" style="border-bottom:none">
          <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:4px">
            <div class="sp-label" style="margin:0">🕐 Änderungshistorie</div>
            <button onclick="_clearTrkHistory()" style="font-size:10px;padding:3px 8px;border-radius:6px;border:1px solid var(--bd2);background:var(--s2);color:var(--td);cursor:pointer">Leeren</button>
          </div>
          <div class="sp-hint">Jede Änderung automatisch mit Zeitstempel protokolliert</div>
          <div id="trk-version-history" style="margin-top:10px"></div>
        </div>

      </div><!-- /trk-editor-body -->
    </div><!-- /trk-pane-features -->
  </div>

  <!-- Tab: QR-Scanner -->
  <div class="sp-content" id="sp-tab-qr">
    <div class="sp-section">
      <div class="sp-label">QR-Code Scanner</div>
      <div class="sp-hint">Lies QR-Codes von anderen Geräten: GPX-Tracks, Marker-Pakete, GMTW-Backups oder GPX-Bündel werden automatisch erkannt und importiert.</div>

      <!-- Aktivierungs-Toggle -->
      <div style="display:flex;align-items:center;justify-content:space-between;background:var(--s3);border-radius:10px;padding:10px 12px;margin-top:10px">
        <div>
          <div style="font-size:13px;font-weight:600;color:var(--tx)">QR-Scanner aktivieren</div>
          <div style="font-size:11px;color:var(--td);margin-top:2px">Erfordert Kamerazugriff</div>
        </div>
        <label style="position:relative;display:inline-block;width:44px;height:26px;cursor:pointer">
          <input type="checkbox" id="sp-qr-enabled" onchange="onQrScanToggle(this.checked)"
            style="opacity:0;width:0;height:0;position:absolute">
          <span id="sp-qr-toggle-track" style="position:absolute;inset:0;border-radius:13px;background:var(--bd2);transition:background .2s">
            <span id="sp-qr-toggle-thumb" style="position:absolute;top:3px;left:3px;width:20px;height:20px;border-radius:50%;background:#fff;transition:transform .2s;transform:translateX(0)"></span>
          </span>
        </label>
      </div>
    </div>

    <!-- Scanner-Fläche (nur sichtbar wenn aktiviert) -->
    <div id="sp-qr-scanner-area" style="display:none">
      <div class="sp-section" style="border-bottom:none;padding:0;overflow:hidden;border-radius:14px">
        <!-- Video live-feed -->
        <div style="position:relative;background:#000;border-radius:14px;overflow:hidden;aspect-ratio:1;max-height:280px">
          <video id="qr-video" autoplay muted playsinline style="width:100%;height:100%;object-fit:cover;display:block"></video>
          <canvas id="qr-canvas-scan" style="display:none"></canvas>
          <!-- Scan-Fadenkreuz -->
          <div style="position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none">
            <div style="width:60%;height:60%;border:2.5px solid var(--ac);border-radius:12px;box-shadow:0 0 0 9999px rgba(0,0,0,.35)"></div>
          </div>
          <!-- Status -->
          <div id="qr-scan-status" style="position:absolute;bottom:10px;left:0;right:0;text-align:center;font-family:var(--fh);font-size:12px;font-weight:700;color:rgba(255,255,255,.7);letter-spacing:.5px">
            QR-Code in den Rahmen halten
          </div>
        </div>
      </div>
      <!-- Erkannter Inhalt -->
      <div id="qr-scan-result" style="display:none;margin-top:12px;background:var(--s2);border:1px solid var(--bd2);border-radius:12px;padding:12px;font-size:12px;color:var(--tx)"></div>
    </div>
  </div>
</div>

<!-- ══ MARKER MODAL (Erstellen / Bearbeiten) ═══════════════════ -->
<div id="md-overlay" style="display:none;position:fixed;inset:0;z-index:1300;background:rgba(0,0,0,.7);align-items:flex-end;justify-content:center;backdrop-filter:blur(4px)">
  <div class="md-sheet" style="max-height:92dvh;overflow-y:auto">
    <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:16px">
      <span id="md-title" style="font-family:var(--fh);font-size:16px;font-weight:800;letter-spacing:.3px;text-transform:uppercase;color:var(--tx)">Marker erstellen</span>
      <button onclick="closeMdModal()" style="background:var(--s3);border:1px solid var(--bd2);border-radius:8px;color:var(--tx);width:32px;height:32px;display:flex;align-items:center;justify-content:center;cursor:pointer;font-size:16px;flex-shrink:0">×</button>
    </div>

    <!-- Symbol-Picker -->
    <div class="md-field">
      <label class="md-label">Symbol / Emoji</label>
      <div id="md-emoji-grid" style="display:flex;flex-wrap:wrap;gap:6px;margin:6px 0 4px"></div>
      <input type="hidden" id="md-emoji" value="📍">
    </div>

    <div class="md-field">
      <label class="md-label">Name <span style="color:var(--exp)">*</span></label>
      <input class="md-input" id="md-name" type="text" placeholder="z.B. Geheimtipp Abfahrt" maxlength="60">
    </div>
    <div class="md-field">
      <label class="md-label">Kategorie</label>
      <select class="md-input" id="md-cat">
        <option value="beginner">🟢 Beginner</option>
        <option value="mittel">🟡 Mittel</option>
        <option value="expert">🔴 Expert</option>
        <option value="logistik">🔵 Logistik</option>
      </select>
    </div>
    <div class="md-field">
      <label class="md-label">Beschreibung</label>
      <textarea class="md-input" id="md-desc" rows="2" placeholder="Optionale Beschreibung…" maxlength="300" style="resize:none"></textarea>
    </div>

    <!-- Maps-Link (auto-generiert) -->
    <div class="md-field">
      <label class="md-label" id="md-maps-lbl">Navigation-Link (auto)</label>
      <div style="display:flex;gap:6px">
        <input class="md-input" id="md-gmaps" type="url" placeholder="Wird automatisch erstellt…" style="flex:1" oninput="this.dataset.userEdited='1'">
        <button type="button" onclick="document.getElementById('md-gmaps').dataset.userEdited='';_updateMdMapsLink(parseFloat(document.getElementById('md-lat').value),parseFloat(document.getElementById('md-lng').value))" style="background:var(--s3);border:1px solid var(--bd2);border-radius:8px;color:var(--td);padding:0 10px;cursor:pointer;font-size:12px;white-space:nowrap;flex-shrink:0" title="Auto-generieren">↺ Auto</button>
      </div>
    </div>

    <!-- Koordinaten (readonly) -->
    <div style="display:flex;gap:8px;margin-bottom:8px">
      <div style="flex:1;background:var(--s2);border-radius:8px;padding:8px 10px">
        <div style="font-size:10px;color:var(--td);margin-bottom:2px;font-family:var(--fh);font-weight:700">LATITUDE</div>
        <div id="md-lat-disp" style="font-size:13px;font-variant-numeric:tabular-nums;color:var(--tx)">—</div>
      </div>
      <div style="flex:1;background:var(--s2);border-radius:8px;padding:8px 10px">
        <div style="font-size:10px;color:var(--td);margin-bottom:2px;font-family:var(--fh);font-weight:700">LONGITUDE</div>
        <div id="md-lng-disp" style="font-size:13px;font-variant-numeric:tabular-nums;color:var(--tx)">—</div>
      </div>
    </div>

    <!-- QR-Code für Position teilen -->
    <div id="md-share-qr-wrap" style="display:none;background:var(--s2);border-radius:12px;padding:14px;margin-bottom:12px;text-align:center">
      <div style="font-size:10px;color:var(--td);font-family:var(--fh);font-weight:700;margin-bottom:10px;letter-spacing:.5px">POSITION TEILEN</div>
      <!-- Weißer Rahmen um den QR-Code (wichtig für Scanner-Erkennung) -->
      <div style="display:inline-block;background:#fff;border-radius:12px;padding:12px;box-shadow:0 2px 12px rgba(0,0,0,.3)">
        <canvas id="md-share-qr-canvas" width="148" height="148" style="display:block;image-rendering:pixelated;image-rendering:crisp-edges"></canvas>
      </div>
      <div style="display:flex;gap:8px;margin-top:10px;justify-content:center">
        <button id="md-share-qr-dl" type="button" style="padding:6px 14px;background:var(--s3);border:1px solid var(--bd2);border-radius:8px;color:var(--td);font-size:11px;cursor:pointer;font-family:var(--fh);font-weight:700">⬇ QR laden</button>
        <button id="md-share-qr-share" type="button" onclick="_mdShareQrPos()" style="padding:6px 14px;background:var(--ac);border:none;border-radius:8px;color:#000;font-size:11px;cursor:pointer;font-family:var(--fh);font-weight:700;display:none">📤 Teilen</button>
      </div>
    </div>

    <input type="hidden" id="md-lat">
    <input type="hidden" id="md-lng">
    <input type="hidden" id="md-edit-id">
    <div class="md-acts">
      <button class="md-btn sec" onclick="closeMdModal()">Abbrechen</button>
      <button class="md-btn prim" onclick="saveMdMarker()">Marker speichern</button>
    </div>
  </div>
</div>

<!-- ══ PWA INSTALL PROMPT (v3 — gerätespezifisch) ════════════ -->
<div id="pwa-install" role="dialog" aria-modal="true" aria-label="App installieren">
  <!-- Header: Icon + Titel + Gerätebadge -->
  <div class="pi-head">
    <div class="pi-icon">🗺️</div>
    <div style="flex:1;min-width:0">
      <div class="pi-title">GMTW Trail Map</div>
      <div class="pi-sub">Offline-fähige App — kein Internet nötig</div>
      <div class="pi-badge" id="pi-device-badge">🌐 Browser</div>
    </div>
    <button onclick="dismissPwaInstall(false)" style="background:none;border:none;color:var(--td);font-size:20px;cursor:pointer;line-height:1;padding:4px;flex-shrink:0" aria-label="Schließen">✕</button>
  </div>
  <!-- Gerätespezifische Schritt-Anleitung (per JS befüllt) -->
  <div class="pi-steps" id="pi-steps">Wird geladen…</div>
  <!-- Aktionsbuttons -->
  <div class="pi-acts">
    <button class="pi-btn later" onclick="dismissPwaInstall(false)">Später</button>
    <button class="pi-btn inst" id="pi-install-btn" onclick="triggerPwaInstall()">📲 Installieren</button>
  </div>
  <!-- Permanent ablehnen -->
  <div class="pi-dismiss">
    <button onclick="dismissPwaInstall(true)">Nicht mehr fragen</button>
  </div>
</div>

</body>
</html>